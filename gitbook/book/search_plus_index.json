{"./":{"url":"./","title":"首页","keywords":"","body":"EXP-BLOGEXP 技术博客EXP-BLOG EXP 技术博客 [success] 　因上努力，果上求缘 EXP's Github 仓库 分类 权限 说明 exp-blog 资料 公开 EXP 技术博客 gitbook-server-docker 工具 公开 使用 Docker 构建的 GitBook 服务器 site-package 工具 公开 站长工具：站点功能组件 api-online 资料 公开 在线 API CTF-Solving-Reports 资料 公开 CTF 解题报告 POJ-Solving-Reports 资料 公开 POJ 解题报告 expcodes 索引 公开 经验代码库（索引目录） exp-libs 项目（Java） 公开 经验构件库（Java版） exp-libs-c 项目（C/C++） 公开 经验构件库（C/C++版） mojo-release-plugin 项目（Java） 公开 Maven 项目发布插件 mojo-archetype 项目（Java） 公开 Maven 项目规范骨架 mojo-web-archetype 项目（Java） 公开 Maven 项目规范骨架（Web版） auto-planting 项目（Python） 私有 Github 自动种草 github-tools 项目（Java） 公开 Github 工具包 account-mgr 项目（Java） 公开 帐密管理工具 auto-upgrader 项目（Java） 公开 自动化升级插件 certificate 项目（Java） 公开 软件授权插件 cron-expression 项目（Java） 公开 cron 表达式生成器 jzone-crawler 项目（Java） 私有 QQ空间爬虫（Java版） pyzone-crawler 项目（Python） 私有 QQ空间爬虫（Python版） sina-crawler 项目（Python） 私有 新浪博客爬虫 top-baidu-tieba 项目（Java） 私有 百度贴吧顶贴机 bilibili-plugin 项目（Java） 私有 哔哩哔哩插件姬 dynamic-token 项目（Java） 公开 嵌入式：动态令牌生成&校验API dt_otp 项目（C/C++） 公开 嵌入式：动态令牌-dll&so实现库 WinProcess 项目（C/C++） 公开 Windows 系统进程管理器 jvm-agent 项目（Java） 公开 JVM 代理 pydbutils-mysql 项目（Python） 私有 Python PDM 生成器 P2P-file-sharing-system 项目（Java） 公开 P2P 文件共享系统 file-port-forwarding 项目（Java） 公开 双机文件流端口转发程序 exp-xml-paper 项目（Java） 公开 XML 文本编辑器 ui-regex-debug 项目（Java） 公开 正则调试工具 pssms 项目（Java） 公开 进销存管理系统 goas 项目（Java） 公开 政府在线自动化办公系统 The-Well-Grounded-Rubyist 资料 公开 《Ruby程序员修炼之道（第2版）》 课后练习 HeadFirst-Python 资料 公开 《HeadFirst Python》 课后练习 lovely-python 资料 公开 《可爱的Python》 课后练习 The-C-Programming-Language 资料 公开 《C++程序设计语言（十周年纪念版）》 课后练习 ro-single-server 游戏 私有 仙境RO传说-单机版-服务端（支持联机） ro-single-client 游戏 私有 仙境RO传说-单机版-客户端（登陆补丁） environment 资源 公开 环境安装包 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 15:43:45 "},"markdown/technical/algorithm/":{"url":"markdown/technical/algorithm/","title":"算法","keywords":"","body":"算法算法 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/algorithm/acm/":{"url":"markdown/technical/algorithm/acm/","title":"ACM 资料","keywords":"","body":"ACM 资料ACM 资料 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/algorithm/poj/":{"url":"markdown/technical/algorithm/poj/","title":"POJ 解题报告","keywords":"","body":"POJ 解题报告POJ 解题报告 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/safe/":{"url":"markdown/technical/safe/","title":"安全","keywords":"","body":"安全安全 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-30 14:08:43 "},"markdown/technical/safe/pentest/":{"url":"markdown/technical/safe/pentest/","title":"渗透测试","keywords":"","body":"渗透测试渗透测试 白帽子渗透测试入门资源：参考书、课程、工具、认证 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 12:43:45 "},"markdown/technical/safe/pentest/白帽子渗透测试入门资源.html":{"url":"markdown/technical/safe/pentest/白帽子渗透测试入门资源.html","title":"白帽子渗透测试入门资源","keywords":"","body":"白帽子渗透测试入门资源：参考书、课程、工具、认证前言名词解析Pwk课程与OSCP证书CTF工具参考书相关文献推荐资源下载白帽子渗透测试入门资源：参考书、课程、工具、认证 前言 初入渗透测试领域，过程中遇到不少错综复杂的知识，也遇到不少坑，特此记录，慢慢整理慢慢填。 名词解析 名词 全称 解析 PwK Penetration Testing with Kali Linux Kali-Linux 渗透测试培训课程 OSCP Offensive Security Certified Professional 攻防安全专家认证 OWASP Open Web Application Security Project 开放式Web应用程序安全项目它提供有关计算机和互联网应用程序的公正、实际、有成本效益的信息，如《2017 Top 10 应用风险评估报告》其目的是协助个人、企业和机构来发现和使用可信赖软件 SCAP Security Content Automation Protocol 安全内容自动化协议已成立了SCAP中文社区，集成了协议框架中的CVE、CCE、CPE、CWE、CVSS、OVAL等6种网络安全相关标准数据库 CVE Common Vulnerabilities and Exposures 公共漏洞与暴露每个CVE都有唯一编号，是一个漏洞字典表 EXP Exploit 安全术语，指可利用点（如漏洞、代码等） vul Vulnerabilities 安全术语，泛指漏洞 PoC Proof of Concept 漏洞的概念证明，常见是一段可复盘漏洞的代码 payload - 安全术语，有效载荷，泛指漏洞利用成功后所要做的事情（如Cracker会做一些有害的或者恶性的动作） WAF Web Application Firewall Web应用防护系统（也称为：网站应用级入侵防御系统） Fuzz Fuzz testing 模糊测试，一种安全测试方法它介于完全的手工测试和完全的自动化测试之间而手工测试是指渗透测试，即模拟Cracker进入系统查找漏洞 社工 社会工程学攻击 安全术语，泛指通过心理战术，欺诈他人以收集信息、行骗和入侵计算机系统的行为 XSS Cross Site Scripting 跨站脚本攻击（缩写首字母为X是为了不与CSS混淆）根据攻击特点分为：反射型XSS、存储型XSS、DOM-XSS DoS Denial of Service 拒绝服务攻击 DDoS Distributed Denial of Service 分布式拒绝服务攻击 SQLi SQL Inject SQL注入式攻击 CSRF Cross-site request forgery 跨站请求伪造攻击 CORS Cross-Origin Resource Sharing 跨源资源共享 GDPR General Data Protection Regulation 通用数据保护条例，在2018-5-25由欧盟正式出台该条例的适用范围极为广泛，任何收集、传输、保留或处理涉及到欧盟所有成员国内的个人信息的机构组织均受该条例的约束，号称史上最严个人数据保护条例 Pwk课程与OSCP证书 OSCP认证：是一个专门针对 PwK课程 的国际安全专业认证。该认证机构声称，OSCP认证是一个区别于所有其它认证的考试，考试全程采取手动操作实战的方式，而不设笔试环节。这是在安全领域含金量非常高的国际认证。 认证条件：无 考试模式：OSCP的认证考试也是另类的存在，考生拥有24小时的时间（实际是23小时45分钟）去完成考试，具体如何分配时间由考生自己决定。题目是5台主机（随机抽取），目标是攻入并拿到最高权限（ROOT/SYSTEM）。基于难度级别，成功执行的攻击会获得相应的积分。24小时结束之后，你还有24小时去完成并提交考试报告（需要详细说明攻击步骤和里程碑截屏来证明确实攻破并获得相应权限）。 考试费用：最低 $ 800 （30天实验室访问学习 + 考试认证） 相关链接： OSCP概述 PwK培训材料 CTF Capture The Flag，夺旗赛。 通过在线靶场进行实战，磨炼网络安全技巧的一种竞技。这里推荐几个免费的 CTF 站点： Root Me CG-CTF Vulhub 不建议找答案，勇敢地刷题吧！ 可以很好地锻炼发掘EXP的能（nao）力（dong）~ 工具 工具 简介 下载 Kali-Linux 渗透测试的必备工具包Kali是一个基于 Debian 的 Linux 发行版，专门用于渗透测试的工具系统大多数做安全测试的渗透和审计开源工具都被尽可能多地囊括在内 官网 CVEList CVE字典表 Github SecLists OWASP维护的一个安全信息列表集合该集合包括了用于渗透的各种类型的列表，这些列表包含了237个字典文件以及常用的 Web Shell 攻击载荷，字典文件类型众多，如用户名、密码、域名、敏感数据特征码、模糊测试载荷等 Github Exploit Database 可利用漏洞数据库（在线）罗列了最新被发现的CVE和PoC等信息，可用于学习漏洞原理和复盘 官网 SearchSploit 与 Exploit Database 配套的命令行工具包（已集成到Kali）它把Exploit Database的数据保存在本地机器（攻击方），通过搜集目标机器（防御方）的信息，在本地发现这些信息的EXP，然后在本地机器提取对应的PoC上传到目标机器实现渗透 官网 Hydra 弱密码爆破工具（已集成到Kali） Github Burp Suite 用于攻击web 应用程序的集成平台（谁用谁知道） 官网破解版密：gsqygf Arachni 基于Ruby的Web漏洞扫描工具算不上强大但有其特色，用于评估web应用程序的安全性不仅能对基本的静态或CMS网站进行扫描，还能识别大部分平台的指纹信息（硬盘序列号和网卡物理地址） 官网Github XSStrike 基于python的XSS漏洞扫描和利用工具它对参数进行模糊测试之后构建合适的payload，然后对参数进行穷举匹配，大多数payload都是由作者精心构造。其内置爬虫功能，能够检测并尝试绕过WAF，且误报率极低 Github XssPy 基于python的Web应用XSS漏洞智能扫描器它不仅能检查主页或给定页面，还能够检查网站上的所有链接以及子域微软、斯坦福、摩托罗拉、Informatica等很多大型企业机构都在用 Github Wfuzz Web Fuzzer：Web应用程序评估审查工具它可以对任何字段的HTTP请求中的数据进行模糊处理 Github OpenSCAP 基于C/C++实现的SCAP协议开源框架目的是为SCAP各个标准协议的使用者提供一套简单易用的接口 官网中文社区Github Hackvertor 黑客工具包看看黑客们平时都在用什么工具 官网 SSL/TLS安全评估报告 检查HTTPS网站的SSL证书安全性 在线检查 SecurityHeaders 通过分析HTTP响应头，评估相关安全选项是否配置得当可根据评估建议修改配置 在线检查 URL Fuzzer 扫描Web服务器上的隐藏文件/目录是否存在敏感信息 在线检查 MD5Online MD5解密：通过已知的Hash字典逆向爆破（论MD5加salt的重要性） 在线使用 truffleHog 排查 Git 项目中是否包含可疑的敏感信息 Github BFG Repo-Cleaner 移除 Git 库中的大文件或污点提交 官网Github brakeman 通过静态代码扫描发现代码里的SQL注入问题 Github gixy Nginx 配置文件静态分析器防止安全配置错误，并自动进行缺陷检测 Github bleach HTML净化器对HTML片段进行标签或属性过滤，预防XSS攻击 GithubPython版PHP版 New PHP Snippet PHP在线运行环境 在线使用 RequestBin 临时 HTTP 服务器，用于收集 HTTP 请求，XSS 利器 在线使用 参考书 参考书（Kali系列） 简介/版本 下载 Penetration Testing with Kali Linux (pwk.1.0) Kali-Linux渗透测试学习指南PwK官方文档v1.0.1 - 2014版 腾讯微云密码：4vi4bw Instant Kali Linux 2013Kali快速入门指导 腾讯微云密码：ryxi47 Basic Security Testing with Kali Linux 2014基于Kali的安全测试 腾讯微云密码：qw9ym8 Hacking with Kali - Practical Penetration Testing Techniques 2014渗透测试实践技术 腾讯微云密码：xk8a3z Kali Linux Cookbook 2013Kali指导手册 腾讯微云密码：xhgjcd Kali Linux Social Engineering 2013基于Kali的社会工程 腾讯微云密码：gs4xay Kali Linux：Assuring Security By Penetration Testing 2014通过渗透测试确保安全 腾讯微云密码：6nrp2k Web Penetration Testing with Kali Linux 2013web应用渗透测试 腾讯微云密码：2cxp9c 参考书（Metasploit系列） 简介/版本 下载 Metasploit渗透测试魔鬼训练营 2013.国内中文原创详细讲解了Metasploit渗透测试的技术、方法和技巧，并提供实战的实验室环境 腾讯微云密码：i9ihtu Metasploit The Penetration Tester's Guide 2011渗透测试入门指导 腾讯微云密码：6gurxk Metasploit Penetration Testing Cookbook Jun.2012渗透测试指导手册 腾讯微云密码：r4q73x 参考书（BackTrack5系列） 简介/版本 下载 Offensive Security - Penetration Testing with BackTrack (Lab Guide) v3.2渗透测试实验室指导手册 腾讯微云密码：fj9sqt BackTrack 5 Wireless Penetration Testing Beginner's Guide 无线网络渗透测试入门指导 腾讯微云密码：pdeqfn 参考书（其他） 简介/版本 下载 影响力（中文版） 社会工程学人为什么犯贱？ 腾讯微云密码：ssyf25 欺骗的艺术（中文版） 社会工程学世界著名黑客传奇 腾讯微云密码：wtpih9 Learning Nessus for Penetration Testing Jan.2014基于Nessus的渗透测试 腾讯微云密码：dak9um PP.Penetration Testing with the Bash shell May.2014基于Bash的渗透测试 腾讯微云密码：7saehu The Basics of Hacking and Penetration Testing( Ethical Hacking and Penetration Testing Made Easy ) 2011渗透测试的基本理论 腾讯微云密码：z9enyr The Basics of Hacking and Penetration Testing( Ethical Hacking and Penetration Testing Made Easy ) The 2nd Edition, 2013渗透测试的基本理论 腾讯微云密码：5nwjt3 Advanced Penetration Testing For Highly-Secured Environments The Ultimate Security Guide 2012终极指南：高安全环境的渗透测试 腾讯微云密码：3u3c9t Gray Hat Hacking The 2nd Edition灰帽子黑客 腾讯微云密码：4tvjgb Hacking - Firewalls And Networks How To Hack Into Remote Computers 防火墙突破：远程网络渗透 腾讯微云密码：k93xfx Hacking The Art Of Exploitation The 2nd Edition, 2018漏洞利用的艺术 腾讯微云密码：5c5ee6 Hacking Wireless Networks For Dummies 2005无线网络窃听 腾讯微云密码：px7hgj Penetration Testing A Hands-On Introduction to Hacking 2014渗透测试实践指导 腾讯微云密码：996jfr Practical Hacking - Techniques and Countermeasures 黑客实践的技术与对策 腾讯微云密码：ne75b9 相关文献推荐 社会工程： 信息安全之社会工程学（需翻墙）：常识扫盲、信息收集、假冒身份、施加影响 《影响力》——人为什么犯贱 有哪些「社会工程学」攻击手段？ 防范社会工程学攻击的技巧与姿势 场景案例： Penetration Testing with Kali (PWK) 课程和 Offensive Security Certified Professional (OSCP) 考试回顾 XSS实战：我是如何拿下你的百度账号 如何构建自己的渗透测试环境 驱散前端安全梦魇——DOMXSS典型场景分析与修复指南 CSRF 攻击的应对之道 DDOS 攻击的防范教程 海量日志中，如何实时在线检测未知异常行为？看瀚思的序列异常算法 记一次在实战靶机中使用SearchSploit的总结 Paypal 2FA Bypass（通过删掉HTTP请求参数绕过验证） 部分利用社工技巧的群发邮件样本关联分析 主机入侵： 主机威胁入侵检测开源工具与规则 OSSEC主要功能及原理+详细配置+日志文件分析 集中式日志系统 ELK 协议栈详解 浅谈大型网络入侵检测建设 Linux提权： A GUIDE TO LINUX PRIVILEGE ESCALATION Linux提权基础介绍（是前一篇的译文） Basic Linux Privilege Escalation 史上最全Linux提权后获取敏感信息方法（是前一篇的译文） 初识linux提权 渗透测试中的Linux提权 Linux提权？这四个脚本可以帮助你 Linux提权：从入门到放弃 Windows提权： Windows Privilege Escalation Fundamentals Windows下的渗透测试之提权的基本套路[上][下]（是前一篇的译文） Windows提权笔记 Privilege Escalation Windows Windows 提权命令指南 Windows提权的几种姿势 内网渗透之如何玩转Meterpreter？ Windows内核漏洞利用提权教程 Metasploit、Powershell之AlwaysInstallElevated提权实战 metasploit 渗透测试笔记(meterpreter篇) WebShell： webshell原理 bash反弹shell原理解析 基于机器学习的web异常检测 机器学习入门之像使用Print一样使用算法检测WebShell OSSEC与webshell实时监控探索 HTTP相关： HTTP cookies HTTP 安全最佳实践 跟着 Github 学习 Restful HTTP API 设计 其他： 米斯特白帽培训讲义 知道创宇研发技能表v3.1 大学霸 Kali Linux 安全渗透教程 大数据安全分析漫谈 浅析ReDoS的原理与实践 最好用的开源Web漏扫工具梳理 How to completely remove a file from a Git repository 渗透测试常用工具集合 资源下载 [!NOTE|style:flat|icon:fa fa-cloud-download|label:Download] 腾讯微云（密码：mpgksn） Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 13:30:48 "},"markdown/technical/crawler/":{"url":"markdown/technical/crawler/","title":"爬虫","keywords":"","body":"爬虫爬虫 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/deeplearn/":{"url":"markdown/technical/deeplearn/","title":"深度学习","keywords":"","body":"深度学习深度学习 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/blockchain/":{"url":"markdown/technical/blockchain/","title":"区块链","keywords":"","body":"区块链区块链 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/bigdata/":{"url":"markdown/technical/bigdata/","title":"大数据","keywords":"","body":"大数据大数据 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/re/":{"url":"markdown/technical/re/","title":"逆向工程","keywords":"","body":"逆向工程逆向工程 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/":{"url":"markdown/notes/language/","title":"开发语言","keywords":"","body":"开发语言开发语言 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/c/":{"url":"markdown/notes/language/c/","title":"C/C++","keywords":"","body":"C/C++C/C++ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/java/":{"url":"markdown/notes/language/java/","title":"Java","keywords":"","body":"JAVAJAVA Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/python/":{"url":"markdown/notes/language/python/","title":"Python","keywords":"","body":"PYTHONPYTHON Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/ruby/":{"url":"markdown/notes/language/ruby/","title":"Ruby","keywords":"","body":"RUBYRUBY Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/ass/":{"url":"markdown/notes/language/ass/","title":"汇编","keywords":"","body":"汇编汇编 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/datastruct/":{"url":"markdown/notes/datastruct/","title":"数据结构","keywords":"","body":"数据结构数据结构 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/design/":{"url":"markdown/notes/design/","title":"设计模式","keywords":"","body":"设计模式设计模式 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/database/":{"url":"markdown/notes/database/","title":"数据库","keywords":"","body":"数据库数据库 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/net/":{"url":"markdown/notes/net/","title":"网络","keywords":"","body":"网络网络 Corba 接口学习笔记 Centos 实现端口转发：Rinetd 部署笔记 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-07 08:57:47 "},"markdown/notes/net/Corba接口学习笔记.html":{"url":"markdown/notes/net/Corba接口学习笔记.html","title":"Corba 接口学习笔记","keywords":"","body":"Corba接口学习笔记1. CORBA简介2. CORBA的基本概念2.1. ORB（Object Request Broker）对象请求代理2.2. IDL（Interface Definition Language）接口定义语言2.3. OA（Object Adapter）对象适配器2.4. GIOP（General Inter-ORB Protocol）通用ORB协议2.5. 其他常见概念3. CORBA的体系结构4. CORBA的应用程序结构5. Java IDL简介5.1. 认识IDL5.2. IDL中的几个重要概念5.3. IDL元素与Java元素的映射关系6. CORBA接口开发入门6.1. Borland VisiBroker Edition简介6.2. 开发环境的安装6.3. CORBA版Hello World应用开发实例7. CORBA常用的四种服务简介7.1. 名字服务7.2. 事件服务7.3. 通知服务7.4. 交易服务Corba接口学习笔记 1. CORBA简介 CORBA（Common Object Request Broker Architecture），公用对象请求代管者体系结构，它是为了实现分布式计算而引入的。为了说明CORBA在分布计算上有何特点，我们从它与其它几种分布计算技术的比较中进行说明。 与过去的面向过程的RPC（Remote Procedure Call）不同，CORBA是基于面向对象技术的，它能解决远程对象之间的互操作问题。 MicroSoft的DCOM（Distributed Component Object Model）也是解决这一问题的，但它基于Windows操作系统，虽然DCOM已有在其他操作系统如Sun Solaris，Digital Unix，IBM MVS上的实现，但毫无疑问，只有在微软的操作系统上才会实现得更好。而只有CORBA是真正跨平台的，平台独立性正是CORBA的初衷之一。 另一种做到平台无关性的技术是Java RMI（Remote Method Invocation），但它只能用JAVA实现。CORBA与此不同，它通过一种叫IDL（Interface Definition Language）的接口定义语言，能做到语言无关，也就是说，任何语言都能制作CORBA组件，而CORBA组件能在任何语言下使用。 因此，可以这样理解CORBA：CORBA一种异构平台下的语言无关的对象互操作模型。 2. CORBA的基本概念 2.1. ORB（Object Request Broker）对象请求代理 CORBA体系结构的核心就是ORB。 下图为ORB的基本模型，它作为一个\"软件总线\"来连接网络上的不同对象，提供对象的定位和方法调用，可以这样简单理解：ORB就是使得客户应用程序能调用远端对象方法的一种机制。 具体来说就是：当客户程序要调用远程对象上的方法时，首先要得到这个远程对象的引用，之后就可以像调用本地方法一样调用远程对象的方法。当发出一个调用时，实际上ORB会截取这个调用（通过客户Stub完成），因为客户和服务器可能在不同的网络、不同的操作系统上甚至用不同的语言实现，ORB还要负责将调用的名字、参数等编码成标准的方式（称为Marshaling）通过网络传输到服务器方（实际上在同一台机器上也如此），并将参数通过Unmarshaling的过程传到正确的对象上（这个过程叫重定向，Redirecting），服务器对象完成处理后，ORB通过同样的Marshaling/Unmarshaling方式将结果返回给客户。 因此，ORB是一种功能，它具备以下能力： 对象定位（根据对象引用定位对象的实现） 对象定位后，确信Server能接受请求 将客户方请求通过Marshaling/Unmarshing方式重定向到服务器对象上 如果需要，将结果以同样的方式返回 [info] Marshaling一个对象的过程就是一个序列化（deflating）的过程，相应的Unmarshaling就可以看作是反序列化（inflating）的过程。 2.2. IDL（Interface Definition Language）接口定义语言 如果说ORB使CORBA做到平台无关，那么IDL则使CORBA做到语言无关。 正像其名字中显示的那样，IDL仅仅定义接口，而不定义实现，类似于C中的头文件。实际上它不是真正的编程语言。要用它编写应用，需要将它映射它相应的程序设计语言上去，如映射到C++或JAVA上去。映射后的代码叫Client Stub Code和Server Skeleton Code。 IDL的好处是使高层设计人员不必考虑实现细节而只需关心功能描述。IDL可以说是描述性语言。设计IDL的过程也是设计对象模型的过程。它是编写CORBA应用的第一步，在整个软件设计过程中至关重要。 IDL的语法很像C++，当然也像Java。很难想像一个程序设计人员是不懂C或Java的，所以，几乎所有的程序设计人员都能迅速理解IDL。而这正是IDL设计者所希望的。 2.3. OA（Object Adapter）对象适配器 OA用于构造对象实现与ORB之间的接口。它给框架发送方法，调用并且支持服务器对象的生命周期，完成对象引用的生成、维护，对象定位等功能。对象适配器有各种各样的，常用的有两种： BOA（Basic Object Adapter）基本对象适配器：负责激活对象，即当客户请求对象的服务时，激活对象实现的能力。 POA（Portable Object Adapter）可移植对象适配器：是BOA的替代方式，提供大量可扩展的接口，来处理一些对于BOA来说不合理的要求。 2.4. GIOP（General Inter-ORB Protocol）通用ORB协议 我们知道，客户和服务器是通过ORB交互的，那么，客户方的ORB和服务器方的ORB又是通过什么方式通信呢？通过GIOP(General Inter-ORB Protocol)。也就是说，GIOP是一种通信协议，它规定了客户和服务器的ORBs间的通信机制。 GIOP设计的尽可能简单，开销最小，同时又具有最广泛的适应性和可扩展性，以适应不同的网络。它定义了以下两个方面： The Common Data Representation (CDR) definition.（通用数据表示定义）：它实际上是IDL数据类型在网上传输时的编码方案。它对所有IDL数据类型的映射都作了规定。 GIOP Message Formats（GIPO消息格式）：它规定了Client和Server两个角色之间要传输的消息格式。主要包括Request和Reply两种消息。 GIOP因为是一种通用协议，所以不能直接使用。在不同的网络上需要有不同的实现。目前使用最广的便是Internet上的GIOP，称为IIOP（Internet Inter-ORB Protocol），IIOP把GIOP消息数据映射为TCP/IP连接行为和输入/输出流读/写。 [info] IIOP不是完全从GIOP分离出来的协议，它更像是GIOP的一个实例。 2.5. 其他常见概念 DII（Dynamic Invocation Interface）动态调用接口：位于客户端，发送客户端的调用请求。 DSI（Dynamic Skeleton Interface）动态框架接口，位于服务器端，传送客户端的调用请求。 SII（Static Invocation Interface）静态调用接口：位于客户端，客户与ORB之间的静态接口。 SSI（Static Skeleton Interface）静态框架接口：位于服务器端，ORB与服务器之间的静态接口。 stub存根：位于客户端，由IDL编译器编译IDL文件生成，其功能类似一个客户代理。 skeleton框架：位于服务器端，由IDL编译器编译IDL文件生成，其功能是负责发送一个操作调用给能实现此操作的服务。 IR（Interface Repository）接口存储库：存储运行时所需要的IDL规范。 IMR（Implementation Repository）实现存储库：存储对象实现（一个服务器）的详细信息（即一个执行程序需要被放置在哪一个服务器上）。 IOR（Interoperable Object Reference）可操作对象引用：它包括所有客户与服务器联系所需的各种信息（包括CORBA服务器对象进程的IP地址和TCP端口等），ORB将通过它产生在网络上唯一标识那个将被分布对象的消息。 ORBAservices（CORBA服务）：在ORB级别之上，定义了大多数分布式企业对象利用的公共服务，如命名服务、交易对象服务、关系服务、生命周期服务、外表化服务、持久性服务、查询服务、对象集合服务、属性服务、事件服务、许可证服务、时间服务、事务服务、并发控制服务和安全服务等。 CORBAfacilities（CORBA工厂）：位于CORBAservices之上，定义了更高层次的分步式服务与框架。如：打印、电子邮件、文档管理等。 3. CORBA的体系结构 上图为CORBA的体系结构图，它描述了以下内容： CORBA规范中定义了IDL语言及其向其他高级语言的映射。类似于COM中的IDL语言，OMG的IDL语言通过说明对象的接口来定义对象，它也是一种描述性语言。一个接口同样包括一组命名的操作和相应于这些接口的参数。 ORB核心提供了客户与对象间实现透明通信的方法，它可以屏蔽对象实现位置、实现方式、状态和通信机制等细节以及不同实现间可能存在的差异。 对象适配器位于ORB核心和对象实现之间，它负责服务对象的注册、对象引用的创建和解释、对象实现的服务进程的激活和去活、对象实现的激活和去活以及客户请求的分发。 IDL存根为客户提供了静态调用方式，IDL构架为客户提供了静态实现方式。IDL编译器编译描述服务对象接口的IDL文件，生成对应于具体编程语言的IDL存根和IDL构架程序。IDL存根负责把用户的请求进行编码，发送到对象实现端，并对接收到的处理结果进行解释，把结果或异常信息返回给用户；IDL构架对用户请求进行解码，定位所请求的对象的方法，执行该方法，并把执行结果或异常信息编码后发送给客户。 动态调用接口DII（Dynamic Invocation Interface）和动态构架接口DSI（Dynamic Skeleton Interface）提供了动态调用方法和动态实现方法。某些情况下客户预先不知道服务对象的接口信息，需要通过查询或者采用其他的手段获得服务对象的接口描述信息，然后使用DII动态调用ORB核心接口的方法来构造客户请求并发送到对象实现。在对象实现方可以使用DSI动态分发用户请求的机制，以便动态的处理客户方的请求。客户和对象实现所采用的方式并不一定要对应，也就是说，客户方支持的静态和动态两种调用方式，对象实现方支持的静态和动态两种实现方式，经过组合后得到的4种方式都可能出现。例如，客户方可能使用静态调用方式，而对象实现方使用动态构架接口，反之亦然。 在动态方式下，需要查询相应的服务对象的接口描述信息（在静态方式下，这些信息由IDL文件来描述），这些信息由接口库提供。接口库通常以IDL描述文件为其输入，将接口描述信息进行处理后存放在文件、数据库或者其他形式的存储机制中，并提供一组标准的调用接口供客户查询使用。服务对象的描述信息也由接口库提供。 4. CORBA的应用程序结构 上图为CORBA的应用程序结构，它显示了CORBA应用程序各部件间的调用关系，ORB在CORBA客户和服务器之间传递方法调用和相关信息。 在CORBA应用系统中主要分为两部分：一是位于应用程序服务器中的CORBA对象，另一个是应用使用的客户程序。这些客户程序通过CORBA技术使用CORBA对象提供的服务来完成其工作。CORBA规范定义了客户程序与服务程序中的对象如何进行通信的机制。 对象请求代理（ORB）负责处理它们之间的通信。ORB提供了支持分布式处理的机制：为请求查找具体的对象实现，让对象实现作好接收请求的准备，传送构成请求的数据等。客户所看到的接口完全独立于对象所在的物理位置，实现对象的编程语言，以及在对象的接口中没有反映出来的其他特性。ORB通过IDL程序框架或动态程序框架来定位相应的实现代码、传送参数，以及对对象实现的传送控制。 处理通信的对象分别称为存根和构架。客户端为存根（Stub），服务器端为构架（Skeleton）。在客户端，存根对象担当CORBA对象的代理，当客户程序调用CORBA对象的方法时，存根把调用传递给ORB，ORB使用Smart Agent程序定位CORBA服务器。在CORBA服务器上，ORB应用程序把调用传递给构架，构架ORB的通信需要经过BOA（Basic Object Adaptor ，基本对象适配器），CORBA服务器运行指定的过程，然后由相反的路径返回结果。 Smart Agent用来定位CORBA服务器。启动程序时，自动访问Smart Agent。如果要支持CORBA，应该在局域网的某台机器上运行Smart Agent，当然也可以启动多个Smart Agent，以提高系统的可靠性。当客户机或服务器启动时，它们通过广播消息寻找Smart Agent，因此无需事先知道Smart Agent的位置。ORB实际上是一组放在动态库orb-r.dll中的函数，用户很少直接调用该DLL中的函数，系统在必要的时候调用他们。当服务器启动时，ORB向Smart Agent注册CORBA服务器。 5. Java IDL简介 5.1. 认识IDL module helloidl{ interface Hello{ string sayHello(); }; }; 上述的代码就是一个简单的IDL。在IDL中，接口定义以分号结尾。 IDL只能用来表示接口而无法用来编程。IDL描述的CORBA对象必须要被实现，例如用C++或Java来实现。 将IDL翻译为Java编程语言的规则统称为Java编程语言的绑定（Java programming language binding）。语言绑定由OMG负责标准化，所有的CORBA提供商都必须使用相同的规则，将IDL的产品映射到特定的编程语言。 5.2. IDL中的几个重要概念 5.2.1. 异常 异常包含如下环节： （1）定义异常处理； （2）引发异常； （3）捕捉异常，异常处理。 其中环节（1）应该在OMG IDL中进行，（2）（3）环节应该在客户端对象实现中进行。 定义异常用exception关键字，抛出异常用raises关键字。下面是简单的IDL异常代码： interface Warehose{ exception BadCustomer {string reason;}; //自定义异常 ProductSeq find(in Customer c) raises BadCustomer; //抛出异常 }; [info] IDL编译器会将异常类型翻译为一个类。 5.2.2. 继承 用OMG IDL可定义继承、多重继承以及跨模块继承。使用冒号“:”表示继承。下面是简单的IDL继承代码： interface Book{ attribute string isbn; }; interface Book:Product{}; 5.2.3. 变量、常量与属性 在CORBA接口中不能使用变量。但可以包含常量，如： const int NUMBER = 404; 接口还可以包含属性。属性看起来就像实例变量，但它们其实是一对访问器（accessor）与改写器（mutator）方法的简化。相当于Java中的setXXX、getXXX。但如果属性声明为readonly，就不生成改写器方法。 5.2.4. in、out和inout参数的使用 定义一个方法时，对于参数传递，除了Java编程语言提供的选择之外，还有其他选择。每个参数都可以声明为in、out或者inout。 一个in参数仅仅是传递给方法，与Java中的参数传递机制相同。但是Java中没有与out参数类似的东西。方法在返回前，会在每一个out参数中保存一个值，而方法调用者可以取得保存在out参数中的值。 如果参数只是声明为out，那么方法就不应该指望该参数被初始化。如果参数声明为inout，那么调用者需要为方法提供参数的初始值，然后，该方法可以修改这个值，而调用者能够获取修改后的值。 在Java中，这些参数可由特殊的持有者类（holder class）来模拟，持有者类由Java IDL编译器生成。IDL编译器为每个接口生成一个后缀为Holder的类。每个持有者类都有一个被称为value的公共实例变量。 Holder结尾的类主要用于out类型的参数传递，其中通过xxxHolder.value值能得到返回的值。示例IDL代码如下所示： Product p; //接口 ProductHolder pHolder = new ProductHolder(); w.locate(descr, pHolder); //pHolder为out类型的参数，调用locate方法后，会将pHolder对象中的value属性赋值。 p = pHolder.value; //取得返回后的值 [info] IDL不支持方法重载，因此必须为每个方法采用不同的名称。对于一些基础类型，已经预定义了它们的持有者，如IntHolder、DoubleHolder等。 5.3. IDL元素与Java元素的映射关系 上图为IDL中的元素以及与Java中元素的映射关系。 OMG IDL中的基本数据类型包括：Long、Short、unsigned long、unsigned short、float、double、char、boolean、Octet、any（其中any可以用来和任何一种数据类型匹配，包括构造数据类型以及数组）。 构造数据类型包括：struct、union、enum、sequence、String。 在IDL中，可以用sequence定义大小可变的数组（相当于Java中的数组）。如果希望限定一维序列的上限，可采用sequence的方式来定义，还可以嵌套定义如sequence>在声明sequence的参数或返回值之前，必须先定义一个类型。例如，下面定义了一个\"产品序列\"的类型： typedef sequence ProductSeq; 然后就可以在方法声明中使用该类型了： interface Warehouse{ ProductSeq find(in Customer c); }; 6. CORBA接口开发入门 6.1. Borland VisiBroker Edition简介 Borland VisiBroker是市场上最流行的CORBA环境之一，目前最新版是6.5。它支持C＋＋和JAVA语言来开发CORBA应用程序，提供跨网络、跨硬件的应用和服务的交互功能。 并且由于它可以轻松地与包括CORBA2.6在内的所有ORB版本互操作，使得用Java编写CORBA应用时，不必学习IDL和其他CORBA特性，减少了开发者的学习负担；可以把已有的RMI应用移植到CORBA运行环境上，有效地利用了已有的开发资源。 6.2. 开发环境的安装 6.2.1. 安装JDK 由于Borland VisiBroker 6.5只支持JDK1.3.1或JDK1.4.1，更高的JDK版本不能够运行VisiBroker。 以下以JDK1.3.1_15为例，安装目录为C:\\Program Files\\Java\\jdk1.3.1_15。在“我的电脑 -- 属性 -- 高级 -- 环境变量 -- 系统变量”中设置以下三个变量值（若没有则创建）： JAVA_HOME：C:\\Program Files\\Java\\jdk1.3.1_15 Path：%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin CLASSPATH：.;%JAVA_HOME%\\lib;%JAVA_HOME%\\lib\\tools.jar 若本已安装并配置好高版本的JDK，可以再安装JDK1.3.1或JDK1.4.1，然后把环境变量JAVA_HOME的值修改为JDK1.3或1.4的目录即可。 如下图所示，在DOS下执行命令“java -version”可查看当前JDK版本： 6.2.2. 安装Borland VisiBroker Edition 下载Borland.Enterprise.Server.v6.5.AppServer.Edition-ZWTiSO.zip，解压得到zkbsea65.bin，用虚拟光驱（假设盘符为G）打开该文件，以下为安装过程： （1）执行G:\\Windows\\installer.exe； （2）选择BES VisiBroker Edition； （3）安装目录选择D:\\software\\work\\VisiBroker； （4）一直点击“下一步”直到出现“安装”按钮，点击开始安装； （5）安装完成后会弹出一个界面要求注册License，点击“Cancle”按钮取消，安装成功； （6）运行cmd，执行G:\\crack>java -jar LicenseMaker_For_BES65.jar，然后选择D:\\software\\work\\VisiBroker\\var文件夹，点击确定后注册License成功； （7）备份D:\\software\\work\\VisiBroker\\var目录下的borland.lic文件（因为重启电脑可能会重写borland.lic，导致出现“Borland Enterprise Server License error”错误，无法执行start vbj Server）。 （8）检查和设置windows的系统环境变量（可选，在DOS下执行或直接写入“我的电脑 -- 属性 -- 高级 -- 环境变量 -- 系统变量”中）： set VBROKERDIR=D:\\software\\work\\VisiBroker set VBROKER_ADM=%VBROKERDIR%\\adm set BES_LIC_DIR=%VBROKERDIR%\\var set BES_LIC_DEFAULT_DIR=%VBROKERDIR%\\license set OSAGENT_PORT=14000 set Path=%VBROKERDIR%\\bin 6.2.3. 开发环境测试 可利用VisiBroker为用户提供的一些例子进行测试环境，测试步骤如下： （1）“开始 -- 运行 -- cmd”，进入DOS系统，然后使用cd命令进入目录D:\\software\\work\\VisiBroker\\examples\\vbe\\basic\\bank_agent，执行vbmake.bat； （2）执行osagent命令，运行智能代理服务，右下角会出现Smart Agent的运行图标； （3）执行start vbj Server，运行CORBA服务器程序，若执行成功则会出现如图 2-8所示的DOS框； （4）执行vbj Client duyh，运行CORBA客户端程序，若执行成功则会出现如图 2-9所示的DOS框； （5）测试完成。 6.3. CORBA版Hello World应用开发实例 6.3.1. 应用需求 客户端通过CORBA接口调用的方式，请求执行服务端中对象的方法，服务器返回相应的字串符给客户端。 6.3.2. 定义IDL 根据需求只定义一个接口和相应该的返回字串的方法，hello.idl文件的内容如下： //hello.idl module helloidl{ interface Hello{ string sayHello(); }; }; 把hello.idl文件保存到D:\\corba_test目录下。 6.3.3. IDL的编译与解释 “开始 -- 运行 -- cmd”，进入DOS系统，然后使用cd命令进入目录D:\\corba_test，执行命令“idl2java hello.idl”对hello.idl文件进行编译，编译成功后会在D:\\corba_test目录出现一个文件夹hello.idl，并且其中有7个java文件。 对生成的各个文件说明如下： _HelloStub.java：客户Hello对象的存根代码。 Hello.java：Hello接口声明。 HelloHelper.java：声明HelloHelper类，定义有用的实用工具方法。 HelloHolder.java：声明HelloHolder类，这为传递Hello对象提供容器。 HelloOperation.java：本接口说明hello.idl文件中的Hello接口中所定义的方法签名。 HelloPOA.java：服务器端Hello对象实央的POA服务参象代码。 HelloPOATie.java：通过使用tie机制，在服务器端用以实现Hello对象的类。 6.3.4. 编写Server端的接口实现代码 6.3.4.1. HelloImpl.java 引入了POA概念后，Server方的实现对象称为Servant，编写实现代码实际上就是对IDL定义的每个interface，都编写一个Servant，其中要实现interface中定义的每个方法。. 这里我们将Servant类定义为HelloImpl.java，代码如下： //HelloImpl.java import helloidl.*; public class HelloImpl extends HelloPOA { public String sayHello() { return \"\\nHello world !!\\n\"; } } 6.3.4.2. HelloServer.java Servant仅是实现代码，而Server是包含main()函数的可执行的代码。Server的主要任务就是创建所需的Servant，同时通知POA已准备就绪，可以接受客户方的请求。 新建一个文件HelloServer.java，代码如下： //HelloServer.java import org.omg.CORBA.*; import org.omg.PortableServer.*; public class HelloServer { public static void main(String args[]) { try { // 初始化ORB ORB orb = ORB.init(args, null); // 取得根POA的引用 POA rootPOA = POAHelper.narrow(orb .resolve_initial_references(\"RootPOA\")); // 持久的POA创建策略 org.omg.CORBA.Policy[] policies = { rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT) }; // 使用正确的策略创建myPOA POA myPOA = rootPOA.create_POA(\"hello_world_poa\", rootPOA .the_POAManager(), policies); // 创建服务对象 HelloImpl managerServant = new HelloImpl(); orb.object_to_string(null); // 确定服务对ID byte[] managerId = \"HelloManager\".getBytes(); // 用myPOA上的ID激活服务对象 myPOA.activate_object_with_id(managerId, managerServant); // 激活POA管理器 rootPOA.the_POAManager().activate(); System.out.println(myPOA.servant_to_reference(managerServant) + \" is ready.\"); // 等待进入的请求 orb.run(); } catch (Exception e) { System.err.println(\"ERROR: \" + e); e.printStackTrace(System.out); } } } 6.3.5. 编写Client端的接口实现代码 6.3.5.1. HelloClient Client程序就是客户方的可执行程序，它需要使用到Server方的服务。 新建一个文件HelloClient.java，代码如下： //HelloClient.java import helloidl.*; import org.omg.CORBA.*; public class HelloClient { static Hello helloImpl; public static void main(String args[]) { try { // 初始化ORB ORB orb = ORB.init(args, null); // 得到一个管理器ID byte[] managerId = \"HelloManager\".getBytes(); // 找到一个对象管理器。给出POA全各及服务对象ID。 helloidl.Hello manager = helloidl.HelloHelper.bind(orb, \"/hello_world_poa\", managerId); // 输出结果 System.out.println(manager.sayHello()); } catch (Exception e) { System.out.println(\"ERROR : \" + e); e.printStackTrace(System.out); } } } 6.3.6. 程序的编译和运行 编译客户端和服务端程序并运行，步骤如下： （1）把3个java文件HelloImpl.java、HelloServer.java和HelloClient放到目录D:\\corba_test下； （2）“开始 -- 运行 -- cmd”，进入DOS系统，然后使用cd命令进入目录D:\\corba_test，然后执行命令“vbjc HelloClient.java”编译客户端代码，执行命令“vbjc HelloServer.java”编译服务端代码； （3）执行osagent命令，运行智能代理服务； （4）执行start vbj HelloServer，运行CORBA服务器程序； （5）执行vbj HelloClient，运行CORBA客户端程序，结果输出“Hello World!!”。 7. CORBA常用的四种服务简介 7.1. 名字服务 名字服务允许将一个或多个逻辑名与一个对象引用联结起来，并将名称存储在一个命名空间（namespace）中，也允许客户应用使用命名服务，以通过使用分配给对象的逻辑名称来取得该对象的引用。 相对于智能代理使用的平面型命名空间，命名服务则使用层次型的命名空间，结构类似于java中的包中的结构，如（com.xyz.corba）。 使用VisiBroker的命名服务中，对象实现使用NamingContext对象以将名称限制到它们所提供的对象。客户应用使用NamingContext来解析限制到对象引用的名称。 NamingContext通过rosolve方法取得逻辑Name中的对象引用，因为一个Name可以包含一个或多个NameComponent对象，所以解析能在NameComponent结构中来回移动，只要取其中的一个节点的对象引用，即可获得整个NameComponent结构的所有对象引用。 字串化的名称用于对应字串和CosNaming::Name，用“/”来分隔名称组件；用“.”来分隔id和kind属性；用“\\”来作转义字符。如： com/xyz/corba ... // 名称字串化\"com/xyz/corba\"的代码 NameComponent[] continentName = { new NameComponent(\"com\", \"\") }; NamingContext continentContext = rootNamingContext.bind_new_context(continentName); NameComponent[] departmentName = { new NameComponent(\"xyz\", \"\") }; NamingContext departmentContext = continentContext.bind_new_context(departmentName); NameComponent[] objectName = { new NameComponent(\"corba\", \"\") }; departmentContext.rebind(objectName,myPOA.servant_to_reference(managerServant)); ... 7.2. 事件服务 核心ORB支持的通信模型是实现客户端与服务器的一对一同步通信，通知服务则可支持更丰富的需求，包括： 支持分布/预订应用程序，如多对多 支持单向、异步和缓冲事件分布，其吞吐量远大于同步通信 对持服务质量，如事件/连接可靠性 支持事件筛选 TCP/IP用于实现接收者、提供者和事件通道之间的通信。分为“拉”和“推”的两种通信模型。事件通道使提供者和接收者不需确定对方的通信模型。 推式模型更为普遍。推型接收者将大多时间花费在事件的回路中，等待从ProxyPushSupplier而来的数据。 拉式模型是事件通道定期从提供者拉出数据，拉型提供者将大多时间花费在网络事件回路中，等待接收从ProxyPullConsumer发出的数据请求。 7.3. 通知服务 通知服务的实现模式跟事件服务类似。 7.4. 交易服务 “一手交钱，一手交货”是交易的基本原则，它的等价命题是既不能提了货却不给钱，又不能给了钱却没提货，在现实生活中，有许多对象之间的操作存在这种类似关系：要么这些操作全都进行，要么这些操作全都不进行，这种关系的操作就构成了事务（Transaction）。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-07 08:42:05 "},"markdown/notes/net/Rinetd部署笔记.html":{"url":"markdown/notes/net/Rinetd部署笔记.html","title":"Rinetd 部署笔记","keywords":"","body":"Centos 实现端口转发：Rinetd 部署笔记前言Rinetd部署环境Rinetd安装Rinetd配置Rinetd使用资源下载Centos 实现端口转发：Rinetd 部署笔记 前言 虽然Linux本身自带的iptables可以实现端口转发功能，但其配置相对复杂。因此本文介绍另一个端口转发工具Rinetd，其安装和配置都更为简单。 Rinetd部署环境 本文是基于Centos7系统部署Rinetd端口转发工具。 Rinetd安装 到官网下载最新版，得到安装包rinetd.tar.gz ： 官网地址：https://boutell.com/rinetd/ 上传到Linux，本文上传位置为： /usr/local/ 解压安装包： tar -zxvf rinetd.tar.gz 由于Rinetd需要编译安装，先安装gcc编译环境： yum install gcc 进入Rinetd安装目录： cd /usr/local/rinetd 检查安装配置文件： vi Makefile 注意配置文件中涉及到两处安装路径，一般情况下保持默认值即可： CFLAGS=-DLINUX -g rinetd: rinetd.o match.o gcc rinetd.o match.o -o rinetd install: rinetd install -m 700 rinetd /usr/sbin install -m 644 rinetd.8 /usr/man/man8 但是若 /usr/man/man8 目录不存在，需要先手建： mkdir -p /usr/man/man8 编译并安装： make && make install 至此Rinetd安装完成。 Rinetd配置 配置端口转发规则（该文件可能不存在，直接创建即可）： vi /etc/rinetd.conf 该文件每行一个转发规则，配置格式为： [source_address] [source_port] [destination_address] [destination_port] 即： [本机IP（若非多网卡直接设为0.0.0.0）] [转发端口] [服务IP] [服务端口] 如： 0.0.0.0 9527 192.168.64.22 9527 Rinetd使用 Rinetd的启动需要指定规则配置文件，而停止需要杀掉进程： 启动：rinetd -c /etc/rinetd.conf 停止：killall rinetd 查看端口转发状态： netstat -tanulp|grep rinetd 资源下载 [!NOTE|style:flat|icon:fa fa-cloud-download|label:Download] 本文全文下载 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-07 08:58:05 "},"markdown/notes/scm/":{"url":"markdown/notes/scm/","title":"配置管理","keywords":"","body":"软件配置管理软件配置管理 Ansible-Tower 部署笔记 Git命令行安装与使用笔记 VisualSVN 使用手册 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 14:42:58 "},"markdown/notes/scm/AnsibleTower部署笔记.html":{"url":"markdown/notes/scm/AnsibleTower部署笔记.html","title":"Ansible-Tower 部署笔记","keywords":"","body":"Ansible-Tower 部署笔记前言1. 部署说明1.1. 安装环境1.2. 安装清单2. 安装步骤2.1. 安装 pywinrm（可选）2.2. 添加相关用户并授权2.3. 安装 Ansbile-2.7.52.4. 安装 PostgreSQL-9.62.5. 安装 Ansible-Tower-3.3.32.6. Ansible-Tower授权3. 附：被控主机为 Windows 时的额外配置3.1. 查看 PowerShell 与 .NET 版本并升级3.2. 安装并查看 WinRM 服务3.3. Ansible 测试 WinRM 连接Ansible-Tower 部署笔记 前言 作为时下最流行的自动化运维工具之一，Ansible 在业界应该是无人不知无人不晓的了。 作为一款轻量化的开源软件，它只需要简单地通过 SSH（对Linux平台）或 PowerShell（对Windows平台），无需被控主机安装客户端，就能实现远程操控、部署、升级等配置管理。 通过编写简单的 playbooks（yml） 脚本就能轻松对成千上万的主机进行区域管控、日常巡检等任务。 而 Ansible-Tower （旧称 AWX）作为其配套界面，使得 Ansible 更容易上手。 这里提供一些官方资料： Ansible 官网 : https://www.ansible.com/ Ansible-Tower 官网 : https://www.ansible.com/products/tower Ansible 官方文档（全） : https://docs.ansible.com/ Ansible 官方教程（英文版） : https://docs.ansible.com/ansible/latest/index.html Ansible 官方教程（中文版） : http://www.ansible.com.cn/docs/intro.html Ansible Github : https://github.com/ansible 1. 部署说明 本文主要记录了在 ubuntu 上部署 Ansible 和 Ansible-Tower 的过程。 虽然 Ansible-Tower 支持在多种操作系统版本上部署，但对于 ubuntu 只支持 14.0 和 16.0 两个版本（而 Ansible 则是支持到 ubuntu 18.0）。 为了可以同时安装 Ansible 和 Ansible-Tower ，本文选择了 ubuntu 16.0 系统进行安装。 1.1. 安装环境 操作系统：Ubuntu 16.04.5 LTS 预装软件：python 2.7、openssh 1.2. 安装清单 pywinrm （要求版本至少为 0.2.2，若不管理 windows 机器则无需安装） Ansible-2.7.5 （ 要求 python 版本 2.6 或 2.7 ） PostgreSQL-9.6 Ansible-Tower-3.3.3 （ 要求 Ansible 版本至少为 2.2，PostgreSQL版本至少为 9.6 ） 预装组件要求可查看官方手册指引：https://docs.ansible.com/ansible-tower/latest/html/quickinstall/prepare.html 2. 安装步骤 注意下述步骤直接依次复制执行即可完成整个部署流程，其中对于命令行前缀： 【#】表示 root 用户 【$】表示普通用户 2.1. 安装 pywinrm（可选） # apt install python-pip # 安装 pip # pip install --upgrade pip # 更新 pip # pip install \"pywinrm>=0.2.2\" # 使用 pip 安装 pywinrm，此模块用于远程管理 windows 机器 2.2. 添加相关用户并授权 # adduser ansible # 添加 ansible 专用用户 # chmod u+w /etc/sudoers # 修改 sudo 配置文件为可写 # vi /etc/sudoers # 修改 sudo 配置文件，对 ansible 和 postgres 用户授权，便于后面安装 root ALL=(ALL:ALL) ALL ansible ALL=(ALL:ALL) ALL awx ALL=(ALL:ALL) ALL # 安装 Ansible-Tower 时自动创建的用户 postgres ALL=(ALL:ALL) ALL # 安装 PostgreSQL 时自动创建的用户 # chmod u-w /etc/sudoers 2.3. 安装 Ansbile-2.7.5 相关过程整理自官方手册：https://ansible-tran.readthedocs.io/en/latest/docs/intro_installation.html#apt-ubuntu # su - ansible # 切换到 ansible 用户 $ sudo apt-get install software-properties-common # 在早期 Ubuntu 发行版中, “software-properties-common” 名为 “python-software-properties”，根据实际情况修改 $ sudo apt-add-repository ppa:ansible/ansible $ sudo apt-get update $ sudo apt-get install ansible # 安装 $ ansible --version # 若安装成功，核验版本 ansible 2.7.5 config file = /etc/ansible/ansible.cfg configured module search path = [u'/home/ansible/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/dist-packages/ansible executable location = /usr/bin/ansible python version = 2.7.15rc1 (default, Nov 12 2018, 14:31:15) [GCC 7.3.0] 关于 Asible 的相关配置： 　　　○ 配置文件位置为 /etc/ansible/ansible.cfg 　　　○ 主机清单文件为 /etc/ansible/hosts （用于配置主机分组、连接方式等） 　　　○ playbooks 目录位置默认为 /etc/ansible/ ，若目录不存在，可手工创建 2.4. 安装 PostgreSQL-9.6 部分过程参考自CSDN：https://blog.csdn.net/zpf336/article/details/50843674 # 注意 Ubuntu 16.0 默认的 PostgreSQL 安装源是 9.5 版本的，不符合要求，需要更新安装源后再安装 $ sudo add-apt-repository \"deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main\" $ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - $ sudo apt-get update $ sudo apt-get install postgresql-9.6 # 安装完成后会自动新增数据库用户 postgres $ sudo su postgres $ psql postgres # 登录数据库 ALTER USER postgres with PASSWORD 'postgres'; # 修改 postgres 用户的数据库密码 \\q # 退出数据库 # 修改数据库配置（ 默认只允许本地连接，由于只有 Ansible-Tower 用，因此无需更改相关连接配置 ） $ vi /etc/postgresql//main/postgresql.conf # 此处的 根据实际安装的 PostgreSQL 版本修改 password_encryption = on # 去掉注释，启用密码验证登录方式 # 重启数据库使配置生效 $ sudo systemctl unmask postgresql $ sudo systemctl restart postgresql $ psql -U postgres -h 127.0.0.1 # 测试本地账密登录 CREATE USER ansible WITH PASSWORD 'ansible'; # 创建 Ansible-Tower 用的数据库用户 ansible CREATE DATABASE tower OWNER ansible; # 创建 Ansible-Tower 用的数据库 tower GRANT ALL PRIVILEGES ON DATABASE tower TO ansible; # 把 tower 库的所有权限授权给 ansible 用户 \\q # 退出数据库 # 测试使用 ansible 用户登录 tower 数据库： $ psql -U ansible -h 127.0.0.1 -d tower \\q # 可选（需图形界面支持） $ sudo apt-get install pgadmin3 # 可安装 PostgreSQL 库的图形客户端 $ pgadmin3 # 启动客户端 2.5. 安装 Ansible-Tower-3.3.3 相关过程整理自官方手册：https://docs.ansible.com/ansible-tower/latest/html/quickinstall/download_tower.html 部分过程参考自CSDN：https://blog.csdn.net/CodyGuo/article/details/78875717 在 ubuntu 系统下，Ansible-Tower 只能下载 Ansible 的 playbooks 脚本，由 Ansible 在线安装。 playbooks 脚本可从 此处 提取（目前最后的 latest 版是3.3.3）。 下载最后版本 ansible-tower-setup-latest.tar.gz 后，上传到任意目录即可。 # 上传到 ansible-tower-setup-latest.tar.gz 到 /tmp 目录 $ sudo su ansible # 切换 ansible 用户执行安装过程 $ tar xvzf ansible-tower-setup-latest.tar.gz # 解包 $ cd ansible-tower-setup- # tower_version 根据实际的 Ansible-Tower 版本号修改 $ vi inventory # 修改安装配置，根据前面流程设置的参数对号入座即可 [tower] localhost ansible_connection=local [database] [all:vars] admin_password='admin' pg_host='127.0.0.1' pg_port='5432' pg_database='tower' pg_username='ansible' pg_password='ansible' rabbitmq_username=tower rabbitmq_password='admin' rabbitmq_cookie=cookiemonster # 执行安装 $ sudo ./setup.sh 2.6. Ansible-Tower授权 安装成功后，可通过访问 https:/// 登录 Ansible-Tower （只能使用 HTTPS 协议） 登录账密在前面安装时已配置为：admin/admin （登录成功后，可以在【Users】里面修改） 登录成功后需要导入License授权，License 可以在官网申请，官方提供了 10 个管理节点的 免费 License 3. 附：被控主机为 Windows 时的额外配置 相关内容参考自： 　　　○ 官方指引手册（英文版）：https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html 　　　○ 官方指引手册（中文版）：https://ansible-tran.readthedocs.io/en/latest/docs/intro_windows.html# 　　　○ 百度百家号：https://baijiahao.baidu.com/s?id=1580415145694814528&wfr=spider&for=pc 为了控制 Windows 主机，作为被控端的 Windows 必须具备以下几个条件： 操作系统版本限制为：桌面版 Windows 7、8.1、10 ；服务器版 Windows Server 2008、2012、2016 Windows上必须已经安装了 PowerShell 3.0 或更新版本 Windows上必须已经安装了 .NET Framework 4.0 或更新版本 WinRM 服务已经被创建并启动服务，相关服务端口没有被防火墙等拦截 3.1. 查看 PowerShell 与 .NET 版本并升级 运行 PowerShell （注意不是 CMD，一般 Win8 之后都默认安装） 输入命令 Get-Host 可查看当前 PowerShell 版本 输入命令 $PSVersionTable.CLRVersion 可查看当前 .NET Framework 版本 若 PowerShell 版本不满足要求，可参考 此处 的升级步骤进行升级 3.2. 安装并查看 WinRM 服务 详细安装步骤可参考 这里 为方便起见，Ansible 官方已提供了 WinRM 的自动安装与配置脚本：https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1 下载脚本后，在 PowerShell 执行命令即可完成安装： powershell.exe -ExecutionPolicy ByPass -File ConfigureRemotingForAnsible.ps1 安装完成后，输入命令 winrm enumerate winrm/config/Listener 或 winrm qc 可查看 WinRM 的服务状态 确认 WinRM 正在监听 HTTPS 5986 端口即配置成功，注意防火墙也要开放相关端口 3.3. Ansible 测试 WinRM 连接 注意，Ansible 主机必须已安装 pywinrm，相关步骤详见 这里 测试方法：修改 Ansible 主机的配置文件 /etc/ansible/hosts，在其末尾添加一行（其中 ${win_ip}、 ${win_username}、 ${win_password} 需根据实际情况修改）： ${win_ip} ansible_user=\"${win_username}\" ansible_password=\"${win_password}\" ansible_port=\"5986\" ansible_connection=\"winrm\" ansible_winrm_server_cert_validation=\"ignore\" ansible_winrm_transport=\"ssl\" 然后执行命令 ansible ${win_ip} -m win_ping 即可，若响应为 pong 则配置成功： Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-07 08:35:20 "},"markdown/notes/scm/Git命令行安装与使用笔记.html":{"url":"markdown/notes/scm/Git命令行安装与使用笔记.html","title":"Git 命令行安装与使用笔记","keywords":"","body":"Git命令行安装与使用笔记1. 安装环境2. Git下载3. Git安装4. 连接Github5. Git命令手册5.1. 专有名词5.2. 新建代码库5.3. 配置5.4. 增加/删除文件5.5. 代码提交5.6. 分支5.7. 标签5.8. 查看信息5.9. 远程同步5.10. 撤销5.11. 其他6. 示例：工作中使用Git的一般流程资源下载Git命令行安装与使用笔记 1. 安装环境 操作系统：Centos 7 （纯命令行环境） Git服务器：Github 安装的Git命令行版本：1.8.3.1 2. Git下载 首先需要安装git的依赖包： yum install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel 切到安装目录： cd /usr/local Centos自带的Git版本比较旧，这里直接到官网下载最新版 ： wget http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.xz 注意下载回来的是.xz包（注意不是.gz包，我下载的时候，.gz包是0字节，可能是官方的问题），对其解压： xz -d git-latest.tar.xz tar -xvf git-latest.tar 解压出来的文件夹是 git-xxxx-xx-xx（xxxx-xx-xx是版本的日期，例如2018-07-23），切到该目录下： cd git-xxxx-xx-xx 3. Git安装 生成Git的配置脚本configure： autoconf 修改安装路径，可随意指定： ./configure --prefix=/usr/local/git 注意，若指定的安装路径不存在，则需要先预建目录： mkdir -p /usr/local/git 编译并安装： make | make install 把Git命令添加到系统环境变量，修改系统环境变量文件： vi /etc/profile 在文件最后添加以下内容： GIT_HOME=/usr/local/git PATH=$PATH:$GIT_HOME/bin export GIT_HOME PATH 重载系统环境变量使其生效： source /etc/profile 通过查看git版本号验证是否安装成功： git --version 至此Git命令行安装完成。 注： ○ 若安装时不通过 ./configure --prefix=xxx 命令指定安装路径，那么Git的可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share ○ 那么当需要卸载Git时，要么在原来的make目录下执行make uninstall（前提是make文件指定过uninstall），要么在上述目录中把相关的文件一个个手工删掉。 ○ 但若指定了安装路径，则只需直接删掉该路径文件夹即可。 4. 连接Github 配置Github的账号和邮箱： git config --global user.name \"你的Github账号\" git config --global user.email \"你的Github邮箱\" 生成该GitHub账号的SSH Keys（本质是RSA公私钥）： ssh-keygen -t rsa -C \"你的Github邮箱\" 运行该命令后，系统会确认一些问题，什么都不用输入，保持默认，连续三次回车即可。 期间系统会提示所生成的RSA公私钥保存位置（一般在~/.ssh目录）： 私钥文件位置：~/.ssh/id_rsa 公钥文件位置：~/.ssh/id_rsa.pub 私钥不要动，只需把公钥设置到Github上就可以实现连接了。 先查看公钥文件内容： cat ~/.ssh/id_rsa.pub 然后在浏览器登陆你的Github： Settings => SSH and GPG Keys => New SSH key 把公钥内容复制进去并保存即可： 注： 以后在这台Centos机器连接到Github时，就是使用这对RSA公私密钥，而不用通过Github密码，所以需要保管好这对密钥。 回到Centos，输入以下命令尝试连接到Github： ssh -T git@github.com 此时会提示以下内容，输入yes即可： The authenticity of host 'github.com (xxx.xxx.xxx.xxx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? yes 最终提示以下内容则表示连接成功： Warning: Permanently added 'github.com, xxx.xxx.xxx.xxx' (RSA) to the list of known hosts. Hi smartwen! You've successfully authenticated, but GitHub does not provide shell access. 此时随便指定一个目录并切换进去，如： cd /tmp/ 把该目录初始化为Git的代码仓库： git init 然后就可以同步Github上的项目代码（和它的整个代码历史）到本地了： git clone 项目仓库URL 5. Git命令手册 由于Centos下并不支持图形化界面（我用的是云服务器，纯命令行），因此需要熟悉Git的命令进行代码版本维护。 一般来说，日常使用只要记住下图6个命令就可以了： 但为了日后使用方便起见，此处整理一下Git的命令清单： 5.1. 专有名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 5.2. 新建代码库 # 在当前目录新建一个Git代码库 git init   # 新建一个目录，将其初始化为Git代码库 git init [project-name]   # 下载一个项目和它的整个代码历史 git clone [url] 5.3. 配置 Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 git config --list   # 编辑Git配置文件 git config -e [--global]   # 设置提交代码时的用户信息 git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 5.4. 增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ...   # 添加指定目录到暂存区，包括子目录 git add [dir]   # 添加当前目录的所有文件到暂存区 git add .   # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 git add -p   # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ...   # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file]   # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 5.5. 代码提交 # 提交暂存区到仓库区 git commit -m [message]   # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message]   # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a   # 提交时显示所有diff信息 git commit -v   # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message]   # 重做上一次commit，并包括指定文件的新变化 git commit --amend [file1] [file2] ... 5.6. 分支 # 列出所有本地分支 git branch   # 列出所有远程分支 git branch -r   # 列出所有本地分支和远程分支 git branch -a   # 新建一个分支，但依然停留在当前分支 git branch [branch-name]   # 新建一个分支，并切换到该分支 git checkout -b [branch]   # 新建一个分支，指向指定commit git branch [branch] [commit]   # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch]   # 切换到指定分支，并更新工作区 git checkout [branch-name]   # 切换到上一个分支 git checkout -   # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch]   # 合并指定分支到当前分支 git merge [branch]   # 选择一个commit，合并进当前分支 git cherry-pick [commit]   # 删除分支 git branch -d [branch-name]   # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] 5.7. 标签 # 列出所有tag git tag   # 新建一个tag在当前commit git tag [tag]   # 新建一个tag在指定commit git tag [tag] [commit]   # 删除本地tag git tag -d [tag]   # 删除远程tag git push origin :refs/tags/[tagName]   # 查看tag信息 git show [tag]   # 提交指定tag git push [remote] [tag]   # 提交所有tag git push [remote] --tags   # 新建一个分支，指向某个tag git checkout -b [branch] [tag] 5.8. 查看信息 # 显示有变更的文件 git status   # 显示当前分支的版本历史 git log   # 显示commit历史，以及每次commit发生变更的文件 git log --stat   # 搜索提交历史，根据关键词 git log -S [keyword]   # 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --pretty=format:%s   # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 git log [tag] HEAD --grep feature   # 显示某个文件的版本历史，包括文件改名 git log --follow [file] git whatchanged [file]   # 显示指定文件相关的每一次diff git log -p [file]   # 显示过去5次提交 git log -5 --pretty --oneline   # 显示所有提交过的用户，按提交次数排序 git shortlog -sn   # 显示指定文件是什么人在什么时间修改过 git blame [file]   # 显示暂存区和工作区的代码差异 git diff   # 显示暂存区和上一个commit的差异 git diff --cached [file]   # 显示工作区与当前分支最新commit之间的差异 git diff HEAD   # 显示两次提交之间的差异 git diff [first-branch]...[second-branch]   # 显示今天你写了多少行代码 git diff --shortstat \"@{0 day ago}\"   # 显示某次提交的元数据和内容变化 git show [commit]   # 显示某次提交发生变化的文件 git show --name-only [commit]   # 显示某次提交时，某个文件的内容 git show [commit]:[filename]   # 显示当前分支的最近几次提交 git reflog   # 从本地master拉取代码更新当前分支：branch 一般为master git rebase [branch] 5.9. 远程同步 # 下载远程仓库的所有变动 git fetch [remote]   # 显示所有远程仓库 git remote -v   # 显示某个远程仓库的信息 git remote show [remote]   # 增加一个新的远程仓库，并命名 git remote add [shortname] [url]   # 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch]   # 上传本地指定分支到远程仓库 git push [remote] [branch]   # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force   # 推送所有分支到远程仓库 git push [remote] --all 5.10. 撤销 # 恢复暂存区的指定文件到工作区 git checkout [file]   # 恢复某个commit的指定文件到暂存区和工作区 git checkout [commit] [file]   # 恢复暂存区的所有文件到工作区 git checkout .   # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset [file]   # 重置暂存区与工作区，与上一次commit保持一致 git reset --hard   # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit]   # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit]   # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit]   # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit]   # 暂时将未提交的变化移除，稍后再移入 git stash git stash pop 5.11. 其他 # 生成一个可供发布的压缩包 git archive 6. 示例：工作中使用Git的一般流程 （1）下载远程代码仓库并创建分支： 　　　　git clone [远程代码仓库] 　　　　git branch [本地分支名称] （创建本地分支） 　　　　git branch （查看本地所有分支） 　　　　git checkout [本地分支名称] （切换到本地分支） （2） 写代码....... （3） 确认变更并提交： 　　　　git status （查看文件改变记录） 　　　　git diff （查看代码级改变） 　　　　git add （确认改变） 　　　　git commit -m 提交注释 （提交到当前分支的本地工作区） 　　　　git push [远程分支：origin] [本地分支的名称] （上传本地分支到远程仓库） （4） 去Git管理网站（如Github）创建Merge Request （5） 等待管理员（有选择地）合并所有人的Merge Request （6） 管理员合并后，从远程代码仓库更新本地分支： 　　　　git checkout master （切换至master） 　　　　git pull （从远程master更新至本地master） 　　　　git checkout [本地分支名称] （切换至本地分支） 　　　　git rebase master [本地分支名称] （从本地master拉取代码更新当前分支） （7） 拉取更新过程中，若有冲突的解决方法： 　　　　① 修改代码文件并解决冲突 　　　　② git add . （加入待提交） 　　　　③ git rebase --continue （继续执行前面第6步的rebase） 　　　　④ 如果仍然有冲突，重复前面①②③步骤 　　　　⑤ git rebase --skip （无法解决冲突时的处理手法1：直接用master覆盖本地分支） 　　　　⑥ git push -f origin [本地分支名称] （无法解决冲突时的处理手法2：强制用本地的代码去覆盖掉远程仓库的代码。其中origin为远程仓库名） （8） 去Git管理网站（如Github）重新创建Merge Request （9） 等待管理员合并Merge Request....... （10）重复上述对应步骤....... 资源下载 [!NOTE|style:flat|icon:fa fa-cloud-download|label:Download] CSDN 下载 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 13:30:48 "},"markdown/notes/scm/VisualSVN使用手册.html":{"url":"markdown/notes/scm/VisualSVN使用手册.html","title":"VisualSVN 使用手册","keywords":"","body":"VisualSVN 使用手册1. VisualSVN Server简介2. TortoiseSVN简介3. VisualSVN Server的安装4. VisualSVN Server的配置5. TortoiseSVN的安装6. VisualSVN Server与TortoiseSVN的基本组合使用7. 资源的同步与共享7.1. 浏览器连接SVN服务器查看和下载资源7.2. TortoiseSVN的Checkout功能导出SVN服务器资源8. Eclipse的SVN插件安装9. Eclipse与SVN服务器的连接10. 利用SVN插件进行代码的同步与共享10.1. 从SVN服务器上把代码同步到本地10.2. 把本地的代码共享到SVN服务器10.3. 本地代码与服务器代码的更新和冲突处理11. *版本控制资源下载VisualSVN 使用手册 —— By EXP 2012.02.14 第 2 次修订 1. VisualSVN Server简介 介绍VisualSVN Server之前，首先说说Subversion。 Subversion是一个自由，开源的版本控制系统。在Subversion管理下，文件和目录可以超越时空。Subversion将文件存放在中心版本库里。这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况。这样就可以籍此将数据恢复到以前的版本，并可以查看数据的更改细节：做了哪些修改，谁做的修改，等等。正因为如此，许多人将版本控制系统当作一种神奇的“时间机器”。 Subversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程度上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行（单线进行也就是必须一个一个进行），开发进度会进展迅速。此外，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量—如果出现不正确的更改，只要撤销那一次更改操作即可。 某些版本控制系统本身也是软件配置管理系统（如SCM），这种系统经过精巧的设计，专门用来管理源代码树，并且具备许多与软件开发有关的特性—比如，对编程语言的支持，或者提供程序构建工具。不过Subversion并不是这样的系统。它是一个通用系统，可以管理任何类型的文件集。 VisualSVN和Subversion一样，都是版本控制器SVN的服务端，一个重要区别是VisualSVN比Subversion配置起来容易的多了。 如果直接使用Subversion，那么在Windows 系统上，要想让它随系统启动，就要封装SVN Server为Windws service，还要通过修改配置文件来控制用户权限，另外如果要想以Web方式（http协议）访问，一般还要安装配置Apache，如果是新手，岂不是很头痛？ 而VisualSVN Serve集成了Subversion和Apache，省去了以上所有的麻烦。安装的时候SVN Server已经封装为Windws service，Apache服务器的配置也只是在图像界面上，指定认证方式、访问端口等简单操作；另外，用户权限的管理也是通过图像界面来配置。 需要知道的是，VisualSVN和VisualSVN Server又有一定区别，两者虽然同是SVN的服务端，但前者是收费的，后者是免费的。 还有一点， 用VisualSVN Server所搭建的服务器仅能在局域网下工作，这是团队开发中必须要注意的，所有成员都必须在同一局域网才能进行资源的同步与共享。一旦客户机与服务机跨越了路由，便无法相连。 2. TortoiseSVN简介 TortoiseSVN 是 Subversion 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。 实际上安装TortoiseSVN后，它是以一种类似“右键插件”的方式存在，使用TortoiseSVN能够更方便地管理SVN服务器上的资源，在团队开发中能够更有效实时地共享所有资源。 这里使用TortoiseSVN的一个主要原因是为了使用它的一个基本功能：把代码或资源迁入SVN服务器以达到同步共享的目的。 3. VisualSVN Server的安装 先到网上下载VisualSVN Server的最新版（当前为2.1.10）。 运行 VisualSVN-Server-2.1.10.msi 安装程序后，点击Next按钮继续。 勾选“I accept the terms in the License Agreement”选择框，点击Next按钮继续下一步操作。 选择完全安装方式，点击Next按钮继续。 到这里开始要注意： “Location”为VisualSVN Server的安装目录，可任意选择。 “Repositories”为SVN代码仓库的位置，即在使用时共享资料的位置，因此基于方便使用的考虑，不建议该位置设置太深（一般在磁盘根目录下再建一层即可），否则以后使用时同步资源库不方便。 “Server Port”为服务端口选择，后面有一个选择框“Use secure connection”。不勾选该选择框为使用快速链接【http协议】，此时供选择的端口有80/81/8080三个；勾选该选择框为使用安全链接【https协议】，这时的端口只有433/8433二个可用。 一般建议选择安全链接【https协议】，即勾选选择框，端口使用默认的即可。设置完毕点击Next按钮继续下一步，然后一直到安装完成即可。 4. VisualSVN Server的配置 安装完VisualSVN Server后，运行VisualSVN Server Manger，启动界面，其中： “Status”为SVN服务器状态，包括运行状态和服务器URL地址。 “Logging”为服务器日志。 “Subversion Authentication”为账户（User和Groups）信息。 “Repositories”为SVN代码库信息。 首先添加一个代码库。右击“Repository”，出现下图所示的右键菜单，任意选择一种方式均可创建一个新的代码库。 然后在文本框中输入代码库名称。 需要注意的是，若选择框“Creat default structure”被选中，则在代码库StartKit下面会创建trunk、branches、tags三个子目录；不选中，则只创建空的代码库StartKit。点击OK按钮，代码库StartKit则创建成功。 创建完代码库后，没有任何内容在里面。添加内容的方法会在后面说明，这里暂且略过。 下面，开始创建用户Users。在左侧的Users上点击右键，出现下图所示的右键菜单，任意选择一种方式均可创建一个新的用户。 然后设置新用户的用户名和密码。输入信息后，点击OK按钮，就创建一个用户了。按照这种方式，创建4个用户：starter、Developer1、tester1、manager1。 然后把这些用户授权给刚才创建的代码库StartKit。只有被授权的用户才能使用StartKit代码库内的资源，与其他用户进行资源共享。具体方法如下： 首先右击刚才创建的代码库StartKit, 选择“Properties”，弹出如下界面： 点击\"Add...\"按钮，然后选择刚才创建的4个新用户，点击OK按钮则完成了授权工作。 [info] 大家可能注意到了图中的Groups。是的，我们也可以先创建组，把用户添加到各个组中，然后对组进行授权，操作比较简单，在此略过。 把用户授权给代码库后，还要继续对每个用户（或组）进行详细的权限设置： “No Access”为禁止该用户访问代码库。 “Read Only”为虽然用户可以访问代码库，但只有读资源的权限。 “Read / Write”为用户不但可以访问代码库，还能对其中的资源进行读或写。 需要注意的是，在用户列表中存在一个“Everyone”用户，为缺省用户，暂时无视之即可。 设置完权限后，点击“确定”按钮，这4个用户就具有了访问StartKit代码库的不同权限。 本例中各个用户的权限说明： 用户starter：在团队中是新来者，不希望他向代码库中提交新代码，所以他只能读取代码库中的代码，不能提交代码。 用户tester1：是测试人员，不负责代码编写，所以也是只读权限。 用户Developer1：是开发人员，自然具有读写的权限。 用户manager1：是项目经理，自然具有读写的权限。 在实际的项目开发过程中，Developer和tester往往不可能只有一个人，这时候使用组来授权会更加方便。 5. TortoiseSVN的安装 先到网上下载TortoiseSVN的最新版（当前为1.7.2）。 运行 TortoiseSVN-1.7.4.22459-x64-svn-1.7.2.msi安装程序后，点击Next按钮继续。 此时点选“I accept the terms in the License Agreement”选择框，点击Next按钮继续下一步操作。 然后选择安装目录，任意即可。设置完毕点击Next按钮继续下一步，然后一直到安装完成。 点击Finish按钮后TortoiseSVN即安装完毕，但此时可能会提示重启系统，其实不重启也没有关系。 6. VisualSVN Server与TortoiseSVN的基本组合使用 注意在使用SVN服务之前，要先确保关闭Windows防火墙，否则可能出现无法连接到SVN服务器的情况。 关闭Windows防火墙的方法是： 右击计算机 -> 属性 -> 系统和安全 -> Windows防火墙 -> 打开或关闭Windows防火墙 为方便下文说明，这里重新配置了一下VisualSVN Server： SVN资源库为CodeLib（代码库）和FileLib（文件库），其所在的位置可在VisualSVN Server启动界面查得： 用户及其权限分别为：（Everyone是缺省用户，暂无视之） CaiZhenBiao Read Only DengWeiWen Read Only LiaoQuanBin Read/Write LiJianCong Read Only 这里设置4个用户的密码均为123456。 然后说一下用TortoiseSVN把源代码迁入SVN服务器的例子。 首先在Eclipse新建项目TestSVN： 然后打开Eclipse的工作空间，可以找到项目TestSVN的文件夹，如下图： 右击要迁入SVN服务器的项目文件夹TestSVN，可以看到TortoiseSVN出现在右键选项中。若选择Setting则可进行相关的设置，这里不做详细说明。我们选择Import把项目TestSVN迁入SVN服务器。 此时弹出如下图所示的界面， URL ： https://Exp-PC/svn/CodeLib 就是当前要迁入的SVN服务器地址。其中 https://Exp-PC/ 是服务器名，svn是代码库的根目录，CodeLib就是刚才添加的代码库。 注意上图中左下角的“Include ignored files”，在第一次迁入源代码时没有用，可以不勾选。但是，在以后提交代码的时候是非常有用的。 点击OK按钮后则自动把TestSVN项目迁入了SVN服务器。迁入过程如下图所示。迁入完成后再点击OK关闭窗口。 此时在VisualSVN Server中点击CodeLib，可在右方看到刚才迁入SVN服务器的源代码（如下图），若没有显示，右键刷新即可。 注意：也可从这里的灰色条栏中看到当前代码库CodeLib的URL地址。 不难发现项目TestSVN的项目文件夹没有了，在CodeLib中只保留了其项目内容。这是因为“根文件夹默认不上传”，因此要把整个TestSVN项目（包括项目文件夹在内）都上传到SVN服务器，可以把整个项目复制到任意一个空文件夹A中，使得文件夹A作为根文件夹，再右击文件夹A进行上传。效果如下图所示。 [info] 资源上传到SVN服务器的是资源的副本，因此一旦资源被上传，即使在本地删除也不会对服务器中的资源有任何影响。 7. 资源的同步与共享 第6节 介绍了如何利用TortoiseSVN把源代码上传到SVN服务器，其实上传非代码的其他资源也是同样的方法，把所需上传的资源（如Word、Excel、*.rar等）放在文件夹内，右键Import即可。同样要注意的是“根文件夹默认不上传”。 本节主要介绍怎样读取已上传到SVN服务器的指定资源的方法，主要有三种： （1）浏览器连接SVN服务器查看和下载资源； （2）TortoiseSVN的Checkout功能导出SVN服务器资源； （3）Eclipse连接SVN服务器查看和导出资源。 方法（3）要在Eclipse安装SVN插件后（见 第8节）才能使用，这将在 第9节 和 第10节 介绍。所以在本节中主要介绍方法（1）和方法（2）。 7.1. 浏览器连接SVN服务器查看和下载资源 要通过浏览器连接SVN服务器，首先需要获取SVN服务器的URL地址，URL地址的获取方法如下图所示： 打开VisualSVN Server界面，右击想要连接的代码库CodeLib，点选“Copy URL to Clipboard”即把代码库的URL复制到剪贴板。 然后把URL黏贴到浏览器地址栏回车即可。 [info] 部分浏览器可能会拦截，如火狐浏览器可能会出现下图的警告。此时点击“我已充分了解可能的风险”，然后点击“添加例外”，“确认安全例外”即可。 同时请确认windows防火墙已关闭。 其他浏览器也是类似的信任安全操作。 通过浏览器拦截后，会弹出身份认证窗口。此时只需要把刚才在VisualSVN Server中设置的4个用户之中的一个账号密码输入即可。然后浏览器就会反馈出当前SVN服务器所保有的资源。 下载界面如下： 7.2. TortoiseSVN的Checkout功能导出SVN服务器资源 在任意空白位置点击鼠标右键，在弹出的功能菜单中选择“SVN Checkout”。 如上图所示（下述的“检出”实质就是把SVN服务器上的资源复制一份副本到本地）： “URL of repository”为要检出资源的SVN资源库地址。 “Checkout directory”为要检出到的位置，可自由选择。 “Checkout Depth”为检出资源的深度，默认为把整个数据库的资源都检出。若要指定检出的项目，可点击“Choose item”按钮进行选择，只勾选需要检出的资源，然后点选OK按钮。 “Revision”为版本控制选项，功能很重要，将在第11节叙述相关作用。 “Show log”为显示被选中的服务器的操作日志。 如上图为检出过程。 如下图为检出后的资源文件。其中左下角的Icon若为“绿色√”说明本地资源与服务器资源一致。当本地资源被修改后，“绿色√”变成“红色！”，说明本地资源与服务器资源不一致。 而关联本地与服务器资源一致性的功能由“.svn”文件夹实现，该文件夹默认为隐藏。当删除“.svn”文件夹后本地与服务器断开连接，Icon消失。 8. Eclipse的SVN插件安装 首先安装Eclipse关于SVN的插件。这里使用Eclipse在线安装插件的方法。 Google搜索“SVN Eclipse插件”即可很容易找到SVN插件的安装地址，当前的安装地址为：http://subclipse.tigris.org/update_1.6.x 。 然后打开Eclipse -> Help -> Install New Software。 把地址 http://subclipse.tigris.org/update_1.6.x 复制到“Work with”下按回车，等待加载如下图的3个插件，点击 “Select all”按钮选中全部，然后点击Next按钮执行下一步，按提示操作即可完成安装。可能安装的时间较漫长，请耐心等待。 9. Eclipse与SVN服务器的连接 安装SVN插件后，找到Eclipse左下角的“+”（快速视图菜单），再点击打开快速视图菜单，选择Other。在弹出的界面中输入“SVN”，点选搜索到的“SVN资源库”，点击OK按钮确认。 此时会出现SVN资源库窗口（如下图）。在空白处右击，选择“新建”，在点选“资源库位置”。然后在弹出的窗口输入SVN服务器的地址，这里使用前面创建的代码库的URL地址：https://Exp-PC/svn/CodeLib 。地址无误则点击Finish按钮确定。 此时会弹出如下图所示的对话框，选择“永久接受”，然后输入用户名和密码。这里必须使用授权给当前正在同步的SVN资源库的用户。 前面第6节中，配置给CodeLib代码库的用户有4个，这里选择其中的一个即可，为避免以后再输入账户密码，可选择“保存密码”。 此时已经可以看到SVN服务器上的代码库，展开则可看到保存在SVN服务器的资源。 10. 利用SVN插件进行代码的同步与共享 10.1. 从SVN服务器上把代码同步到本地 打开Eclipse的“SVN资源库”，找到要下载的源代码项目，右击该项目的根文件夹，选择“检出为”则可把服务器上的项目同步到本地。 如上图所示，检出时会提示命名项目名称，任意命名均可（只要与本地已有项目不重名）。命名完毕后直接按Finish按钮。 此时返回本地Project目录，即可看到刚才从SVN服务器同步下来的TestSVN项目。 如下图所示，从服务器上同步到本地的项目，可以在左边项目列表看到该源代码的来源，以及最后被更新的时间和用户信息。 10.2. 把本地的代码共享到SVN服务器 新建项目TestSVNUpdata，右击项目文件夹，选择Teamshare project在弹出的界面中选择“SVN”，点击Next按钮继续。 如下图所示，选择“使用已有资源库位置”，然后在资源库地址列表中点选要上传的SVN服务器，点击Next按钮继续下一步。若资源库地址列表为空，则选择“创建新的资源库的位置”，输入要上传的SVN服务器的URL地址即可。 到这步选择“使用项目名做为文件夹名”，点Finish后自动切换到Synchronize标签，其中Synchronize显示的是为等待同步到服务器的项目，这里只有项目TestSVNUpdata可供选择。右击TestSVNUpdata项目文件夹，选择“提交”。 然后弹出下图的界面，勾选全部，点击OK按钮。 切换回到“SVN资源库”标签，右击刚才所上传到的SVN资源库，选择“刷新”，则可看到刚才上传的项目，上传成功。 10.3. 本地代码与服务器代码的更新和冲突处理 在说明更新和冲突处理之前，先解释一下各种SVN图标含义。 当本地的项目是从SVN服务器上更新下来的时候，若本地或SVN服务器的代码有被修改过，则当进行如此操作时：在“Project Explorer”标签的本地项目上点击右键 Team 与资源库同步（“与资源库同步”仅是在本地和服务器进行比对，暂时并不会使得本地或服务器代码有任何改变）。 这时会在“Synchronize”标签中列出本地与SVN服务器上不一致的文件列表。文件列表中各个文件的右方会根据不同的情况出现不同的Icon（即SVN图标），它们的含义分别为： 灰色向右箭头：本地修改过； 蓝色向左箭头：SVN上修改过； 灰色向右且中间有个加号的箭头：本地比SVN上多出的文件； 蓝色向左且中间有个加号的箭头：SVN上比本地多出的文件； 灰色向右且中间有个减号的箭头：本地删除了而SVN上未删除的文件； 蓝色向左且中间有个减号的箭头：SVN上删除了而本地未删除的文件； 红色双向箭头：SVN上修改过,本地也修改过的文件。 10.3.1. 更新处理 更新主要有两种操作形式： （1）从本地提交到服务器； （2）从服务器覆盖/更新到本地。 前者主要用于开发进度的更新，后者主要用于从服务器的备份恢复本地错误。两种操作都比较简单，在核对完本地和服务器代码后，只需在“Synchronize”标签中选中需要更新的文件（或文件夹），然后点击右击，找到“Team”，此时选择“提交”则是进行操作（1），选择“覆盖/更新”则是进行操作（2）。具体要进行哪种操作应该视情况而定，这里不再详细说明。 10.3.2. 冲突处理 产生冲突的原因很多，最普遍的一个原因就是：假设服务器上有源代码x，开发者A从服务器上复制了x的副本x1到本地Ax进行开发，开发者B从服务器上复制了x的副本x2到本地Bx进行开发。 当开发者A首先完成了他的开发任务时，此时其本地Ax的源代码就是x1*，当他x1*提交到服务器上后，服务器的源代码就被更新为x1*。 此后开发者B也完成了它的开发任务，此时其本地Bx的源代码就是x2*，当他试图把x2*提交到服务器上时，就出现了冲突。因为此时服务器的代码不再是x，而是被A修改过的x1*。x1*中不但有A增加的代码，原本x中还可能有被A删改过的地方。 此时B要提交代码x2*，就必须根据服务器的代码x1*先把x2*进行恰当的修改，使得修改后的x2**不但包含B的开发部分，还比包含A开发的x1*部分。 如下图所示为产生冲突的一种情况，Eclipse的SVN插件自动指出了本地与服务器不同或冲突的部分，B就能根据这些提示在本地进行修改再提交。结合下图在本地进行如下修改： （a）本地第6行由于是在本地被无故修改的，因此根据服务器进行恢复 （b）本地第8行需要保留，因此不修改 （c）服务器第8行需要被保留，因此复制到本地 （d）服务器第10行不需要保留，因此不复制到本地 （e）服务器第12行需要保留，复制到本地 （f）本地第10行不需要保留，删除 修改后如下图所示，此时冲突已解决，本地保存后，右击代码文件 -> Team -> 提交，即可更新到服务器。 11. *版本控制 版本控制已在 第7.2节 介绍TortoiseSVN的Checkout功能时粗略提及过，本节将详细介绍如何利用Eclipse的SVN插件进行版本控制。TortoiseSVN的版本控制原理雷同，因此不再详细介绍，读者可自行摸索。 以下为示例。 如下图所示，首先在Eclipse建立一个新的本地项目“版本控制测试”。 然后把该项目上传到SVN服务器：右击项目文件夹 -> Team -> Share project。 然后按下图依次进行操作。 到这步为止，为当前提交到服务器的项目在“编辑提交注释”一栏中填写版本信息。这步很重要，是作为以后版本控制的依据。 填写完版本信息后，点击Finish按钮，自动跳转到“Synchronize”标签（同步标签），在同步列表中出现等待同步到服务器的项目。右击“版本控制测试”项目的文件夹，选择“提交”，然后按提示操作即可把“版本控制测试”项目连同其版本信息写入SVN服务器。 [info] 若提交对话框的注释栏为空，请重新填写版本信息，也可利用下拉选择。 此时SVN服务器上只有“版本控制测试”项目的1.0版本。 现在回到本地，现在对本地的“版本控制测试”项目进行修改： 然后右击项目文件夹，选择“Team”，选择“与资源库同步”。自动跳转到“Synchronize”标签（同步标签）。右击“版本控制测试”项目的文件夹，选择“提交”。在出现的提交界面中填写新的版本号。 确认上传后，现在SVN服务器已经有了“版本测试控制”项目的1.0版本和2.0版本。虽然在SVN资源库中依然只有一个“版本测试控制”项目，这是因为SVN资源库默认是显示项目的最新版本。 注意此时服务器上有两个版本1.0和2.0，而本地上只有最新的版本2.0。 下面我们试图把本地的版本恢复到1.0： 在资源库中右击“版本控制测试”，选择“检出为”。 可以看到“Check out HEAD revision”默认是被勾选的，表示从服务器检出最新版本（当前为2.0）的项目到本地。 “Depth”为检出深度，默认为选中的整个资源文件，按需设置，这里为默认值。 “Check out HEAD revision”下方有“Revision”，这里是填写希望检出的版本号，这里先不急着填，先点击“显示日志”。 如上面几张图所示，可以看到点击“显示日志”后，出现了关于项目“版本控制测试”的修改日志列表，日志列表下方对应的是当前被选中的版本号的详细修改信息。但是出现了两个“最初版本1.0”和一个“版本2.0”。现在希望把本地项目恢复到1.0版本，应该选择哪个呢？ 不难发现，最底下的“最初版本1.0”的修改信息只有1个空文件夹，那是之前我们把项目第一次同步到服务器时产生的：我们实际上分开了两步上传，先在服务器创建了项目文件夹，然后再上传项目文件，而这两次操作我们都编写了同一个版本号信息，因此会出现这种情况。 而中间的“最初版本1.0”的修改信息则是整个项目的内容，那么显然现在我们要恢复到的是中间的“最初版本1.0”，即修订号为85的版本。 至于“版本2.0”的修改信息只有“VersionTest.java”一个文件，这也是因为我们只对这个文件做了修改的缘故。 现在我们选择“最初版本1.0”（修订号为85）的版本，点击OK按钮。自动返回到检出界面，而“Check out HEAD revision”已不再被勾选，“Revision”一栏自动被填写了对应修订号85。点击Finish按钮，提示覆盖本地项目，点击OK按钮即可。 返回本地项目查看，已被恢复至1.0版本（如下图）。 类似地，现在也可以从服务器中把最新的版本2.0重新检出到本地，方法一样，具体步骤不再阐明。 资源下载 [!NOTE|style:flat|icon:fa fa-cloud-download|label:Download] 本文全文下载 配套PPT讲义下载 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 13:30:48 "},"markdown/notes/arch/":{"url":"markdown/notes/arch/","title":"系统架构","keywords":"","body":"系统架构系统架构 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/resource/":{"url":"markdown/resource/","title":"资源分享","keywords":"","body":"资源分享资源分享 2015系统架构师复习资料 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-07 08:59:45 "},"markdown/resource/2015系统架构师复习资料.html":{"url":"markdown/resource/2015系统架构师复习资料.html","title":"2015系统架构师复习资料","keywords":"","body":"2015系统架构师复习资料前言上午题版本号规范CISC（复杂 指令集计算机）和RISC（精简指令集计算机）并发任务的同步互斥PV原语看门狗（Watch Dog）高速缓存存储管理方案数据库范式（P25）数据库设计步骤（P27）* 关系模式分解实体关系向关系模型的转换规则数据库的数据集成商业智能的主要技术（P30）数据挖掘（P32）多媒体技术标准（P42）视频压缩技术结构化布线系统性能评估指标（P47）系统测试冒烟测试集成测试软件测试与软件调试区别单元测试-桩模块测试分类基准测试程序（P49）四种评价程序的准确度（P49）软件设计和软件测试与电子政务相关的行为主体（P59）企业信息化目的（P62）ERP（企业资源计划）结构（P66）CRM（客户关系管理系统）的定位（P68）企业门户分类（P74）知识产权的相关法律法规（P88）敏捷开发的核心思想 / 特点 （P98）敏捷开发核心价值观（P99）敏捷开发实践规则（P99）极限编程（XP）的13个核心实践（P99）RUP（统一软件开发过程）阶段任务（P101）项目管理工具（P108）需求管理（P109）需求变更策略（P112）项目范围定义（P116）项目时间管理（P116）产品配置的配置项（P117）程序静态分析静态分析技术遗留系统的演化策略逆向工程导出信息级别（P123）软件架构设计的生命周期（P125）架构模式、设计模式、惯用法的区别软件架构的主要作用（P127）软件架构策略体系结构失配（P128）软件架构的重要性（P130）DSSA特定领域架构的角色与任务（P145）ATAM体系架构权衡分析方法（P152）软件设计阶段的度量耦合程度文档评审形式化方法用例图-用例间关系（P159）UML面向对象设计（P176）软件构件概念（P247）构件设计原则构件依赖关系基于构件开发模型的顺序执行阶段基于构件的软件工程的复用性计划加密解密技术（P307）网络七层协议（P317）Internet三种服务质量类型网络分层设计模型（三层模型）网络开发过程网络存储方式SNMP.v3（简单网络管理协议）网络架构数据流图的内容HTTP超文本传输协议RIP路由协议系统可维护性评价指标（P397）系统维护工作类型（P397）计算机质量保证计划规范内容集成平台的基本功能（P449）企业集成模式（P451）企业应用集成EDI电子数据交换（P462）嵌入式系统软硬件协同设计过程（P510）下午题Mysql主从复制优点Memcached缓存与数据库缓存差异数据库系统提供的基本加解密方式反规范化技术数据库分区NoSQL的优缺点负载均衡技术（P40）ABSD（基于体系结构的软件架构设计）概念（P131）ABSD方法的三个基础（P131）ABSD的6个主要活动/子过程（P133）ABSD需求过程（P133）ABSD设计过程（P134）ABSD文档化（P135）ABSD复审（P135）ABSD实现过程（P135）ABSD演化过程（P136）系统架构风格（P137）系统质量属性（P147）系统架构评估（P149）UML的10种4类模型视图（P158）数据流图数据流图的常见错误类型数据流图、流程图的含义与区别数据流图设计原则CRUD矩阵4+1视图（P181 - 图P103）设计模式（P195）获取构件的方法（P247）开发构件的策略（P267）构件组装（P271）主流构件标准（P275）主要的身份认证技术（P315）授权侵犯抗抵赖框架基于口令的简单认证机制 与 基于公钥体系的认证机制 优缺点比较对称加密策略公钥加密策略软件可靠性的定量描述（P355）可靠性设计技术（P377）容错设计技术（P377）恢复块设计（P377）N版本程序设计（P377）冗余技术（P377）动态冗余（P378）检错技术优缺点（P378）检错设计技术要素（P378）FMEA失效模式与效应分析（P379）FMEA主要活动FMEA分类ODP分布式数据架构（P382）集中式数据架构集中式和分布式数据架构的扩展方式开放式架构的基本特点MVC架构风格（P419）MVC设计模式-示例图（P419）MVC模式的优点（P420）从设计模式角度描述用XML作为GUI描述语言的机制（P421）基于XML的界面管理技术（P422）基于XML的界面管理技术框架-示例图（P423）TLS三层栈软件总体架构特点嵌入式操作系统VxWorks与Linux的差异（P505）Linux操作系统特点嵌入式操作系统故障类型嵌入式操作系统故障滤波算法嵌入式操作系统容错算法基于VME总线机载和基于FC总线机载的嵌入式系统架构比较ESB企业服务总线（P537）ESB主要功能（P538）ESB作为集成框架的优点项目计划应包含的内容缩短项目工期的方式REST表现层状态转换技术REST设计原则XACML（可扩展访问控制标记语言）相对于MAC（强制访问控制）的优点论文题论文通用题型论文评分点论文模板示例论文历年论文题目2015系统架构师复习资料 前言 经过一年的复习，鄙人终于通过了15年的 【系统架构师】 资格考试啦 O(∩_∩)O 为了更多人都可以通过，分享一下我自己整理的复习要点~ 不过现在 架构师 的考点还不稳定，大家在复习的时候也要善于自己总结哦！ 我整理复习资料分为【上午题】【下午题】【论文】三部分， 结合了07~14年的真题，去除了重复题型整编的~ 【上午题（Go）】以理解为主，当然如果有能力背下来是最好的 【下午题（Go）】以背为主，当然最理想是都实践过这些知识点，理解了才更好背 【论文题（Go）】我只有给提纲，这个必须多练~ 除了练题型，也要练字迹、练手速 因为下午题（2.5H）完了之后，休息15min就要写论文，论文只有2H，想合格3000字是必须的~ 换言之你需要连续写字写4.5H，不想手腐就写写写写吧。。。 至少一星期一篇，，， 顺便吐槽一下15年的考试~~ 上午题偏僻~ 下午题偏易~ 论文题有架构风格肯定大众必选的45分保底题型~ [!NOTE|style:flat|icon:fa fa-cloud-download|label:Download] 复习资料下载 官方教材《系统架构设计师教程》下载（密码：ndkiyi） [info] 本文标题后若标注了【Pxx】字样，表示在《系统架构设计师教程》的第 xx 页有相关内容 上午题 版本号规范 处于“草稿”状态的版本号都是以“0.”格式开头 处于“正式”状态的版本号格式为“X.Y”（X为主版本号，取值1~9，Y为次版本号，取值0~9） 处于“修改”状态的版本号格式为“X.YZ” CISC（复杂 指令集计算机）和RISC（精简指令集计算机） 比较内容 CISC RISC 指令系统 复杂，庞大 简单，精简 指令数目 一般 > 200 一般 指令格式 一般 > 4种 一般 寻址方式 一般 > 4种 一般 指令字长 不固定，1~15字节 等长，通常为4字节 可访存指令 不加限制 只有LOAD / STORE等指令 各种指令使用频率 相差很大 相差不大 优化编译实现 很难 较容易 程序源代码长度 较短 较长 控制器实现方式 绝大多数为微程序控制 绝大多数为硬布线控制 芯片设计复杂度 高 低 软件系统开发时间 较短 较长 操作 可以对存储器和寄存器进行算术和逻辑操作 设置大量通用寄存器，访问存储器指令简单，只能对寄存器进行算术和逻辑操作 执行时间 有些指令执行时间很长 选取使用频率较高的一些简单指令，且指令执行时间较短 并发任务的同步互斥 同步：进程间的直接制约关系，如生产者消费者问题 互斥：进程间的间接制约关系，如临界资源的PV操作 PV原语 P原语：Proberen（测试），为阻塞原语，负责把当前进程由运行态转为阻塞态，等待唤醒。 　　　　　其操作为：申请一个空闲资源（信号量-1），成功退出，失败阻塞。 V原语：Verhogen（增加），为唤醒原语，负责唤醒一个阻塞进程。　　　　　其操作为：释放一个被占用的资源（信号量+1）。 看门狗（Watch Dog） WDT（Watch Dog Timer）是一个定时电路，一般有一个输入，叫“喂狗”，一个输出到MCU（微控制单元）的RTS端（标志位，表示复位连接）。 MCU正常工作时，每隔一段时间输出一个信号到喂狗端清零，若超时不喂狗，WDT定时器超时，就会给出复位信号（复位中断）到MCU，使MCU复位，防止死机。 WDT的作用就是防止程序死循环或跑飞（系统受到干扰后偏离正常运行的路径）。 高速缓存 高速缓存介于CPU与主存（内存）之间，利用局部性原理消减CPU与主存之间的速度差以提升系统性能。其工作速度数倍于主存，全部功能由硬件实现，且对程序员透明。 存储管理方案 覆盖：编程时必须划分程序模块和确定程序模块之间的调用关系，不存在调用关系的模块可以占用相同的主存区。 固定分区：在系统进行初始化的时候就已经将主存空间划分成大小相等或不等的块，并且这些块的大小在此后是不可以改变的。系统将程序分配在连续的区域中。 请求分页：主存空间和程序按固定大小单位进行分割，程序可以分配在不连续的区域中。该方案当一个作业的程序地址空间大于主存可以使用的空间时也可以执行。 数据库范式（P25） 1NF：原子式。 2NF：所有字段都必须与主键有直接或间接相关，允许某些字段与候选码传递或非传递依赖。 3NF：所有字段都必须与主键直接相关，允许某些字段与候选码传递或非传递依赖。 BCNF：所有字段都必须与主键直接相关，不允许存在字段与候选码有传递或非传递依赖。 数据库设计步骤（P27） 需求分析：DFD 概念结构设计：E-R图 逻辑结构设计：确定数据模型（由E-R图转换）、约束 物理结构设计：利用DBMS设计数据库 应用程序设计：对DBMS的二次开发，存储用户信息，实现用户处理要求 运行维护：数据的转储和恢复、安全性和完整性控制、性能监督、数据库重组等 * 关系模式分解 无损分解算法：LOSSLESSTEST(R, F ,p) 算法。 定理： 关系模式R(U)，分解为 p={R(U1),R(U2)} p是无损连接的，当且仅当 U1∩U2 → U1-U2 或 U1∩U2 → U2-U1 分解保持依赖 - 最小依赖集： ① 将F中的所有依赖右边化为单一元素 ② 去掉F中的所有依赖左边的冗余属性 ③ 去掉F中所有冗余依赖关系 实体关系向关系模型的转换规则 多对多的联系 [必须] 转换成一个独立的关系模式 一对多的联系既可以转换成一个独立的关系模式，也可以与多端关系模式合并（此时需把一端的码合并到多端关系模式中） 数据库的数据集成 若单表即可完成整合，则可以将该表封装为记录，采用 [主动记录] 方式进行集成 若需要多表进行数据整合，则需要采用 [数据映射] 方式完成数据集成与处理 商业智能的主要技术（P30） 数据仓库、联机分析、数据挖掘 数据挖掘（P32） 目标：从数据库的大量数据中揭示出隐含的、先前未知的并有潜在价值的信息。 挖掘信息特征：先知、有效、实用。 主要功能（任务）：自动预测趋势和行为、关联分析、聚类、概念描述、偏差检测。 挖掘技术：关联分析、序列分析、分类分析、聚类分析、预测、时间序列分析。 挖掘流程：确定挖掘对象、准备数据、建立模型、数据挖掘、结果分析、知识应用。 多媒体技术标准（P42） 静态图像压缩编码标准：JPEG 运动图像压缩标准：MPEG MPEG-1：应用于VCD、CD、MP3 MPEG-2：应用于DVD、HDTV MPEG-4：面向低速、低码率的传输条件（如移动网） 另外，MPEG-7是多媒体接口标准，MPEG-21是多媒体框架标准 视频压缩技术 视频图像本身在时间和空间上都存在冗余信息。 视频图像压缩技术的基本思想和方法可归纳为： 在空间上，图像数据压缩采用JPEG压缩方法去除冗余信息，主要包括 [帧内预测] 和 [变换编码] 在时间上，图像数据采用 [帧间预测编码] 和 [运动补偿] 去除冗余信息。 视频压缩中包括 [有损压缩] 和 [无损压缩] 两种： 无损压缩： [哈夫曼编码]、 [行程编码] 有损压缩： [预测编码]、 [变换编码]、 [运动补偿] 结构化布线系统 工作区子系统（如PC到房间路由）　　由终端设备到信息插座的整个区域，用于将终端设备连接到布线系统。 水平子系统（如房间内多个PC间的拓扑支线）　　连接用户工作区与布线系统主干的子系统，起支线作用，将所有用户通过连接件连接到配线设备上。 管理子系统（如房间路由到楼层交换机）　　对布线电缆进行端接及配线管理的子系统，由各种交换设备（如集线器、交换机等）组成。 干线子系统 / 垂直子系统（如各楼层交换机之间的连接干线）　　连接各管理间、设备间的子系统。 设备间子系统（如大楼网箱）　　主要用于安放网络关键设备（如程控交换机等），地位重要，但不一定有，大型建筑一般有多个。 建筑群子系统（如大楼间的光纤电缆、无线网等）　　连接楼群间通信传输介质及各种支持设备组成的子系统，传输介质可以是有线或无线。 性能评估指标（P47） 计算机：时钟频率（主频）、运算速度、运算精度、内存容量、存取周期等等 路由器：设备吞吐量、端口吞吐量、丢包率、时延、时延抖动等等 交换机：背板吞吐量、换成区大小、最大MAC地址表大小、负载均衡等等 网络：设备级性能指标、网络级性能指标、应用级性能指标、用户级性能指标、吞吐量 操作系统：可靠性、吞吐量（率）、系统响应时间、系统资源利用率、可移植性 数据库管理系统：数据库大小、表数量、单表大小、单表允许最大行/列/索引数量等等 Web服务器：最大并发连接数、响应延迟、吞吐量 系统测试 系统测试是将已经确认的软件、计算机硬件、外设和网络等其他因素结合在一起，进行信息系统的各种集成测试和确认测试。 系统测试根据系统方案说明书来设计测试用例，常见的测试内容包括恢复测试、安全性测试、压力测试、性能测试、可靠性测试、可用性测试、可维护性测试和安装测试。 冒烟测试 将代码更改嵌入到产品的源代码之前，对这些更改进行验证的过程。 采用极限编程（XP）的“持续集成”策略有助于建立冒烟测试的环境。 集成测试 - 非增量式测试 增量式测试 错误定位 不容易定位错误 容易定位错误、排除故障 测试强度 小 大，先加入的模块经过多次测试，测试更彻底 测试工作量 小 大 测试进度 对各个模块可以并行测试，加快测试进度 测试过程长、进度慢 测试辅助程序 每个中间模块的测试都需要编写驱动模块和桩模块 自顶向下的增加需要编写桩模块自底向上的增加需要编写驱动模块 软件测试与软件调试区别 测试是为了发现软件中存在的错误。调试是为了证明软件开发的正确性。 测试以已知条件开始，使用预先定义的程序，且有预知的结果，不可预见的仅是程序是否通过测试。调试以一段不可知的内部条件开始，除统计性调试外，结果是不可预见的。 测试是有计划的、需要进行测试设计。调试是不受时间约束的。 测试经历发现错误、改正错误、重新测试的过程。调试是一个推理的过程。 测试经常是独立的测试组在不了解软件设计的条件下完成的。调试必须由了解详细设计的开发人员完成。 大多数测试的执行和设计可由工具支持。调试时，开发人员能利用的工具主要是调试器。 单元测试-桩模块 桩模块是指 模拟 [被测试模块] [所调用的模块] ，而不是软件产品的组成部分。 主模块作为驱动模块，在单元测试时，与之直接相连的模块可用 桩模块 代替。 测试分类 负载测试：运行某些诊断程序，加大负载，检查哪个设备会发生故障。 集成测试：验证程序模块之间的接口是否正常起作用 白盒测试：根据程序的内部结构和内部逻辑，测试程序是否正确 基准测试：运行一个标准程序对多种计算机系统进行检查，以比较和评价它们的性能 基准测试程序（P49） 把应用程序中用得最多、最频繁的那部分 [核心程序] 作为评价计算机性能的标准程序，称为基准测试程序，一般使用公认的第三方测试。 四种评价程序的准确度（P49） 依靠评价程序评价机器的性能，按评测准确度由高至低的4种评价程序为： 真实的程序 > 核心程序 > 小型基准程序 > 合成基准程序 软件设计和软件测试 软件设计应从“宏观”的软件架构开始，“微观”的构件模块结束。 软件测试则相反，应从“微观”开始，“宏观”结束。 与电子政务相关的行为主体（P59） 政府、企业/事业单位、公民/居民 企业信息化目的（P62） 技术创新 管理创新：按照市场发展的要求，对企业现有的管理流程重新整合，　　　　　　从作为管理核心的财务、资金管理，转向技术、物资、人力资源的管理，　　　　　　并延伸到企业技术创新、工艺设计、产品设计、生产制造过程的管理，　　　　　　进而还要扩展到客户关系管理、供应链的管理乃至发展到电子商务。 制度创新 ERP（企业资源计划）结构（P66） （1）生产预测：对市场需求进行预测，其结果用于计划。 （2）销售管理计划：对销售部门的相关业务进行管理，属于决策层（最高层）计划。 （3）经营计划（生产计划大纲）　根据经营计划的生产目标制定，是对企业经营计划的细化，用于描述企业在可用资源的条件下，在一定时期中的产量计划。 （4）主生产计划　其编制是ERP的主要工作内容，是对企业生产计划大纲的细化，说明在一定时期内生产什么、生产多少和什么时候交货。 （5）物料需求计划　是对主生产计划的各个项目所需的全部制造件和全部采购件的网络支持计划和时间进度计划，属于ERP管理层计划。 （6）能力需求计划　是对物料需求计划所需能力进行核算的一种计划管理方法，能够帮助企业今早发现生产能力的瓶颈、为实现企业的生产任务而提供能力方面的保障。 （7）车间作业计划　按照交货期的前后和生产优先级选择原则、以及车间的生产资源情况，将生产计划以订单形式下达给适当的车间，属于ERP执行层计划。 （8）采购与库存管理　采购管理：对订单产生至货物收到的全过程进行组织、实施和控制。　库存管理：对企业物料的进、出、存进行管理。 （9）质量与设备管理　质量管理：贯穿企业管理的始终。　设备管理：对设备寿命周期内的所有设备物资运动形态和价值运动形态进行综合管理。 （10）财务管理：以货币形式反映和监督企业日常经济活动，为企业管理和决策提供必要的信息支持。 （11）ERP有关扩展应用模块：如客户关系管理（CRM）、分销资源管理、供应链管理、电子商务等。 其中，（3）（4）（5）（6）（7）又称作是ERP的五层计划。 CRM（客户关系管理系统）的定位（P68） 在注重提高客户满意度的同时，一定要把帮助企业提高获取利润的能力作为重要指标。 企业门户分类（P74） 企业信息门户：强调为访问结构数据和无结构数据提供一个统一的入口 企业知识门户：强调提高企业范围内的知识共享，减少员工解决问题时间，提高工作效率 企业应用门户：提高企业集中贸易能力、协同能力和信息管理能力的平台 垂直门户：为某一特定的行业服务的，传送的信息值属于人们感兴趣的领域。 知识产权的相关法律法规（P88） 软件著作权的产生时间，是自软件开发完成之日时。 软件商标权的保护对象是软件注册商标。 为介绍、评论某一作品或者说明某一问题，在作品中适当引用他人已发表的作品，可以不经著作权人许可，不向其支付报酬。 法律法规，国家机关决议、决定、命令和其他具有立法、行政、司法性质的文件，及其官方译文均不适用或不受著作权法保护。 口述作品（如某人在公共场所的即兴演说）适用于著作权法，并受其保护。 著作权权利中，署名权、修改权、保护作品完整权的保护期不受时间限制，发表权的保护期限为作者终生及其死亡后五十年（截止于作者死亡后第五十年的12月31日）。 通过反向编译技术、净室技术、反向工程技术等获得他人软件技术构思、技术方案并直接用于其自身软件产品的行为，在我国暂无相关法律法规限制，在著作权法中不构成侵权（著作权法也不保护思想）。 商业秘密要受到法律保护，必须同时满足三个条件：不为公众所知悉、具有实用性、采取了保密措施。缺少任意一个均会丧失法律保护。 公司享有 [员工任职期间利用公司资源所开发的软件] 的著作权，不论是否和该员工签订了劳动合同。 专利法规定，申请专利的发明创造在 [申请日以前6个月内] ，有下列情形之一的不丧失新颖性：① 在中国政府主办或者承认的国际展览会上首次展出的；② 在规定的学术会议或者技术会议上首次发表的； ③ 他人未经申请人同意而泄露其内容的。 知识产权的保护以所执行国家的当地法律为准，不受被保护对象的身份国籍影响。 敏捷开发的核心思想 / 特点 （P98） 适应型而非预测型，拥抱变化 以人为本而非以过程为本，强调充分发挥人的特性 迭代增量式开发，以原型开发为核心，发行版本小型化 敏捷开发核心价值观（P99） 沟通、简单、反馈、勇气 敏捷开发实践规则（P99） 简单设计，测试驱动，代码重构，结对编程，持续集成，现场客户，发行版本小型化，系统隐喻，代码集体所有制，规划策略，规范代码，40小时工作制 极限编程（XP）的13个核心实践（P99） 团队协作、规划策略、结对编程、测试驱动开发、重构、简单设计、代码集体所有权、持续集成、客户测试、每周40小时工作制、编码规范、系统隐喻、小型发布 RUP（统一软件开发过程）阶段任务（P101） 初始：定义最终产品视图和业务模型，并确定系统范围。 细化：设计及确定系统的体系结构，指定工作计划及资源要求。 构造：构造产品并继续演进需求、体系结构，计划直至产品移交。 移交：把产品提交给用户使用。 每个阶段都由一个或多个迭代组成，迭代并非重复地做相同的事，而是针对不同用例的细化和实现。每一个迭代都是一个完整的开发过程（螺旋模型）。 项目管理工具（P108） 项目管理工具（如成本估算工具）用来辅助软件的项目管理活动。它通常把重点放在一个或某几个特定的管理环节上，而不提供对管理活动包罗万象的支持。 需求管理（P109） 需求管理是一个对系统需求变更、了解和控制的过程。 原则（策略）： 需求管理的关键领域不涉及收集和分析项目需求 开发人员在向客户以及有关部门承诺某些需求之前，应该确认需求和约束条件、风险、偶然因素、假定条件等。绝不承诺任务无法实现之事。 关键处理领域同样建议通过版本控制和变更控制来管理需求文档。 需求变更策略（P112） 所有需求变更必须遵循变更控制过程。 对于未获批准的变更，不应该做设计和实现工作。 变更应该由项目变更控制委员会决定实现哪些变更。 项目风险承担者应该能够了解变更数据库的内容。 决不能从数据库中删除或修改变更请求的原始文档。 每一个集成的需求变更必须能够跟踪到一个经核准的变更请求。 项目范围定义（P116） 项目章程、项目范围管理计划、组织过程资产、批准的变更申请 项目时间管理（P116） 项目时间管理的过程包括：活动定义、活动排序、活动的资源估算、活动的历时估算、制定进度计划、进度控制。 为了得到工作分解结构（WBS）中最底层的交付物，必须执行一系列的活动，对这些活动的识别以及归档的过程就叫做活动定义。 产品配置的配置项（P117） 属于产品组成部分的工作成果：需求文档、设计文档、源代码、测试用例等。 属于项目管理和机构支撑过程域产生的文档：工作计划、项目质量报告、项目跟踪报告等。 程序静态分析 在不执行程序的情况下，对其进行分析的技术。 其特点为：不实际执行程序，分析速度快、效率高，误报率较高。 相较之下的动态分析则需实际执行程序，多用于性能测试、功能测试、内存测试等。 静态分析技术 词法分析：逐字符读入源程序，使用正则匹配转换为等价符号流，生成相关符号列表。 语法分析：判断源程序结构上是否正确，通过上下文无关语法将相关符号整理为语法树。 抽象语法树分析：将程序组织成树形结构，树中相关节点代表程序中的相关代码。 语义分析：对结构上正确的源程序进行上下文有关的性质检查。 控制流分析：生成有向控制流图，用节点代表基本代码块，节点间的有向边代表控制流路径，反向边表示可能存在的循环，还可生成函数调用关系图，表示函数间的嵌套关系。 数据流分析：对控制流图遍历，记录变量的初始化点和引用点，保存切片相关数据信息。 污点分析：基于数据流图判断代码中哪些变量可能受到攻击，是验证输入、识别代码表达缺陷的关键。 无效代码分析：根据控制流图可分析孤立节点就是无效代码。 遗留系统的演化策略 淘汰、改造、继承、集成 逆向工程导出信息级别（P123） 实现级：包括程序的抽象语法树、符号表等信息 结构级：包括反映程序分量之间相互依赖关系的信息，如调用图、结构图。 功能级：包括反映程序段功能及程序段之间关系的信息。 领域级：包括反映程序分量或程序诸实体与应用领域概念之间对应关系的信息。 软件架构设计的生命周期（P125） 需求分析阶段：关注问题域 软件设计阶段：将需求转换为软件架构模型 软件实现阶段：关注将架构设计转换为实际代码 软件部署阶段：通过组装软件组件提高系统的实现效率 其中在设计和实现阶段对软件架构的关注度最大，软件系统架构必须建立在需求明确的基础上。 架构模式、设计模式、惯用法的区别 架构模式是软件设计中的高层决策，反映了开发软件系统过程中所作的基本设计决策。 设计模式主要关注软件系统的设计，与具体的实现语言无关。 惯用法是实现时通过某种特定的程序设计语言来描述构件与构件之间的关系。 软件架构的主要作用（P127） 分析设计在满足规定需求方面的有效性。 在设计变更相对容易的阶段，考虑体系结构可能选择的方案。 降低与软件构造相关联的风险。 软件架构策略 关键 问题 危害 策略 要点 是否遗留了至关重要的非功能需求 对需求理解不系统、不全面，对非功能需求不够重视 造成返工、项目失败 全面认识需求 从不同级别、不同类别梳理列表，归纳总结，建立跟踪矩阵 能否驯服数量巨大且频繁变化的需求 对于时间和质量的矛盾，办理不足，处理草率 耗时不少、质量不高 让关键需求决定架构：只分析和重点关注关键功能性需求和重要的质量属性需求 控制架构设计时需详细分析用例的个数，权衡非功能需求之间的关系，找到影响架构的重点非功能需求 能否从容地设计软件架构的不同方面 架构设计方案覆盖范围严重不足，许多关键决定被延迟由实现人员仓促决定 开发混乱、质量不高 多立场、多视角探寻架构：架构级设计是分层式的分而治之，子系统是功能性分而治之 一次只从某一主场、某一视角出发，围绕少数概念和技术展开，并分析对其他部分、其他立场视角分析结果的关系与影响 是否及早验证架构方案并作出调整 假设架构方案是可行的，直到后期才能发现问题，造成大规模返工 造成返工、项目失败 尽早验证架构：采用原型技术和框架技术 必须精挑细选能够触发主要设计决策参与执行的、或有较高技术风险的、或最影响用户满意度的一切功能进行验证 全面认识需求 功能需求 质量属性 约束 组织级 软件系统实现的功能 - 成本、上线时间、业务限制 用户级 软件系统实现的功能 易用性、性能、持续可用性、可靠性 用户的计算机水平有限 开发级 软件系统实现的功能 可扩展性、可重用性、可移植性、易理解性、易测试性 开发语言的约束 体系结构失配（P128） 由构件引起的失配：包括系统对构件基础设施、构件控制模型和构件数据模型的假设存在冲突。 由连接子引起的失配：包括系统对构件交互协议、连接子数据模型的假设存在冲突。 由于系统成分对全局体系结构的假设存在冲突引起的失配。 软件架构的重要性（P130） 能满足系统的品质 使受益人达成一致的目标 能够支持计划编制过程 对系统开发的指导性 能够有效管理复杂性 为复用奠定了基础 能够降低维护费用 能够支持冲突分析 DSSA特定领域架构的角色与任务（P145） 角色 任务 领域专家（软件工程师） 提供关于领域中系统的需求规约和实现的知识，帮助组织规范的、一致的领域字典，帮助选择样本系统作为领域工程的依据，复审领域模型、DSSA等领域工程产品等 领域分析者（系统分析员） 控制整个领域分析过程，进行知识的获取、将获取的知识组织到领域模型中，根据现有系统、标准规范等验证领域模型的准确性和一致性，维护领域模型 领域设计者（软件设计人员） 控制整个软件设计过程，根据领域模型和现有的系统开发出DSSA，对DSSA的准确性和一致性进行验证，建立领域模型和DSSA之间的关系 领域实现者（程序设计人员） 根据领域模型和DSSA，或者重头开发可重用构件、或者利用再工程的技术从现有系统中提取可重用构件，对可重用构件进行验证，建立DSSA与可重用构件之间的联系 ATAM体系架构权衡分析方法（P152） 主要关注系统的 [需求建模] ， 并在系统开发之前，针对 [性能、实用性、安全性和可修改性] 等质量属性进行评价和折中。 ATAM不是精确的评估工具，其整个评估过程强调以 [质量属性] 作为架构评估的核心概念。 在识别出质量属性的描述后，通常采用 [决策表] 对质量属性的描述进行刻画与排序。 ATAM分为4个主要的 [活动领域] ，包括需求收集、体系结构视图描述、属性模型构造和分析、折中。 软件设计阶段的度量 架构层次度量：考虑了设计模型的体系结构方面 构件层次度量：通过建立内聚、耦合和复杂度的简介度量，提供了模块质量的指示 界面层次度量：给GUI的布局提供了恰当性的提示 耦合程度 从低到高排列如下（越低越好）： 非直接耦合：两个模块间无直接联系，他们之间的联系完全是通过主模块的控制和调度实现的。 数据耦合：一个模块访问另一个模块时，彼此之间是通过简单数据参数来交换输入输出信息的。 标记耦合：一组模块通过参数表传递记录信息。这个记录是某一数据结构，而非简单变量。 控制耦合：一个模块通过传送开关、标识等控制信息，明显选择另一模块的内部功能。 外部耦合：一组模块通过访问同一全局简单变量（而非参数表或全局数据结构）来传递信息。 公共耦合：一组模块通过访问同一公共环境数据（而非全局简单变量）来传递信息。 内容耦合：一个模块直接修改或操作另一模块的数据，或者不通过正常入口转入另一模块。 文档评审 需求评审：进一步确认开发者和设计者已了解的用户要求、以及用户从开发者了解的某些限制和约束 设计评审：产生的最终文档规定系统和程序如何设计开发和测试，以满足统一的需求规格说明书 概要设计评审：评审每个系统组成部分的基本设计方法和集成测试计划，并相应修改系统规格说明书 详细设计评审：主要评审计算机程序、程序单元测试计划 形式化方法 数据不变式：即一个条件表达式，它在包含一组数据的系统的执行过程中总保持为真。 状态：即从系统外部能够观察到的行为模式的一种表示（或者系统访问和修改的存储数据） 操作：即系统中发生的动作，以及对状态数据的读写。每一个操作均与前置条件和后置条件相关。 用例图-用例间关系（P159） 泛化： 包含：特殊的依赖关系，一个用例（称作基本用例）包含了另一个用例（称作包含用例）的行为。 扩展：类似于泛化关系，但有更多规则限制。扩展用例只能在基本用例的扩展点上增加新的行为。 UML面向对象设计（P176） 边界类：实现界面控制、外部接口和环境隔离。 实体类：表示目标软件系统中具有持久意义的信息项及其操作。 控制类：作为完成用例任务的责任承担者，协调、控制其他类共同完成用例规定的功能或行为。 软件构件概念（P247） 软件构件是软件系统中具有一定意义的、相对独立的可重用单元。构件可以基于对象实现、也可以不基于对象实现。构件需要在容器中管理并获取容器提供的服务。客户程序可以在运行状态下利用接口动态确定构件所支持的功能并调用。 构件设计原则 开关原则：模块应对外延具有开放性，对修改具有封闭性 Liskov替换原则：子类可以替换它们的基类 依赖倒置原则：依赖于抽象，而非具体实现 接口分离原则：多个用户专用接口比一个通用接口要好 构件依赖关系 共享依赖：使用相同资源的 [消费者间] 或 [生产者间] 的依赖 流依赖： [生产者和消费者间] 的资源依赖 约束依赖：一组 [活动间] 的相关控制流上的约束 基于构件开发模型的顺序执行阶段 需求分析定义、体系结构设计、构件库建立、应用软件创建、测试和发布 基于构件的软件工程的复用性计划 成品构件：从第三方获得，或在以前项目中已进行内部开发的既有软件。成品构件能够直接应用于当前项目。 具有完全经验的构件：以前项目开发的构件，与当前项目需要构造的软件具有一定相似性。对其修改的风险较小，要求团队成员在这些构件所代表的领域中具有丰富的经验。 具有部分经验的构件：以前项目开发的构件，与当前项目需要构造的软件具有一定相似性。由于团队成员在这些构件所代表的领域中的经验较少，若对其做实质性的修改，会有较大风险。 新构件：软件团队为了满足当前项目的特定需求，而必须专门开发的软件构件。 加密解密技术（P307） 对称算法：DES（便于硬件不便于软件实现），RC-5，IDEA 非对称算法：RSA，ECC 摘要算法（不可逆）：MD5，MD4，SHA，HMAC 网络七层协议（P317） 网络层 相关协议 应用层 DHCP、DNS、FTP、Gopher、HTTP、HTTPS、IMAP4、IRC、NNTP、XMPP、POP3、SIP、SMTP、SNMP、SSH、TELNET、RPC、RTCP、RTP、RTSP、SDP、SOAP、GTP、STUN、NTP、SSDP、NFS（网络文件系统） 表示层 HTTP/HTML、FTP、Telnet、ASN.1（具有表示层功能） 会话层 ADSP、ASP、H.245、ISO-SP、iSNS、NetBIOS、RPC、RTCP、SMPP、SCP、SSH、ZIP、SDP（具有会话层功能） 传输层 TCP、UDP、TLS、DCCP、SCTP、RSVP、PPTP 网络层 IP (IPv4、IPv6)、ICMP、ICMPv6、IGMP、IS-IS、IPsec、BGP、RIP、OSPF、ARP、RARP 数据链路层 L2TP（第2层隧道协议）、PAP（密码认证协议）、Wi-Fi(IEEE 802.11)、WiMAX(IEEE 802.16)、ATM、DTM、令牌环、以太网路、FDDI、帧中继、GPRS、EVDO、HSPA、HDLC、PPP、ISDN、STP 物理层 RS-232、RS-449、X.21、V.35、ISDN、FDDI、IEEE802.3、IEEE802.4、IEEE802.5、以太网路卡、调制解调器、电力线通信(PLC)、SONET/SDH（光同步数字传输网）、G.709（光传输网络）、光导纤维、同轴电缆、双绞线 Internet三种服务质量类型 保证质量的服务：对带宽、时延、抖动和丢包率提供定量的保证。 尽力而为的服务：这是一般的Internet服务，不保证服务质量 负载受控的服务：提供类似于网络欠载时的服务，定性地提供 网络分层设计模型（三层模型） 核心层（网络的高速交换主干）　　是所有流量的最终承受者和汇聚者，其主要功能是实现骨干网络间的优化传输，因此应采用冗余设计，以保证冗余能力、可靠性和高速传输。 汇聚层（提供基于策略的连接）　　是核心层与接入层的中介，即在工作站接入前先做好汇聚，以减轻核心层的设备负荷。如过滤数据包、策略路由、完成路由汇总和协议转换功能等。 接入层（将工作站接入网络）　　应提供即插即用特性，为用户提供本地网段访问接入能力，主要解决相邻用户互访需求，并应适当负责一些用户管理工作（如地址认证、用户认证、计费管理等），以及用户信息的收集工作（如IP地址、MAC地址、访问日志等）。 网络开发过程 需求分析：理解网络应该具有的功能和性能，最终设计出符合用户需求的网络 网络体系分析：分析现有网络和新网络的各类资源分布，掌握网络所处的状态 网络逻辑设计：根据需求规范和通信规范，实施资源分配和安全规划 物理网络设计：依据逻辑网络设计的功能要求，确定设备的具体物理分布和运行环境 网络存储方式 DAS：开放系统的直连式存储　　在服务器上外挂了一组大容量硬盘，存储设备与服务器之间采用SCSI通道连接。　　这种方式难以扩展存储容量，且不支持数据容错功能，当服务器出现异常时会造成数据丢失。 NAS：网络接入存储（公网环境）　　是将存储设备连接到现有的网络上，提供数据存储和文件访问服务的设备。　　NAS服务器是在专用主机上安装简化了的瘦操作系统的文件服务器，它内置了与网络连接所需要的协议，可以直接联网，具有权限的用户都可以通过网络访问NAS服务器上的文件。 SAN：存储区域网络（专网环境）　　是一种连接存储设备和存储管理子系统的专用网络，专门提供数据存储和管理功能。　　SAN可以看做是负责数据传输的后端网络，而前端网络（又称数据网络）则负责正常的TCP/IP传输。　　SAN也可以看做是通过特定的互连方式连接的若干台存储服务器组成的单独的数据网络，提供企业级的数据存储服务。 SNMP.v3（简单网络管理协议） 必须防护的威胁： （主要）修改信息 （主要）假冒 （次要）修改报文流 （次要）消息泄露 不必防护的威胁： 拒绝服务 通信分析 网络架构数据流图的内容 服务器及其物理位置、客户端及其物理位置、处理器说明、传输协议 HTTP超文本传输协议 HTTP是一种基于TCP 80端口在浏览器和web服务器之间传送网页信息的应用层协议。 TCP是一种面向连接的传输层协议，在数据传输之前需要在发送方和接收方之间建立一对一的连接（单播通信），因此HTTP使用TCP传送页面文件时，每个页面文件都需要单独建立一条TCP连接。 RIP路由协议 一种内部网关协议，采用距离向量算法，使用“跳数”来衡量到达目标的路由距离。 这种协议的路由只关心自己周围的世界，只与自己相邻的路由交换信息，范围限制在15跳以内，再远则不关心了（认为不可达）。 默认情况下，RIP使用一种非常简单的度量机制：距离就是通往目的站点所经的链路数，取值为1~15，数值16表示无穷大（不可达）。 系统可维护性评价指标（P397） 可理解性、可测试性、可修改性 系统维护工作类型（P397） 更正性维护：针对系统内隐藏的错误 适应性维护：为了适应软硬件环境变化 完善性维护：针对用户的功能扩充需求 预防性维护：针对可能会发生的变化或调整先行维护 计算机质量保证计划规范内容 验证：确定软件在开发周期中的一个给定阶段的产品是否达到上一阶段确立的需求的过程 确认：在软件开发过程结束时对软件进行评价，以确定它是否和软件需求相一致的过程 测试：通过执行程序来有意识地发现程序中的设计错误和编码错误的过程。 测试是验证和确认的手段之一。 集成平台的基本功能（P449） 通信服务　　提供透明的同步/异步通信服务功能（用户和应用无需关心具体的操作系统和网络物理位置）。 信息集成服务　　实现不同数据库系统间的数据交换、互操作、分布数据管理和共享信息模型定义，使继集成平台运行的应用、服务或用户端能够以一致的语义和接口实现对数据的访问与控制。 应用集成服务　　能够为应用提供数据交换和访问操作，使各种不同的系统能够相互协作。 二次开发工具 平台运行管理工具 企业集成模式（P451） 面向信息的集成　　强调实现数据的转换（不同数据格式和存储方式之间的转换）、数据源的统一（同一个数据仅有一个数据入口）、数据的一致性维护、异构环境下不同的应用系统之间的数据传送。 面向过程的集成　　采用工作流管理方式，强调处理不同应用系统之间的交互逻辑，与核心业务逻辑相分离，并通过不同应用系统之间的协作共同完成某项业务功能。 面向服务的集成　　强调大范围内的公共业务过程集成的动态继承方式，可以较好实现企业间具有松散耦合关系的不同应用之间的互操作。 企业应用集成 数据集成：提供企业之间的信息共享能力 API集成： 功能集成：通过重用现有逻辑来实现和提供更强大的功能 界面集成：使得用户对集成系统产生一个“整体”的感觉 EDI电子数据交换（P462） 电子数据交换是电子商务活动中采用的一种重要技术手段。 EDI的实施需要一个公认的标准和协议，将商务活动中涉及的文件标准化和格式化。 EDI通过计算机网络，在贸易伙伴之间进行数据交换和自动处理。 EDI主要应用于企业与企业、企业与批发商之间的批发业务。 EDI的实施在技术上比较成熟，但是实施EDI需要统一数据格式，成本与代价较大。 嵌入式系统软硬件协同设计过程（P510） 目标系统构思 系统需求描述 模块的行为描述 对模块的有效性检查 软硬件划分 性能评估 硬件综合、接口综合和软件编译 软硬件集成 软硬件协同仿真、系统评估与设计验证 下午题 Mysql主从复制优点 主从复制机制使得同样的数据可存在多个副本，这样用户在查询数据时，可以选择该数据最近的副本访问，从而提高访问效率、降低资源使用时的冲突。 Memcached缓存与数据库缓存差异 缓存架构：数据库仅缓存查询结果，适用面窄；Memcached则将数据库中的表进行缓存，对这些表的操作均可适用。 缓存有效性：数据库查询缓存时效较短（与配置有关）；Memcached缓存时效较长，只要未更新就属于有效状态。 缓存数据类型：数据库查询缓存为元组级；Memcached缓存数据为表级。 数据库系统提供的基本加解密方式 加解密API　　DBMS提供可在SQL中调用的加解密API，应用程序据此构建自己的基础架构，对数据进行加密保护。 加解密API的灵活性强，但构建和管理复杂。 透明加密　　安全管理员为数据库敏感字段选择加密方式及密钥强度，应用程序访问受保护数据时，只需使用口令打开或关闭密钥表，对数据的加密和解密由DBMS自动完成。　　透明加密方式管理简单，应用程序负担轻，但灵活性差。 反规范化技术 规范化设计后，数据库设计者希望牺牲部分规范化来提高性能，这种从规范化设计回退的方法称为反规范化技术。 优点：降低连接操作的需求、减少外码和索引的数目、还可能减少表的数目，能够提高查询效率。 缺点：数据重复存储，浪费硬盘空间；可能出现数据完整性问题；为了保障数据一致性，增加了数据维护的复杂性，降低修改速度。 反规范化技术主要有： 增加冗余列：在多个表中保留相同列，减少或避免查询时的连接操作。 增加派生列：增加由本表或其他表中数据计算生成的列，避免计算或使用集合函数。 重新组表：若许多用户要查看两个表连接得到的结果数据，则把两个表重组为一个表提高性能。 水平分割表：按行切割数据到多个独立表，多用于数据规模很大、或需要存放到多个介质的情况。 垂直分割表：按列分割，将主键与部分列放到一个表，主键与其他列放到另一个表，减少查询时的IO次数。 数据库分区 水平分区　　对表的行进行划分，使得所有在表中定义的物理列，在每一个分区表中都能得以保留，从而使得表的特性能够得以保持。 垂直分区　　对表的列进行划分，以减少表的宽度，使得某些特定列被划分到特定分区。（如把某些不常访问的超长列划分出去，则可以在保证数据相关性的同时提高访问速度）。 NoSQL的优缺点 优点： 支持高并发数据访问，性能较高。 数据存储结构松散，能够灵活支持多种类型的数据格式。 能够支持海量数据的存储，且易于横向扩展。 基于分布式数据存储，不存在单点故障和性能瓶颈，系统可用性高。 缺点： 现有产品不够成熟，大多数产品处于初创期。 并未形成一定的标准，产品种类繁多，缺乏官方支持。 不提供对SQL的支持，学习和应用迁移成本较高。 支持的特性不够丰富，现有产品提供的功能比较有限。 负载均衡技术（P40） DNS 负载均衡技术　　在DNS中为多个IP地址配置同一个名字，因而查询这个名字的客户端只能得到其中一个地址，使得不同的客户端访问不同的服务器。（最早的技术，简单有效，但不能区分服务器差异） 代理服务器/反向代理 负载均衡技术　　以代理服务器接受网络客户端的请求，并将这些请求动态、均匀地转发到内部网络的多台服务器，最后把请求结果返回给对应的客户端。（能实时考虑服务器的性能和负载，可缓存静态资源并提升访问速度，此时代理服务器对外表现为一个服务器） NAT（网络地址转换） 负载均衡技术　　将一个外部IP地址（即对内网而言的网关）映射为多个内部IP地址，对每一次TCP连接请求，均动态地使用其中一个内部地址，以达到负载均衡。（可屏蔽内网结构，缓解Internet地址紧张问题） 协议内部支持 负载均衡技术　　由通信协议自身算法实现的负载均衡技术，如HTTP协议中的重定向能力。 混合型 负载均衡技术　　由于多个服务器群内的软硬件设备、规模、提供服务等存在差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡（或集群起来），以一个整体对外提供服务，从而达到最佳性能。（有时也用于单台负载均衡设备，其性能不能满足大量请求的情况下） ABSD（基于体系结构的软件架构设计）概念（P131） ABSD强调由商业、质量和功能需求的组合驱动软件架构设计。 使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，并且设计活动的开始并不意味着需求抽取和分析活动可以终止，而是应该与设计活动并行。 ABSD方法是一个自顶向下、递归细化的过程。软件系统的架构通过该方法得到细化，直到能够产生软件构件的类。 ABSD方法的三个基础（P131） 对系统功能进行分解： 基于模块的内聚和耦合技术 选择体系结构风格： 实现质量和商业需求 软件模板的使用： 设计软件结构 ABSD的6个主要活动/子过程（P133） 需求：用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。 设计：通过需求来激发和调整设计决策（设计是迭代的过程） 文档化：文档是系统设计与开发人员的通信媒介、是验证体系结构时，执行预先分析的基础 复审：标识潜在的风险，及早发现体系结构设计中的缺陷和错误。 实现：用实体来显示出一个软件体系结构 演化：使用系统演化步骤去修改应用，以满足新的需求。 ABSD需求过程（P133） 需求获取 标识构件：生成类图、对类进行分组、把类打包成构件 需求评审 ABSD设计过程（P134） 提出体系结构模型 映射构件 分析构件相互作用 产生体系结构 设计评审 ABSD文档化（P135） 体系结构文档化过程的主要输出结果是 [体系结构规格说明] 和 测试体系结构需求的 [质量设计说明书] 。 文档要从 [使用者] 的角度进行编写，必须分发给 [所有与系统相关的开发人员]，且必须保证 [开发者] 手上的文档是最新的。文档中的描述应该尽量避免不必要的重复，每次文档的修改都应该进行记录。 ABSD复审（P135） 架构设计、文档化和复审是一个迭代过程。 在一个主版本的软件架构分析后，要安排一次由 [外部人员（用户代表或领域专家）] 参加的复审。 由用户代表和领域专家决定架构是否满足需求、质量需求是否在设计中得到体现。 复审过程中，通常会对一个可运行的最小化系统进行架构评估和测试。 复审的目标是标识潜在的风险，及早发现架构设计的缺陷和错误。 ABSD实现过程（P135） 分析与设计、构件实现、构件组装、系统测试 ABSD演化过程（P136） 需求变化归类 体系结构演化计划 构件变动（可利用构件库） 更新构件的相互作用 构件组装与测试 技术评审（若不能反映需求变动或不符合用户要求，需回到第2步迭代） 得到演化后的体系结构 系统架构风格（P137） 软件架构风格是描述某一特定领域中系统组织方式的惯用模式，它定义了一类架构所共有的特征，主要包括架构定义、架构词汇表和架构约束。 其中组织方式描述了系统的组成构件及其组织方式，惯用模式则反映了众多系统共有的结构和语义。 架构风格 子分类 说明 数据流风格 批处理序列 组件为一系列固定顺序的独立计算单元，组件间只通过数据传递交互，传递的数据必须是完整的   管道-过滤器 每个构件（过滤器）都有一组输入和输出，数据输入构件，经过内部处理，然后产生数据输出。这种风格的连接件就像是数据流传输的管道，将一个过滤器的输出传到另一个过滤器的输入 调用/返回 主程序-子程序 所有的计算构件作为子程序协作工作，并由一个主程序顺序地调用这些子程序，构件通过共享存储区交换数据   面向对象风格（数据抽象和面向对象组织） 将数据表示和基本操作封装在对象（构件）中，对象维护自身表示的完整性，对象间通过消息机制进行通信，对象交互时需要知道彼此的标识，通过对象间的协作完成计算过程   分层系统（层次结构） 每一层的构件为上层服务，并作为下层客户。此风格支持增加抽象层的设计，允许将一个复杂问题分解成一系列增量步骤的实现，由连接件控制层间构件的拓扑约束，系统结构更清晰 独立构件风格 进程通讯     事件驱动系统（隐式调用） 构件不直接调用一个过程，而是触发或广播一个或多个事件。系统中其他构件的过程在一个或多个事件中注册，因而当一个事件触发就会导致另一模块中的过程调用。基于事件驱动模式的系统具有某种意义上的递归性，形成了“部分-整体”的层次结构。 C2风格（虚拟机） 解释器 通常包括[正在被解释执行的伪码]和[解释引擎]。伪码由[需要被解释执行的源码]和[解释引擎分析所得的中间代码]组成；解释引擎包括[语法解释器]和[解释器当前的运行状态]。（典型如JVM：通过虚拟架构屏蔽不同的硬件环境）   基于规则的系统 通过连接件绑定在一起，按照一组规则运作的并行构件网络 仓库风格（仓库系统及知识库） 数据库系统 独立构件在中央数据存储区上执行，由构件控制共享数据。（系统由输入数据流中的事务信息来驱动）   超文本系统     黑板系统 系统根据中央数据单元的各种状态启动各种进程，以响应知识库的变化 复制风格 复制仓库     缓存系统   其他风格 CS（二层）结构 系统中的功能构件被充分隔离，客户端应用程序的开发集中于数据的显示和分析，而数据库服务器的开发则集中于数据的管理   CS三层结构 增加了应用服务器，可以将整个应用逻辑驻留在应用服务器上，而只有表示层存在于客户机上。三层CS把应用功能分成表示层、功能层和数据层   BS风格 是三层CS结构的另一种实现方式，其具体结构为 浏览器/WEB服务器/数据库   CS与BS混合软件体系结构 如内部采用CS风格，对外采用BS风格   面向Agent软件体系结构     Process Control（Loop）     Heterogenous Architecture（异构）     控制环路风格 将过程输出的指定属性维护在一个特定的参考值（设定点）该风格包括过程变量、被控变量、输入变量、操纵变量和设定点等构件，通过收集实际和理想的过程状态信息，调整过程变量使得实际状态趋于理想状态   闭环结构风格 通常由几个协作构件共同构成，且其中主要的构件彼此独立，能够单独进行替换和重用。但闭环结构通常只适用于处理简单任务（如机器装配等） 系统质量属性（P147） 质量属性 子属性 说明 架构策略 性能   单位时间内所处理事务的数量 或 系统完成某个事务处理所需的时间 资源需求：减少计算开销、控制采样频率、限制执行时间、限制队列大小资源管理：引入并发、维持数据或计算的多个副本、增加可用资源资源仲裁：先进先出、固定优先级调度、动态优先级调度 可靠性   在意外或错误使用的情况下维持软件系统的功能特性的基本能力 用平均失效等待时间（MTTF）和平均失效间隔时间（MTBF）衡量   容错性 在错误发生时确保系统正确的行为，并进行内部修复     健壮性 保护应用程序不受错误使用和错误输入的影响，遇到意外错误事件时确保应用系统处于已定义的状态 可用性   两次故障之间的时间长度 或 出现故障时系统能够恢复正常的速度 错误检测：命令/响应、心跳、异常错误恢复：表决、主动冗余、被动冗余、备件、Shadow操作、状态再同步、检查点/回滚错误预防：事务、进程监视器 安全性   系统在向合法用户提供服务的同时能够阻止非授权用户使用的企图或拒绝服务的能力 抵抗攻击：身份验证、用户授权、维护数据机密性、维护数据完整性、限制暴露信息、限制访问检测攻击：入侵检测从攻击中恢复：恢复状态、识别攻击者   机密性 保证信息不泄露给未授权的用户、实体或过程     完整性 保证信息的完整和准确，防止被非法修改     不可否认性       可控性 保证对信息的传播及内容具有控制的能力，防止为非法者所用   可修改性   能够快速地以较高的性价比对系统进行变更的能力 局部化修改：减少由某个变更直接影响的数量防止连锁反应：限制对局部化的模块的修改延迟绑定时间：控制部署时间和成本   可维护性 体现在对问题的修复     可扩展性 使用新特性扩展软件系统     结构重组 重新组织软件系统的构件及构件间的关系     可移植性 使软件适用于多种硬件平台、用户界面、操作系统、编程语言或编译器   功能性   系统完成所期望的工作的能力   可变性   经扩充或变更而成为新体系结构的能力   互操作性   与其他系统或自身环境相互作用的能力   可测试性 易安装性易替换性适应性 在完成一个软件的增量开发后，能轻松地对其进行测试的能力 输入/输出：记录回放、将接口与实现分离、特化访问路线/接口内部监视：内置监视器 易用性 易理解性易操作性易学性 衡量用户使用一个软件产品完成指定任务的难易程度 运行时战术：维持任务的一个模型、维持用户的一个模型、维持系统的一个模型设计时战术：将用户接口与应用的其余部分分离开来 系统架构评估（P149） 系统架构风险（风险点/非风险）：指在架构设计中潜在的、存在问题的架构决策所带来的隐患。 敏感点：为了实现某种特定的质量属性，一个或多个构件所具有的特性。 权衡点：是影响多个质量属性的特性，是多个质量属性的敏感点。 UML的10种4类模型视图（P158） 机制 分类 子分类1 子分类2 说明 静态建模机制 用例图     从用户角度描述系统功能，并指出各功能的操作者   静态图 类图   描述类的静态结构（属性、操作）和类间关系（关联、依赖、聚合）     对象图   类图的实例，几乎与类图标识一样，但存在生命周期     包图（软件体系结构图）   由包与类组成，标识包与包的关系，描述系统的分层结构   实现图 构件图   描述代码部件的物理结构及各部件间的依赖关系，以分析和理解部件间的相互影响程度     配置图（部署图/实施图）   定义系统中软硬件的物理体系结构 动态建模机制 行为图 状态图（行为模型）   描述类的对象所有可能的状态，及事件发生时的状态转移条件     活动图   特殊的状态图，强调对象内的控制流程，描述流程化处理     交互图（用例实现图） 顺序图（时序图） 描述一组对象及其收发的消息，反映对象间的交互关系，强调按时间顺序对控制流建模       协作图（合作图） 描述一组对象间的连接及其收发的消息，反映对象间的协作关系，强调按组织结构对控制流建模 数据流图 数据流图（DFD）是以图形方式描述数据在系统中流动和处理的过程，由于它只反映系统必须完成的功能，因此它是一种功能模型，其包含4种基本元素： “→”箭头表示数据流，是数据在系统内传播的路径，由一组成分固定的数据组成。 “o”圆或椭圆表示加工，是对数据进行处理的单元，它接收一定的数据输入，处理后产生输出。 “=”双杠表示数据存储，即信息的静态存储，可以是文件、文件的一部分、数据库的元素等。 “□”矩形表示外部实体，是数据的源点或终点，可以是人、物或其他软件系统。 数据流图的常见错误类型 黑洞：加工仅有输入流，缺少输出流。 奇迹：加工仅有输出流，缺少输入流。 重名：多条数据流经过加工后，命名不变。 错误：数据流的源点或终点错误，如：　　外部实体没有经过加工处理，直接到数据存储。　　外部实体之间没有加工处理，存在直接数据流。 数据流图、流程图的含义与区别 含义：　　数据流图是用来说明业务处理过程、系统边界所包含的功能和系统中的数据流。　　流程图展示应用程序从数据输入开始到获得输出为止的逻辑过程，描述的是处理过程的控制流。 区别： 数据流图中的处理过程可并行；流程图在某个时间点只能处于一个处理过程。 数据流图展现系统的数据流；流程图展现系统的控制流。 数据流图展现全局的处理过程，过程之间遵循不同的计时标准；流程图中处理过程遵循一致的计时标准。 数据流图适用于系统分析中的逻辑建模阶段；流程图适用于系统设计中的物理建模阶段。 数据流图设计原则 复杂性最小化：DFD分层结构就是把信息划分为小的且相对独立的一大批子集，以便于单独考查每一个DFD，如果要了解某个过程更详细的信息，可以跳转到上一层的DFD再考查。 接口最小化：在设计模型时，应使得模型中各个元素之间的接口数或连接数最小化。 数据流一致性：一个过程和它的分解在数据流内容中应保持一致，数据流不应该存在“黑洞”，也不应该存在“奇迹”。 CRUD矩阵 指利用矩阵的形式来表示各个不同用户对不同操作的动作行为。其中，C（Create）→产生，R（Read）→引用，U（Update）→更新，D（Delete）→删除。 [success] 小诀窍：只要用户与操作之间存在关系，则至少必存在R关系。 4+1视图（P181 - 图P103） 逻辑视图：设计的对象模型，说明系统应为用户提供哪些服务 过程视图：捕捉设计的并发和同步特征 物理视图：描述了软件到硬件的映射，反映了分布式特性 开发视图：描述了在开发环境中软件的静态组织结构 用例视图：围绕上述4个视图所做的各种决定，强调从用户角度看到的或需要的系统功能，是最基本的需求分析模型。 设计模式（P195） 创建性模式：就是创建对象的模式，抽象了实例化的过程。它帮助一个系统独立于如何创建、组合和表示它的那些对象。 结构性模式：解决怎样组装现有的类，设计他们的交互方式，从而达到一定功能的目的。 行为性模式：涉及到算法和对象间的职责分配。它描述了对象和类的模式，以及他们之间的通信模式，刻画了在程序运行时难以跟踪的复杂的控制流。 [info] 设计模式图例也要清楚。 分类 设计模式 说明 应用场景 创建性模式 Abstract Factory（抽象工厂） 提供一个创建 [一列相关或相互依赖对象的] 接口，而无需指定具体的构造类 · 期望所提供的类库，只开放接口而非实现· 一系列相关的对象是共同使用的（必须保证，否则可用Factory Method作为替代）   Factory Method（工厂方法） 定义一个用于创建对象的接口，让子类决定将哪一个类实例化 · 类不能预料它所必须创建的对象的类· 类希望其子类指定它要创建的对象   Builder（构建器 / 建造者） 将一个复杂对象的构建与其表示相分离，使得相同的构造过程可以创建不同的对象 · 创建对象的算法独立于对象的组成部分· 构造过程必须允许已构建对象有不同的表示   Prototype（原型） 用原型实例指定创建对象的种类，并通过原型拷贝来创建新的对象 · 在运行时需要实例化类（如动态载入）· 类的实例是仅有的一些不同状态组合之一   Singleton（单例） 保证一个类仅有一个实例，并提供一个访问它的全局访问点 · 只有一个类实例 结构性模式 Adapter（适配器） 将一个类的接口转换成期望的另一个接口 · 要使用的已有类与所需接口不匹配· 所创建的可重用的类不需要兼容接口· 在一个不同于已知对象接口的接口环境中使用· 必须进行多个源之间的接口转换   Bridge（桥接） 将抽象部分与其实现部分分离，使它们均可独立地变化 · 想避免抽象与实现之间存在永久性绑定· 抽象及其实现可使用子类进行扩展· 抽象的实现被改动对客户端无影响   Composite（组合） 将对象组合成树形结构，以表示[部分-整体]的层次结构，使得对单个对象和复合对象的使用具有一致性 · 想要表示对象的整个或部分层次结构· 想要忽略复合对象和单个对象间的差异· 结构可以具有任何级别的复杂性，且为动态的   Decorator（装饰者） 在不修改对象外观和功能的情况下添加或删除对象功能，可动态地为一个对象添加额外的职责 · 为对象动态而透明地添加职责，不影响其他对象· 想要在以后可能会修改的对象中添加职责· 无法通过静态子类化实现扩展   Facade（外观） 为子系统中的一组接口提供了一个统一的高级接口，使得子系统更易使用 · 想要为复杂的子系统提供简单的接口· 在客户端和抽象的实现类中存在许多依赖关系· 想要对子系统进行分层   Flyweight（享元 / 轻量） 通过共享技术大量减少细粒度对象，避免多个具有相同信息的实例带来的开销 · 应用程序使用了大量的对象· 因对象数量巨大造成很高的存储开销· 应用程序不依赖于对象的身份   Proxy（代理） 为其他对象提供一个代理以控制这个对象的访问 · 需要比简单的指针更灵活、更全面的对象引用 行为性模式 Template Method（模板） 定义一个操作中的算法骨架，将一些步骤迟延到子类中实现，使得可以不改变一个算法的结构即可重定义该算法某些特定步骤 · 期望一次实现算法不变的部分，而由子类实现可变的行为· 把子类的通用行为定义到通用类，避免重复代码   Command（命令） 将一个请求封装成一个命令对象，这样就可以保存命令，并将命令传递给方法，再由该方法返回该命令 · 希望通过要执行的动作来参数化对象· 要在不同的时间指定、排序以及执行请求· 必须支持Undo、日志记录或事务   Interpreter（解释器） 给定一个语言，定义其文法的一种表示，并定义一个解释器，用该表示去解释语言中的句子 · 语言的语法比较简单· 效率并非最主要的问题   Chain of Responsibility（责任链） 使多个相关对象连成一条链，并沿着链传递发送者的请求，直到有一个对象处理之 · 多个对象可以处理一个请求，而处理器却未知· 希望在不确定请求的接收对象的情况下，向多个对象中的一个发送请求· 可以动态指定能够处理请求的对象集   Memento（备忘录） 保持对象状态的“快照”，使得对象可以在不向外界公开其内容的情况下返回到它的最初状态 · 必须保存对象状态的快照以便以后恢复状态· 使用直接接口获得状态可能会公开对象的实现细节，从而破坏对象的封装性   State（状态） 允许对象在内部状态变化时，改变其行为，并修改其类 · 操作具有大量以及多部分组成的取决于对象状态的条件语句   Strategy（策略） 定义一系列的封装好的算法，让它们可以相互替代，且算法的变化可以独立于使用它们的用户 · 相关类只在行为方面有所区别· 需要算法的不同变体· 算法使用客户端未知的数据   Observer（观察者） 定义了对象间一到多的依赖关系，这样当对象改变状态时，将自动通知并更新它所有依赖的对象 · 对一个对象的修改涉及到对其他对象的修改，且不知道有多少对象需要进行相应的修改· 对象在不用假设对象标识的前提下通知其他对象   Iterator（迭代） 提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示 · 不开放集合对象内部表示的前提下访问其内容· 支持集合对象的多重遍历· 为遍历集合中的不同结构提供了统一的接口   Visitor（访问者） 不改变原来类结构（固定结构）的基础上增加新的功能 · 对象结构包含许多具有不同接口的对象类，并且需要对这些依赖于具体类的对象进行操作· 定义对象结构的类很少被修改，但希望在此结构上定义新操作   Mediator（中介者） 用一个中介对象来封装一系列对象的交互，使各对象不需显式地相互引用，从而使其耦合松散，而且可以独立改变对象间的交互 · 对象集合需以一个定义规范但复杂的方式通信· 希望在不使用子类的情况下自定义分布在几个对象之间的行为 获取构件的方法（P247） 从现有构件中获得符合要求的构件，直接使用或作适应性的修改，得到可重用的构件。 通过遗留工程，将具有潜在重用价值的构件提取出来，得到可重用的构件。 从市场上购买现成的商业构件，即COTS（Commercial Off-The-Shell）构件。 开发新的符合要求的构件。 开发构件的策略（P267） 修改已有构件，产生新构件。 全新开发新构件。 构件组装（P271） 将构件库中的构件经适当修改后互相连接，或将它们与当前开发项目中的软件元素相连接，最终构成新的目标软件。构件组装技术大致可以分为三种： 基于功能的组装技术　　采用子程序调用和参数传递的方式将构件组装起来。它要求库中的构件以子程序/过程/函数的形式出现，并且接口说明必须清晰。开发人员使用此组装技术时，需先对目标软件系统分解成强内聚、松耦合的功能模块，再根据各模块功能提取构件，进行适应性修改后挂接到功能分解框架中。 基于数据的组装技术　　根据当前软件问题的核心数据结构设计出一个框架，再根据框架中各结点的需求提取构件并进行适应性修改，最后把构件逐个分配到框架中的适当位置。这种组装方式也要求构件以子程序形式出现，但依赖的软件设计方法不是功能分解，而是面向数据的设计方法。 面向对象的组装技术　　如果从类库中检索出来的基类能够完全满足新软件项目的需求，则直接使用；否则必须以类库中的基类为父类，采用构造法或子类法生成子类。由于封装和继承特性，该技术更适合支持软件重用。 主流构件标准（P275） CORBA、COM/DCOM/COM+、EJB 主要的身份认证技术（P315） 用户名和口令认证：主要是通过一个客户端和服务器共知的口令（或与口令相关的数据）进行验证。根据处理形式的不同，分为直接通过明文传送验证数据、利用单向散列函数处理验证数据、利用单向散列函数和随机数处理验证数据。 令牌认证：该方式中，进行验证的密钥存储于令牌中。目前的令牌包括安全认证书和智能卡等。 生物识别认证：主要是根据认证者的图像、指纹、气味和声音等作为认证数据。 授权侵犯 指被授权以某一目的使用某一系统或资源的某人，将此权限用于其他非授权的目的，也称“内部攻击”。 抗抵赖框架 内容：框架中的抗抵赖服务包括证据的生成、验证和记录，以及在解决纠纷时随即进行的数据恢复和再次验证。 目的：提供有关特定事件或行为的证据。 如必须确认数据原发送者和接受者的身份和数据完整性，在某些情况下，可能需要涉及上下文关系的证据（如日期、事件、原发者/接受者的地点等）。 基于口令的简单认证机制 与 基于公钥体系的认证机制 优缺点比较 口令认证方式实现简单，但由于口令复杂度及管理方面等原因，易收到认证攻击。而在公钥认证方式中，由于其密钥机制的复杂性，同时在认证过程中私钥不在网络上传输，因此可以有效防止认证攻击，与口令认证方式相比更安全。 口令的认证方式中，用户口令为用户与服务器共享，没有用户独有的直接秘密信息。而在公钥认证方式中，可基于用户私钥对私有数据进行加密保护。 公钥认证方式，其协议和计算的复杂度要高于口令认证方式，同时由于管理复杂、认证效率低，其使用环境的用户数不宜过多。 对称加密策略 机密性：发送者利用对称密钥对要发送的数据进行加密，只有拥有正确相同密钥的接收者才能将数据正确解密，从而提供机密性。 完整性：发送者根据要发送的数据生成消息认证码（或消息摘要），利用对称密钥对消息认证码进行加密并附加到数据上发送；接收者使用相同密钥将对方发送的消息认证码解密，并根据接收到的数据重新生成消息认证码，比较两个认证码是否相同以验证数据的完整性。 公钥加密策略 机密性：发送者利用接收者的公钥对要发送的数据进行加密，只有拥有对应私钥的接收者才能将数据正确解密，从而提供机密性。 完整性：发送者根据要发送的数据生成消息认证码（或消息摘要），利用自己的私钥对消息认证码进行加密并附加到数据上发送；接收者利用对方的公钥将对方发送的消息认证码解密，并根据接收到的数据重新生成消息认证码，比较两个认证码是否相同以验证数据的完整性。 软件可靠性的定量描述（P355） 规定时间　　自然时间：即日历时间，指日常计时用的年、月、日等自然流逝的时间段。　　运行时间：指软件从启动开始，到运行结束的时间段。　　执行时间（最准）：指软件运行过程中，CPU执行程序指令所用的时间总和。 失效概率　　F(t)表示软件运行时失效的随机函数，在时间域(0,+∞)单调递增，F(0)=0，F(+∞)=1 可靠度　　系统软件在规定的条件下、规定的时间内不会发生失效的概率。R(t)=1-F(t) 失效强度　　单位时间软件系统出现失效的概率。f(t)=F’(t) 失效率　　又称风险系数，或条件失效强度。　　是指在运行至此软件系统未出现失效的情况下，单位时间软件系统出现失效的概率： λ(t) = R'(t) / R(t) 可靠度与失效率之间的换算　　当可靠度 R(t)>0.95 时，λ(t)= (1-R(t)) / t 平均无失效时间　　软件运行后，到下一次出现失效的平均时间。 可靠性设计技术（P377） 容错设计技术：用于软件失效后果特别严重的场合。 检错技术：在软件出现故障后能及时发现并报警，提醒维护人员处理。 降低复杂度设计：在保证软件功能的基础上，降低软件复杂度（简化结构、缩短代码长度、优化数据流等），从而提高软件可靠性。 容错设计技术（P377） 恢复块设计、N版本程序设计、冗余技术 恢复块设计（P377） 是一种动态故障屏蔽技术。一个恢复块包含有若干个功能相同、设计差异的程序块文本，每一时刻有一个文本处于运行状态。一旦该文本出现故障，则用备份文本加以替代，从而构成“动态冗余”。 N版本程序设计（P377） 是一种静态故障屏蔽技术，其设计思路是用N个具有相同功能的程序同时执行一项计算，结果通过多数表决来选择。其中N个版本的程序必须由不同的人独立设计，使用不同的方法、设计语言、开发环境和工具来实现。目的是减少N版本程序在表决点上相关错误的概率。 冗余技术（P377） 实现容错计算的主要手段是冗余。 冗余技术 分类 说明 结构冗余（硬件冗余） 静态冗余 通过表决和比较来屏蔽系统中出现的错误   动态冗余 多重模块待机储备，相继运行，以维持系统的正常工作（冷备、热备系统）   混合冗余 静态冗余和动态冗余的综合，效果最好，成本很高，仅用于可靠性要求极高的情况 信息冗余   在实现正常功能所需的信息外，再添加一些额外信息，以保证运行结果的正确性 时间冗余   以降低系统运行速度为代价，减少硬件冗余和信息冗余的开销，以达到可靠性的目的 冗余附加技术   指为实现上述冗余技术所需的资源和技术 动态冗余（P378） 又称主动冗余，它是通过故障检测、故障定位及故障恢复等手段达到容错的目的，其主要方式是多重模块待机储备，当系统检测到某工作模块出现错误时，就用一个备用模块代替它并重新运行。 各备用模块在其待机时，可与主模块一样工作，也可以不工作。前者叫热备份系统（双重系统），后者叫冷备份系统（双工系统、双份系统）。 检错技术优缺点（P378） 优点：实现代价一般低于容错技术和冗余技术。 缺点：不能自动解决故障，出现故障后如果不进行人工干预，最终将导致系统不能正常运行。 检错设计技术要素（P378） 检测对象　　① 检测点：容易出错的地方和出错对软件系统影响较大的地方。　　② 检测内容：有代表性的、易于判断的指标。 检测延时　　从软件发生故障到被自检出来的延时时间。若延时过长，甚至影响故障的及时报警，则需更换检测对象或检测方式。 实现方式　　① 判断返回结果：如果返回结果超出正常范围，则进行异常处理。　　② 计算运行时间：如果某个模块或函数运行时间超过预期时间，可以判断出现故障。　　③ 置状态标志位： 处理方式　　大多数都采用“查出故障-停止软件运行-报警”的处理方式。　　但根据故障的不同情况，也可以不停止软件运行，这一般由故障是否需要实时处理决定。 FMEA失效模式与效应分析（P379） FMEA是FMA（故障模型分析）和FEA（故障影响分析）的组合，它对系统各种可能的风险进行评价、分析后，在现有技术的基础上消除这些风险，或将这些风险降低到可接受的水平。 FMEA主要活动 找出产品/过程中潜在的故障模式 根据相应的评价体系对 [所找出的潜在故障模式] 进行风险量化评估 列出故障起因/机理，寻找预防或改进措施。 FMEA分类 由于产品故障可能与设计、制造过程、使用、承包商/供应商的服务有关，因此FMEA又分为： 设计FMEA、过程FMEA、使用FMEA、服务FMEA ODP分布式数据架构（P382） 由多个计算机系统上的多个局部数据库系统构成，数据可以在这些数据库中进行传送，并接受不同的DBMS的管理。同时，安装了这些系统的机器分布在不同的地理位置，并通过多种通信网络连接在一起，使得企业数据可以分布在不同的计算机上，而一个应用程序则可以操作位于不同地理位置的机器上的数据。 集中式数据架构 集中式数据架构，是由一个处理器、与它相关联的数据存储设备以及其他外围设备组成，它被物理地定义到单个位置。 根据系统提供的数据处理能力，用户可以在同样的站点上操作，也可以在地理位置隔开的其他站点上通过远程终端来操作。系统及其数据管理被某个站点或中心站点集中控制。 集中式和分布式数据架构的扩展方式 集中式　　通过向上扩展提升系统的可扩展性。　　具体的实现方式包括硬件扩容（增加CPU数量、内存容量、磁盘数量等）和硬件升级（更换为高端主机或高速磁盘等）。 分布式　　通过向外扩展提升系统的可扩展性。　　具体的实现方式包括数据复制、数据垂直切分/水平切分、缓存和全文搜索。 开放式架构的基本特点 可移植性：各种计算机应用系统可在具有开放式架构特性的各种计算机系统中进行移植，不论这些计算机是否为同种型号、同种机型。 可互操作性：若计算机网络中的各节点机都具有开放架构的特性，则该网络上各节点机间可相互操作和资源共享。 可剪裁性：若某计算机系统具有开放性架构特性，则在该系统的低档机上运行的应用系统应能在高档机上运行，原在高档机上运行的应用系统经过裁剪后也可在低档机上运行。 易获得性：在具有开放架构特性的机器上所运行的软件环境易于从多方获得，不受某个来源控制。 MVC架构风格（P419） 通过把业务逻辑、数据、界面显示进行分离的代码组织方法。它将业务逻辑聚集到一个部件中，在个性化定制界面以及改进用户交互的同时，不需要重新编写业务逻辑。 MVC架构把整个软件系统划分为模型（M）、视图（V）和控制器（C）三个部分，其中： 模型：负责维护并保存具有持久性的业务数据，实现业务处理功能，并将业务数据的变化情况及时通知视图。 视图：负责呈现模型中包含的业务数据，响应模型变化通知，更新呈现形式，并向控制器传递用户的界面操作。 控制器：负责将用户的界面动作映射为模型中的业务处理功能并实际调用之，然后根据模型返回的业务处理结果选择新的视图。 MVC设计模式-示例图（P419） P419 MVC模式的优点（P420） 允许多种用户界面的扩展：新增界面只需改动对应的视图和控制器，模型无需变动。 易于维护：模型在扩展时若保持接口不变，则控制器和视图无需变动。 功能强大的用户界面：程序使用更清晰，界面发布更友好。 从设计模式角度描述用XML作为GUI描述语言的机制（P421） 从设计模式的角度来说，整个XML表现层解析的机制是一种策略模式。 在调用显示GUI时，不是直接地调用特定表现技术的API，而是装载GUI对应的XML配置文件，然后根据特定的表现技术解析器解析XML，得到GUI视图实例对象。 这样，对GUI开发人员来说，GUI视图只需要维护一套XML文件即可。 基于XML的界面管理技术（P422） 基于XML的界面管理技术可实现灵活的 界面配置、界面定制 和 界面动态生成。 界面配置：是对用户对界面的静态定义，通过读取配置文件的初始值对界面配置。由界面配置对软件功能进行裁剪、重组和扩充，以实现特殊需求。 界面定制：是对用户界面的动态修改过程。在软件运行过程中，用户可按需求和使用习惯，对界面元素的属性进行修改。软件运行结束时，界面定制的结果被保存。 动态生成界面：系统通过DOM API读取XML配置文件的表示层信息，通过数据存取类读取数据库中的数据层信息，运行时由界面元素动态生成界面。界面配置和定制模块在软件运行前后修改配置文件、更改界面内容。 基于XML的界面管理技术框架-示例图（P423） P423 TLS三层栈软件总体架构特点 应用层（AL）、操作系统层（OSL）、模块支持层（MSL） -> 硬件平台 应用软件与操作系统服务相关，不直接操作硬件 操作系统通过模块支持层访问硬件，可与具体硬件无关 模块支持层将硬件抽象成标准操作 通过三层栈的划分可实现硬件的快速更改与升级，应用软件的升级不会引起硬件的变更 嵌入式操作系统VxWorks与Linux的差异（P505） 比较类型 VxWorks Linux 工作方式 操作系统与应用程序处于同一的存储空间 操作系统与应用程序处于不同的存储空间 多任务支持 支持多任务（线程）操作 支持多进程、多线程操作 实时性 硬实时系统 实时系统 安全性 任务间无隔离保护 支持进程间隔隔离保护 标准API 支持 支持 Linux操作系统特点 Linux是一种安全性较强的操作系统。其内核工作在系统态，应用软件工作在用户态，可以有效防止应用软件对操作系统的破坏。 Linux系统调度的最小单位是线程，线程归属于进程，进程具有自己的独立资源。进程通过MMU实现多功能应用间隔离。 Linux系统支持硬件抽象，可以有效实现TLS结构，并将硬件抽象与操作系统分离，便于实现硬件的外场快速更换。 嵌入式操作系统故障类型 硬件故障：如CPU、存储器和定时器等 应用软件故障：如数值越界、异常和超时等 操作系统故障：如越权访问、死锁和资源枯竭等。 嵌入式操作系统故障滤波算法 门限算法、递减算法、递增算法、周期滤波算法 嵌入式操作系统容错算法 N+1备份、冷备、温备、热备 基于VME总线机载和基于FC总线机载的嵌入式系统架构比较 VME总线采用存储映射方式、多主机仲裁机制，仲裁方式为菊花链方式（串行仲裁），同一时刻仅由单一主机控制，导致任务执行时延大，限制了可扩展性，实时性差，带宽低。 FC总线采用消息包交换机制，支持广播和组播，任务并发性好，传输距离远，误码率低，且允许在同一接口上传输多种不同的协议，可扩展性好，可靠性高，实时性好，带宽高。 ESB企业服务总线（P537） 企业服务总线是由中间件技术实现的面向服务架构的基础软件平台，支持异构环境中的服务以基于消息和事件驱动模型式的交互，并且具有适当的服务质量和可管理性。 ESB主要功能（P538） 提供位置透明的消息路由和寻址服务（服务位置透明性） 提供服务注册和命名管理功能 支持多种消息传递范型（如请求/响应、发布/订阅等） 支持多种可以广泛使用的传输协议（传输协议转换） 支持多种数据格式及其相互转换（消息格式转换） 提供日志和监控功能（监控与管理） 消息增强支持 安全性支持 ESB作为集成框架的优点 能够实现灵活的部署结构，包括CS结构、P2P结构等 待集成系统只需和总线进行联系，彼此间无需相互通信，大大降低了系统的耦合程度 在加入新的集成系统时，只需采用插件的方式实现传输协议和数据格式适配即可，系统的可扩展性较强。 项目计划应包含的内容 项目背景 项目经理及其主管领导、客户方及其主管领导、项目管理团队、项目实施团队 项目总体技术解决方案 项目的管理过程及执行水平 项目过程的工具、技术和输入输出的描述 项目的生命周期和相关的项目阶段 项目的最终目标和阶段性目标 进度计划 项目预算 变更流程和变更控制委员会 对于内容、范围和事件的关键管理评审，以便于确定悬留问题和未决决策 缩短项目工期的方式 快速跟进　　通过对项目各阶段的逻辑关系进行并行调整来缩短项目周期。　　它是在当风险不大时，通过精心安排而使项目的前后阶段相互搭接，以加快项目进展的做法。　　快速跟进只是将部分工作提前开始，所以不会明显增加成本。 赶工　　对成本和进度进行权衡，确定如何在尽量少地增加费用的前提下最大限度地缩短项目所需的时间。 REST表现层状态转换技术 REST从资源的角度来定义整个网络系统结构，分布在各处的资源由统一资源标识符URI确定，客户端应用程序通过URI获取资源的表现，并通过获得资源的表现使其状态发生改变。 REST中将 [资源] 、 [资源的表现] 和 [获取资源的动作] 三者进行分离。 REST是一种只使用HTTP和XML的基于WEB通信的技术，它可以降低开发的复杂性，提高系统的可伸缩性。而其简单性和缺少严格配置文件的特性将其与SOAP很好地隔离开来。从根本上说，REST只支持几个操作（POST、GET、PUT、DELETE），而这些操作适用于所有消息。 REST设计原则 网络上所有事物都被抽象为资源 每个资源对应一个唯一的资源标识 通过通用的连接件接口对资源进行操作 对资源的各种操作不会改变资源的标识 所有的操作都是无状态的 XACML（可扩展访问控制标记语言）相对于MAC（强制访问控制）的优点 授权的可管理性：RBAC（基于角色的控制访问）将用户与权限分离，与MAC相比，减少了授权管理的复杂性，更适合于大型企业级系统的安全管理。 细粒度访问控制的支持：XACML提供了统一的访问控制策略描述语言，策略表达能力强，可以用来描述各种复杂的和细粒度的访问控制安全需求，更适合企业复杂业务功能的访问控制要求。 分布式环境的支持：XACML的标准性便于各子系统的协作交互，各子系统或企业业务部门可以分部管理访问控制权限；而MAC则通常需要对访问控制权限集中管理，不太适合企业基于SOA集成后的分布式系统。 论文题 论文通用题型 概要叙述你参与管理和开发的软件项目，以及你在其中承担的主要工作 分析【XXX】的主要技术/手段/内容，并说明选择【XXX】的原因。 结合具体参与管理和开发的实际项目，举例说明【XXX】的具体实施过程，并详细分析实施效果。 注意：选好题型后，不要忘记在答题纸上画圈和填写考号！！！ 论文评分点 切题：30% 引用与水平深度：20% 实践性：20% 表达方式：15% 综合能力与分析能力：15% 字迹：100% 加分点 扣分点 有独特见解，体会深刻、突出 字迹潦草，难以辨认 符合当今信息系统发展的新趋势、新动向，并加以利用 自我吹嘘、自我标榜、夸大其词 内容详实，思路清晰，符合提议 通篇理论或内容空洞，泛泛而谈 论文模板 **摘要：（300-400字，先摘要，再正文，占分5-10）** y年m月，根据 xxx （项目背景） 的需求，我所在的 xxx （公司、团队）组织了 xxx （项目名称）项目的开发。该项目 yyy （简单项目介绍，功能模块等）。在该项目中，我担任了 ??? （项目角色）。通过采取 zzz（论文主题，包括相关的技术、方法、工具、措施），使项目得以实施完成，并正稳定地投入使用。但其实，该项目除了 aaa （特色之处、发展趋势），其实还存在 bbb （不足之处、如何改进）。 **正文：（2000-3000字，先立纲，再下笔，思维导图）** 　1. 项目概述（400-600字，切忌照抄摘要）： 　　1.1. 开发项目概述 　　1.2. 我承担的角色和工作 　　1.3. 项目的架构情况概述 　2. 采用的技术，为什么（1000-1400字，直奔论文主题，可以图文并茂，分点论述，但层次不宜太深） 　3. 技术的效果（200-300字，佐证论点的好处） 　4. 不足之处和改进方案（200-300字，万事不尽美，报喜不报忧会很假） 　5. 总结（100-200字，心得，我学到了什么，可以合并到第4点） 示例论文 摘要： 201x年11月，由于我司现有的 【告警保障系统 服役时间太长，性能、维护、扩展等多方问题日益严重】 （项目背景），于是我所在的 【网管团队】 （公司、团队）启动了 【告警保障系统】 （项目名称）的项目重构开发。该系统包括 【告警的采集过滤和上报、告警的规则事务管理、数据模型转换管理、通信协议管理、统计报表生成、资源集中监控器等多个业务功能模块，以及其他预留的扩展功能接口】 （简单项目介绍，功能等）。 在该项目中，我担任了架构师的职责，通过采取 zzz （论文主题，包括相关的技术、方法、工具、措施），使项目得以实施完成，并正稳定地投入使用。本文将结合我的实际工作经验，对相关过程进行描述。 正文： 　1. 项目概述（400-600字，切忌照抄摘要）： 　　1.1. 开发项目概述 　　1.2. 我承担的角色和工作 　　1.3. 项目的架构情况概述 　2. 采用的技术，为什么（1000-1400字，直奔论文主题，可以图文并茂，分点论述，但层次不宜太深） 架构角度：整体框架采用了 主程序-子程序架构风格 设计模式： 核心功能模块采用了 生产者消费者模式、有限状态机模式，以及为了容错采用的备忘录模式。 辅助功能模块采用了多种设计模式， 如共享资源的工厂模式、数据协议转换的适配器模式、资源集中监控器的中介者模式， 特定的算法模板、配置的单例模式等等 质量属性： 性能：统计报表结合sqlite和内存映射，减少IO； 系统关键位置的多线程资源解耦，避免同步。 苛刻对待内存管控，避免浪费开销。 使用数据池、线程池技术。 数据结构的选择，JVM数据结构的运行，关键代码采用本地化方式优化（牺牲平台无关性） 输入输出优化：后台集群、缓存。 可修改性：预留扩展接口，保证可扩展性。 Maven架构管理构件，SVN版本控制（可维护性） 完善的程序文档 可靠性：预防式编程，健壮性 Socket中介，减少数据库直连数 可用性：心跳，异常捕获，logback日志跟踪，基于签到模式的统计，及时发现故障并自动恢复 安全性：与Socket交互先登录，保证授权使用（机密性） 核心口令采用C++编写（机密性，牺牲平台无关性） 混淆打包（机密性） 可测试性：持续集成，测试驱动开发，功能模块保留完整测试用例，更新算法时先用用例验证。 容错设计： 以检错设计为主，核心模块采用动态冗余（采集、适配、上报） 构件管理：常用构件平台，构件管理Maven与Nexus（第三方成品构件） 　3. 技术的效果（200-300字，佐证论点的好处） 　4. 不足之处和改进方案（200-300字，万事不尽美，报喜不报忧会很假） 　5. 总结（100-200字，心得，我学到了什么，可以合并到第4点） 通过使用xxx技术，最终有效地 aaa （特色之处、发展趋势），但也遇到了一些问题： bbb （不足之处、如何改进）。 历年论文题目 2014论软件需求管理（P109） 软件需求管理是一个对系统需求变更了解和控制的过程。需求管理过程与需求开发过程相互关联，初始需求导出的同时就要形成需求管理规划，一旦启动了软件开发过程，需求管理活动就紧密相伴。 需求管理过程中主要包含变更控制、版本控制、需求跟踪和需求状态跟踪等4项活动，其目标是为项目管理人员建立一个软件需求基线，并保持软件计划、产品和活动与软件需求的一致性。 问题：请以“软件需求管理”为题，依次从以下三个方面进行论述。 1．概要叙述你参与管理和开发的软件项目以及你在其中所担任的主要工作。 2．详细描述需求管理过程中各个活动中的主要工作。 3．详细说明你所参与的软件开发项目中，是如何进行软件需求管理的，实施的具体效果如何。 2014论非功能性需求对企业应用架构设计的影响（软件架构策略） 企业应用架构(Enterprise Application Architecture) 描述了企业IT系统的功能和技术实现内容，它在企业信息化建设中起到了统一规划、承上启下的作用，向上承接了企业战略发展方向和业务模式，向下规划和指导企业各IT系统的定位和功能。企业应用架构包括了企业的应用架构蓝图、架构标准、系统的边界和定义、系统间的关联关系等。其中非功能性需求是进行企业应用架构设计时需要重点考虑的因素，不同类型的非功能性需求从不同侧面影响应用系统的架构设计。 问题：请以“非功能性需求对企业应用架构设计的影响”为题，依次从以下三个方面进行论述。 1．概要叙述你参与分析和开发的企业应用系统项目以及你所担任的主要工作。 2．分析在企业应用架构设计中应该考虑哪些非功能性需求，详细阐述这些非功能性需求是如何影响架构设计的。 3．详细说明你所参与的企业应用系统项目中，在进行系统架构设计时，考虑了哪些非功能性需求，如何通过架构设计满足了系统的这些非功能性需求。 2014论软件的可靠性设计（P377） 现代军事和商用系统中，随着系统中软件成分的不断增加，系统对软件的依赖性越来越强。软件可靠性已成为软件设计过程中不可或缺的重要组成部分。实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制，由此提出了可靠性设计的概念。可靠性设计就是在常规的软件设计中，应用各种方法和技术，使程序设计在兼顾用户的功能和性能需求的同时，全面满足软件的可靠性要求。 问题：请以“软件的可靠性设计”为题，依次从以下三个方面进行论述。 1．概要叙述你参与管理和开发的软件项目以及你在其中所担任的主要工作。 2．简要说明目前比较主流的软件可靠性设计技术，结合项目实际情况，阐述所选择的可靠性设计技术及其原因。 3．结合你具体参与管理和开发的实际项目，举例说明所选取的软件可靠性技术的具体实施过程，并详细分析实施效果。 2014论网络安全体系设计 随着社会信息化的普及，计算机网络已经在各行各业得到了广泛的应用。目前，绝大多数业务处理几乎完全依赖计算机和网络执行，各种重要数据如政府文件、工资档案、财务账目和人事档案等均依赖计算机和网络进行存储与传输。另一方面，针对计算机和网络的攻击活动日益猖獗，网络安全已经成为当前社会的主要安全问题之一。 在上述背景下，国家标准《信息处理系统工程开放系统互联基本参考模型——第二部分：安全体系结构》（GB/T 9387.2-1995）定义了基于OSI参考模型7层协议之上的信息安全体系，其核心内容是：为了保证异构计算机进程与进程之间远距离交换信息的安全，定义了认证服务、访问控制服务、数据机密性服务、数据完整性服务和抗抵赖性服务等5大类安全服务，以及提供这些服务的8类安全机制及相应的OSI安全管理，并根据具体系统适当配置于OSI模型的7层协议之中。 问题：请以“网络安全体系设计”为题，依次从以下三个方面进行论述。 1．概要叙述你参与管理和开发的软件项目以及你在其中承担的主要工作，并详细阐述该软件系统在网络安全方面的要求。 2．请对GB/T 9387.2-1995中定义的5大类安全服务进行描述，阐述每类安全服务的定义和主要实现手段。 3．请结合项目实际，具体阐述你在项目中实现了上述5大类安全服务中的哪些服务，具体运用了哪些实现手段。 2013论软件架构建模技术与应用（P181 - 图P103） 软件架构用来处理软件高层次结构的设计和实施，它以精心选择的形式将若干结构元素进行装配，从而满足系统的主要功能和性能需求。软件架构设计的首要问题是如何表示软件架构，即如何对软件架构建模。根据建模的侧重点不同，可以将软件架构模型分为 ~结构模型、框架模型、动态模型、过程模型和功能模型~ 。Kruchten在1995年提出了“4+1”视图模型，将5种模型有机地统一在了一起。 问题： 1．概要叙述你参与管理和开发的软件项目以及你在其中所承担的主要工作。 2．简要叙述“4+1”视图模型的主要内容。结合你参与项目的实际情况，详细说明该项目需求及所涉及的软件架构（包括使用到的视图模型、创建的架构模型及使用的建模工具等）。 3．说明该项目软件架构的实施效果，分析其是否满足了项目的需求并说明原因。 2013论软件可靠性设计技术的应用（P377） 随着软件的日益普及，系统中软件成分不断增加，使得系统对软件的依赖越来越强。 软件的可靠性对系统可靠性的影响越来越大。而实践证明，保障软件可靠性最有效、最经济、最重要的手段是在软件设计阶段采取措施进行可靠性控制，为此提出了软件可靠性设计的概念。 软件可靠性设计就是在常规的软件设计中，应用各种方法和技术，使软件设计在兼顾用户功能和性能需求的同时，全面满足软件的可靠性要求。软件可靠性设计应和软件的常规设计紧密结合，贯穿于软件设计过程的始终。 问题： 1．概要叙述你参与管理和开发的软件项目以及你在其中所承担的主要工作。 2．结合项目实际，论述你在项目开发过程中，进行软件可靠性设计时遵循的基本原则；论述你在该项目中所采用的具体可靠性设计技术。 3．阐述你在具体的可靠性设计工作中，为了分析影响软件可靠性的主要因素，所采用的可靠性分析方法。 2012论基于架构的软件设计方法及应用（P131） 本题考查的知识点是ABSD。 ABSD （architecture-based software design,基于体系结构的软件设计）方法。ABSD方法是体系结构驱动，即指构成体系结构的商业、质量和功能需求的组合驱动的。使用ABSD方法，设计活动可以从项目总体功能框架明确就开始，这意味着需求抽取和分析还没有完成（甚至远远没有完成），就开始了软件设计。设计活动的开始并不意味着需求抽取和分析活动就可以终止，而是应该与设计活动并行。特别是在不可能预先决定所有需求时，例如产品线系统或长期运行的系统，快速开始设计是至关重要的。 这种方法的主要阶段包括： 2012论企业应用系统的数据持久层架构设计 本题考查数据持久层架构设计。 数据持久层位于领域层和基础架构层之间。由于对象实例和关系实例这两大领域之间存在“阻抗不匹配”,所以把数据持久层单独作为一个层提出来的原因就是能够在对象-关系数据库之间提供一个成功的企业级映射解决方案，尽最大可能弥补这两种实例之间的差异。 本题要求分析持久层架构设计中有哪些数据访问模式，数据访问模式包括：在线访问、Data Access Object、Data Transfer Object、离线数据模式、对象/关系映射（O/R Mapping:Object/Relation Mapping）。此处需要详细描述这些模式的主要内容。 2012论决策支持系统的开发与应用 本题考查决策支持系统的开发。 决策支持系统（Decision Support System,DSS）是辅助决策者通过数据、模型和知识，以人机交互方式进行半结构化或非结构化决策的计算机应用系统。它是MIS向更高一级发展而产生的先进信息系统。它为决策者提供分析问题、建立模型、模拟决策过程和方案的环境，调用各种信息资源和分析工具，帮助决策者提高决策水平和质量。 要完成本题的写作，需要充分了解决策支持系统的概念，这种系统有何用途，以分析，为什么要建立决策分析系统。并需要了解决策支持系统的建设与一般MIS系统有何区别，这样才能找出题目中要求的“在建立决策支持系统时需要解决的一般关键问题”.些处的关键问题，可以因不同项目而异，所以说明需要解决的关键问题时，还需给出合理的分析，为什么这是个关键问题。 2012论企业信息化规划的实施与应用 本题的考查方向是企业信息化规划。 企业信息化规划是企业信息化建设的纲领和向导，是信息系统设计和实施的前提和依据，意义重大。文章中应首先描述企业战略与企业信息化规划之间的关系，并实质性的指出目前企业的战略，由此而来的信息化规划要求。 在进行信息化规划过程中，需要注意方法的应用，方法包括但不限于：企业系统规划方法（BSP）、战略数据规划方法、信息工程方法。选择其中的一种，说明，为什么采用这种方法，作者是如何采用这种方法来做规划的，步骤效果如何。 最后题目要求总结经验，分析效果，以及分析原因，这里其实是暗示大家，信息化规划不可能做到尽善尽美，总会有问题存在。所以此时不要“报喜不报忧”,这样会显得很假，需要指出一些实质性的问题，再给出解决方案，这样会显得更加的真实。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-07 09:35:40 "},"markdown/feelings/":{"url":"markdown/feelings/","title":"心路历程","keywords":"","body":"心路历程心路历程 半杯水 一位ACMer过来人的心得 你难道没收到我的邮件？ 找BUG记 请还我安静的4小时 别让你的能力成为绊脚石 我们需要的，是测试而非重构 月缺，梦圆。 请发展你的惰性 优雅的烂代码 程序员的\"病态\" 工作需要经营 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:27:19 "},"markdown/feelings/半杯水.html":{"url":"markdown/feelings/半杯水.html","title":"半杯水","keywords":"","body":"半杯水这应该算是引子分节目录苦逼程序猿，劳模运维狮你需要K.I.S.S掌控你的资源能力与方法囚徒困境人的核心竞争力书写是为了更好地思考半杯水 [info] 读 《暗时间》 有感 这应该算是引子 半杯水 —— 思如杯，技如水，技盈则满，思盈则空。虚而不满，似无物，可容万物。 有一个辩题为「能力和思维哪个更重要」。我不选边站，「学而不思则惘，思而不学则怠」，物极必反是亘古之理。只是现在社会的竞争过大，很多人为了眼下的生活，都过份追求自身能力的发展，而忽略了不时反思自身的那份态度。 我之前问过一个海纳百川的朋友：「你什么新技能都去试，也不想想学得多而不精有什么用？」 于是他告诉我，这样才能在短时间内让上司知道自己有什么变化，而且新东西可以显得自己与众不同。 我想说，其实如果你可以坚持每天不穿衣服去上班，也是可以起到同样效果的…… 同理，我也不认为一味思考人生就会变得很好，当然如果你想成为下一个「深井冰」，那就另当别论了。 其实辩题不应该是哪个更重要，因为都重要。关键是如何在两者之间寻求平衡，保持半杯水的「状态」 —— 但我更倾向于认为这是种互补的「心态」：不过分依赖能力、也不过分依赖思考，不过分依赖自己、也不过分依赖他人，为身边的一切寻求互补，不卑不亢，聪明地做事。 分节目录 - - ● 苦逼程序猿，劳模运维狮 —— 工作怪圈 ● 你需要K.I.S.S —— 跳出怪圈（程序猿篇） ● 掌控你的资源 —— 跳出怪圈（运维狮篇） ● 能力与方法 —— 正确地使用你的能力 ● 囚徒困境 —— 别宅了，抱团吧 ● 人的核心竞争力 —— 技能不是万能 ● 书写是为了更好地思考 —— 你的思维需要降速 苦逼程序猿，劳模运维狮 对程序猿而言，「重构」永远是最大的课题。 程序猿最困扰的，莫过于总要面对一堆乱七八糟的历史代码 —— 历史代码其本身可能并不混乱，只是经手的人多了，面目全非罢了。从心理上看，一份代码越混乱，对于维护结果抱着「无所谓」的心态越明显。但不负责任的恶性维护，尽头只能是重构，而即使重构了，却也只是新循环的开始。 而对于运维狮，「自动」应是他们最终所追求的幻想。 运维狮的工作核心基本无一例外的就是要面对大量的机器、大量的程序副本、不知何时会崩坏的线程，还要时常排查天文数字一样的监控数据，到头来却不知道自己究竟在维护什么。 即使渴望可以自动化完成这一切，但「羊群效应」却使得大多数运维狮无意识地从众，因为有安全感的，尤其所面对的东西是未知的时候 —— 既然已经有那么多非自动化部署的程序 …… 于是又手动拷贝了一份程序副本。 我们总是在嘲笑历史上的别人留下一堆麻烦，历史却总是惊人的相似 —— 因为我们在抱怨别人的烂摊子的同时，一边给别人制造烂摊子却不自知。若始终不肯抛弃「自我感觉良好」的心态，所有人都只能苦逼地活在别人制造的圈子里，然后成为别人嘲笑的劳模。这个循环是时候结束了。 你需要K.I.S.S 首先要声明的是，不要理会别人的维护质量有多烂，从自身做起，保持良好的心态，负责任地维护每一份代码才是一个程序猿应有的职业素质。 但是总有一些代码经过历史不断的修补而变得过于复杂，复杂到我们宁愿放弃80%的功能（这并不是确切的划分，只是我深受二八定律影响罢了）去重构一份简洁的代码 —— 当然如果还有保有我们所需要的那些功能就更好了。 良好的开端比什么都重要。程序猿觉得代码维护困难，根本原因在于程序设计阶段没有做好。所以无论如何，只要你一下定决心要重构，请务必由始至终把K.I.S.S原则铭记在心。K.I.S.S，即「Keep it simple,stupid!」，直译过来就是「保持简单，傻瓜」。确实，把程序复杂化无助于性能和资源的管控，也使得后续的使用和维护更加困难。 有一条程序猿悖论如是说：「程序猿的工作效率并不会随着资历的增加而有显著提高」。究其原因，年轻的程序猿会耗费大量的工作时间去敲写几万行代码以体现能力；而老程序猿更倾向于在深入思考后再写出几百行代码以体现质量，即使偶尔花了大量时间在写代码上，一般也只是为了这几百行代码找到最优的组合而已。 这是因为所有老程序猿都明白，华而不实的工作能力，只会使我们的工作变得更加困难。只有简单才是美，为了简单我们不惜付出任何代价。 掌控你的资源 相对于程序猿，运维狮没有推翻一切重来的「重构」手段，因此需要的更多是务实的精神，但务实不等同于蛮干，技巧也很重要。一个合格的运维狮应该思考的不是「能做多少」，而是「如何做得最少」。 如果你觉得维护工作开始变得困难，或者已经很困难，就需要审视自己是否有正确利用身边的资源以提高自身的工作效率和质量。不要奢望「自家的」程序猿什么时候能提供自动化的程序使你的工作变得轻松，关注第三方的运维工具并利用起来才是王道，毕竟现在的社会，什么东西都是「别人家的」更好啊。 有一条成功的箴言如是说：「要看一个人是否成功，看他晚上8点之后在干什么」。其实也是很浅显的道理，白天谋生、晚上谋事。作为运维狮，虽然少有晚上时间，但闲下来的时候必须学会充实自己。如果你还在迷茫应该学习什么，或者我能够为你指两个方向： 掌握shell/sed/awk三剑客编程：学会编写定制化的脚本 掌握自动化部署工具ansible：用程序生成程序、而不是手工复制 特别一提的是，不少运维狮容易受工作内容所限，生疏于编程语言、甚至不懂编程语言。其实不妨走出自己的圈子，学习一些编程语言，打通前后端，更有利于自身的工作。在维护出现问题的程序的时候，「知道用什么方法解决」和「知道为什么可以这样解决」是两种截然不同的境界。 这里说一个题外话，我在协助现场维护工作的时候，发现运维狮和用户之间总有争取硬件资源的矛盾。所谓「宁花机器一分，不费程序员一秒」，程序量提高了，用户却迟迟不肯放宽硬件资源，很多时候可能是没有看到有力的「证据」。如果能够做到常态化监控，并把性能数据持续集成健康的报表，对用户透明化，或许争取资源会更容易，这也是一种做事手段。 能力与方法 [info] 「如果你手里有一把锤子，所有东西看上去都像钉子」。 —— 这不是我说的。 往往我们可能花费了大量时间去学习一项技能，而学无所用是所有人最不愿意发生的事情。于是我们就会尝试在各个方面炫耀这项新技能，而不管它是否适用。 在我学习设计模式之初，就陷入了这种状态，几乎不能自拔。确实，设计模式为我打开了一扇大门，我首次知道原来代码也可以写得如此优美，使得我迫不及待地寻找可以应用它们的项目，哪怕只有一点可以用得上。但牵强附会总是没有好结果的。 再如我现在所参与的技术框架开发，虽然一些工具组件已经被成功推广起来了，但一些工具组件却依然不为人所知。不是说这些组件没有技术性，究其原因也是适用性问题。所谓的工具是为了提高开发效率才被制造出来的，而很多同事就投诉说，为了使用一个工具必须注意这注意那，还要配置一堆有的没的东西，甚至还可能与业务逻辑不兼容，如此复杂还不如自己实现。于是他们真的选择了抛弃这些工具。 所以其实正确的做事态度应该是：「如果你想钉一个钉子，所有东西看上去都像是锤子」。 即我们在处理问题时，优先考虑的是要做什么What，而不是怎么做How。只有先明确目的，才去选择合适的工具，而不是拿着一把工具对所有事情都勉而为之。正确而有效率地做事，谨记以下几点，受用无穷： 方向比努力更重要：莫要南辕北辙 流程比修补更重要：无规矩不成方圆 方法比拼命更重要：事半功倍 囚徒困境 在信息时代，「大鱼吃小鱼」已成为过去，如今是「快鱼吃慢鱼」。但如何能够「快」？在软件开发中，如果单凭一个人在闭关修炼技术，无论学习能力多么像海绵，也不可能短时间内海纳百川，又如何能快得起来？其实这也恰好说明你开始需要一个团队了 —— 为了综合实力，取长补短。 软件开发的本质就是一项团队运动，人与人的因素对结果的影响完全不亚于技术因素。一个项目成功的关键不仅仅是写出漂亮的代码，团队中的所有人朝着同一个目标一起合作也是同样重要的。但团队工作经常遇到的问题，就是沟通问题，我遇到的主要有两种情况：不愿意沟通，或无法正确表达自己想法。 举一个博弈中的著名栗子，「囚徒困境」。大概是描述这样的一个问题：两个疑犯被隔离审讯，由于证据不足，若两个都抵赖则均判1年，两个都坦白则均判8年，一个坦白一个抵赖则坦白的释放、抵赖判10年。 从整体利益上考量，最优的方案是两者均抵赖。但由于两个疑犯不知对方所想，在对方可能会抵赖的怀疑下，局限于自身利益进行判断，都会选择坦白，以保证自身利益最大化。 囚徒困境也是在团队工作中，缺乏沟通或沟通不当的必然结果。所谓的团队任务，就是要每个人承担一块工作，分别完成后再整合。如果都只从自身角度做考量而不顾他人，即使自己工作得非常出色，但最终却无法与他人的工作完成整合，那么也只是在做无用功。 只有通过不断的沟通、磨合，才可能保证整体的利益最大化，一盘散沙，终难成事。所谓「要学做事，先学做人」，时刻谨记我们都只是半杯水：内修本领、追求极致，固然重要；外联朋志、寻求互补，方是王道 —— 抱团取暖 = 力量大。 人的核心竞争力 前面讲述的都是一些现实性的东西，那些确实都是我们用来竞争的实质性资本。但毕竟随着工作的更替，很多东西也就过时了。而不过时的只有思考的方式，或者说只有思考才真正是我们作为人的不可替代的核心竞争力。 下面这些是我平时或蒐集、或所悟的「箴言」，既然是分享，我就不要脸地「借鉴」过来了。有时这些看似与技能毫无关系的东西，可能恰好就在某个转折点决定了人生，所以都参考着看一下吧： 万事先修德，养性必制怒。 广交朋友并为他们做事情。 多参与社区活动，积极分享，锻炼口才。 锻炼身体，笑到最后得有一副好身体。 反思是让人得以改进自己的最重要的思维品质。 「教」是最好的「学」。 我们都是半杯水，正是这样人生才有意义，不卑不亢，寻找互补。 人生就是一场修行，人必自助而天助之。 读书，尤其是读那些非实用性的书（如心理学等）。 潜心一到两项业余爱好，参与一些艺术活动。 不断寻找偷懒的方法，聪明地工作。 越努力，越幸运。 与智者交谈，思考，并常做笔记。 犯错趁早，防微杜渐。 因上努力，果上求缘。 书写是为了更好地思考 最后，这是一个我自身的一个小故事。 —— 一个我成为「作家（虚伪的）」之前的故事。 以前我们读书的时候，每天的工作就是写。而现在工作了，扪心自问，又还有谁拿起过笔？恐怕都差不多执笔忘字了吧。 那为什么我们需要书写？ 众所周知，物理上速度的极限是光速。但撇开物理不谈，比光速更快的，则是人的思维 —— 因为光从地球到火星都需要400秒，而人想一下就到了。 这不是脑筋急转弯，大部分人应该有过这样的经历：在思考一个问题很久却不得果时，都会试着问一下别人的想法。但当我们把问题描述一次给对方的时候，对方还没做出回答，我们就突然「想通」了。 这是因为，我们在思考问题的时候，往往已经想明白了各个细节要如何解决，但由于思维速度过快、跳跃性太大，在想细节A的时候、忘记了细节B，想B的时候又忘记了A，从而引起「想不透」或「总觉得哪里不对」的假象。 而通过文字将问题重新描述一次，实际上就是一个将思考「降速」并「梳理」的过程。因此如果一直想不透一个问题，不妨用笔将其写下来，往往问题就迎刃而解了。有时可能还会因此有意外的收获。 以上。 所以.... 所以我好像丝毫没有提到那个故事，这是因为我知道你们不会想看的。 但其实你已经猜到那个故事了 —— 所以大家都积极地写一点东西去记录自己的点点滴滴吧！ 或许一开始你可能会纠结怎样可以写出令人眼前一亮的东西，但当你意识到这可以让你更好地思考的时候，你就会摒弃这种纠结。当你慢慢习惯怎样用文字去描述你的想法时，所谓「思如泉涌」也不过如是罢了。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:41:20 "},"markdown/feelings/一位ACMer过来人的心得.html":{"url":"markdown/feelings/一位ACMer过来人的心得.html","title":"一位ACMer过来人的心得","keywords":"","body":"【转】一位ACMer过来人的心得算法学习是ACM比赛所要推广或者要提倡的一个方面用模板是不好的需要深入学习独立思考做有意义的题估算好某种训练所需要的时间有关训练的度【转】一位ACMer过来人的心得 刻苦的训练我打算最后稍微提一下。主要说后者：什么是有效地训练？ 我想说下我的理解。 很多ACMer入门的时候，都被告知：要多做题，做个500多道就变牛了。其实，这既不是充分条件、也不会是必要条件。 我觉得一般情况下，对于我们普通学校的大学生，各方面能力的差距不会太大，在这种情况下，训练和学习的方法尤为重要。 其实，500题仅仅是一个标志，而且仅仅表示你做 ACM-ICPC 有一定的时间。 我们训练的目的是什么？我觉得有四点： 提高编程能力 学习算法（读书，读论文，包括做一些题目验证） 准备好面临将到来的挑战（熟悉题型，调整心态） 启发思维 这里四个目的，从训练的角度上，重要性逐次递减；为什么呢？ 因为前面的因素是后面的基础。而是后面的目的，想达成越为不易。我觉得前3者能保证你ac掉你能做的题，即使难题始终不会做，也可以ac掉中等偏难的题目。 而需要一定思维难度的题，要以前三者为基础而且属于训练的后期，中期只能作为偶尔调节。当然，我思维也烂得要死，对这点没什么发言权，大家可以鄙视我。 我这里想主要说下第2点。 对于算法，我发现，很多我们这样的弱校ACMer选手没有侧重好算法的学习。 下面要讲的几点，可能都很老套，但我想以035对比我自己的例子给大家做说明。 算法学习是ACM比赛所要推广或者要提倡的一个方面 记得曾经路过某人的blog，上面说他作比赛的时候遇到了一个dijkstra，他没做出来，然后评论到（大意）：我才不会花时间去搞明白“这种”算法。 “这种”也许有可能是指：没什么实用性，对吧，这样我就不想评论了（又是有关科学和工程的讨论）。但起码有一点需要明确的：ACM-ICPC比赛时关于计算机科学的比赛，计算机科学是算法的科学，计算机算法中dijkstra有着重要的实际和启发意义，所以比赛一定要考。 你参加这个比赛，要拿奖，就必须学习这种算法。你也许觉得你智商很高，但ACM-ICPC比赛本身不是智力比赛，比赛就是要让你去学习这些东西，所以，如果你不想学的话，我觉得也没有必要参加。说道这，可能偏题有点远，但是希望以上的分析能得出这样一个基础结论：不想学好算法，那没有必要来比赛。 用模板是不好的 现在很多我们弱校的ACM-ICPC选手比较依赖模板，说实话，我也很依赖，但是我起码知道一点，这样是不对的，某种意义上说，这是你没有把算法学明白的一种表现。而且也严重影响编码速度。在我见过的huicpc035参加过的比赛中，他从来没有看过模板，全部现场敲，有一次比赛有个图强连通分量+缩点+染色+什么的题去了，我在他们机房做，我则抄模板，结果总共敲了1个半小时，而035明确算法之后，啪啦啪啦，估计30多分钟就敲完了。这里顺便八卦一下他：我和kevin以前去湖大集训队玩的时候，给他取了个外号——打字猛男（他应该还不知道）。因为他敲键盘的声音特别大特别快，呵呵。 我觉得他敲代码的时间没有浪费，某牛曾说：因为每次敲都有可能有不同的错误，所以不用模板是好习惯。我最开始学dancing link的的时候，自己敲出了代码，然后接下来的几道题部分参考了以前的代码，后来基本上是直接copy。现在，当别人问我dancing link算法或有关的题目的时候，我已经是一脸茫然。 所以，用模板是不好的，有时候由于某些原因可能你用了模板，但你起码要知道这要做是不对的，并且有机会要改正。 需要深入学习 像 ACRush、zzy、ahyangyi...等等国家队的天才们，本身难以说我们与他们之间有什么可比性。但是他们的学习方法应该还是值得借鉴的，他们的学习方法当然我们得不到言传身教，但是从他们在国家队集训的论文中和他们搞完ACM-ICPC以后的轨迹中，可以有所体现。那就是：深入学习。 其实这点我来讲可能还是不够有力，因为我这方面也很欠缺，我尽量说下我的想法。 首先，觉得ACMer学算法不应停留在看看代码实现这个层面，在算法思想上要有清醒的认识，在正确性分析上要也应该要有较好的逻辑。因为网上的代码的实现上的一些细枝末节很可能掩盖了算法本身有的简洁性、美感和思想。因而丧失了对算法整体上的一些认识。还拿dijkstra算法打比方，有些算法不是基于 dijskstra的直接建模，而是需要你修改这个算法，这时你对算法没有真正理解的话，也就一筹莫展了。 我为什么老说Dijkstra算法，因为确实很多人都只知道用模板，而且模板还不好，在我看到的Dijkstra实现中，只有czyuan_acm的代码写得好。不是说其他的不对，但确实是有问题，投机取巧了的。 所以，要阅读论文和书籍，尤其与英文书籍，窥到它的本质。另一方面，只有这样，你学的的东西才能在ACM-ICPC以外，给你一定的启发——否则你会迅速忘掉它的。 据我所知，035起码阅读了几十篇集训队论文，orzorzorz，而且切掉了例题。 独立思考 这点我也很惭愧，因为我也是缺乏独立思考的。很多题我不会了就去搜解题报告，所以反而我的搜资料能力变得特别强。035和许多大牛在这点上做的比我好多了，他们遇到题不会的时候，也不会很急于把题目做出来，可能每隔一段时间又拿出来想一次，总有一天想通了，之后这一类型的题目基本上也就没有什么问题了。 而我恰恰比较“虚荣”，做到的题目不会不太愿意想太久，就想尽量快些AC，于是急于看解题报告，这样导致的一个问题就是有些重要的东西解题报告中没有提到，而我也没去想就把他们忽略了，这样，我还是不会做。我和035讨论问题的时候，我不会一般就直接找他要代码，但是他不懂的时候，顶多问我大体的思路，而绝对不会要代码的。 在去年ACM赛区尾声的时候，我发现035做中难题的能力已经明显超过我一个档次。看他现在做的题目，已然是相当变态，几乎是都100以下人ac，这些题目我看了基本上没什么想法，更要命的时，解题报告也搜不到。035目前的状态让我想起一个人，不知道大家知道不：wangfangbob，他切bt题的能力也是令人汗颜的。 做有意义的题 不要做水题，这里的水题定义为：一眼就能看出做法，而且中途的实现可以预计没有太多问题的题目。 做能够强化你最近学到的东西的题目 你不会但你应该会的题目 这同时也是在说，某些没太多代表性的题目可以少做，因为对比赛帮助不大。（当然我这个参加比赛的目的很功利，非功利主义者另当别论）刚才，我把我在poj上的号和他的号对比了下，他ac而我没ac的基本上是难题，我ac他没ac的一般是水题，看得我想哭，5555。 补充一点：ac的人多的并不一定代表着水题，有些几千人ac的题目，在现场赛中ac的人很少，这样的题目往往是有一定思维难度且编码不难的好题，这种题目要认真做，某个学长说：经典的题目啊，只有那么多，做一道，就少一道。 估算好某种训练所需要的时间 我觉得我学网络流就是一个例子，我在大概赛区赛之前2个月开始学习网络流，1个月前开始学习费用流，但是对于我来讲，这两个月培养出来的网络流思维还是不够（虽然也做了不少题），特别是，这种题目往往作为中难的题目出现，不会让你随便水的，于是，北京赛区的那道网络流当时就没有想出来——功利地说，学习网络流没有得到好的效果。 所以，现在来看，当时其实我可以不搞网络流。如果要学一种比较有难度的东西，并且还必须把他搞好，应该较早地，全面地学习，必须长期的训练以培养这种思维。打个比方，如果你微积分平时不学，仅仅考试前一周狂做题目，我觉得上90分是很困难的。 当然，这要根据个人情况而定，我的理解能力应该说是中等水平，如果牛的话应该可以更快地学好。 有关训练的度 我有时候通宵刷体，这里我不知道huicpc035有没有这个习惯，不过我通宵的时候没见到他通宵。 我觉得其实通宵刷体，或者太长时间地做题，还是不好的。我们为什么会这样有热情的做题呢，因为我们有兴趣；但是一个人的成功不仅仅依赖于兴趣，还要依赖于自控。这和打游戏是一个道理，游戏太有趣以至于我们常常通宵——ICPC题目也太有趣，所以有时候通宵。而且很多时候是，由于一道题AC不掉，所以赌气一定要搞定才睡觉，这样一不小心，就通宵了。 其实我明白，通宵不一定效果好，这仅仅说明了你兴趣很高涨而已。通宵往往会打乱你的时间安排，打乱你的生物钟，进而影响你短期或是中期的训练计划。而且，疲惫的状态下做题，你往往只有ac题目的欲望，而完全丧失了ac题目的灵气。所以，我建议，ACMer一定要合理安排作息，能够自控，这样不仅仅对你做 ACM-ICPC有好处。 总之，有效训练是很重要，只有通过有效的训练你才能获得你参加这个比赛应得的东西。 还有就是，除了035以外，另一个值得大家学习的就是richardxx——我也很佩服，我并不觉得他是天才，我觉得他以全方位的努力让他自己变得优秀，大家看他的blog可以看到他的学习历程。 最后要说下刻苦训练这一点，这个我主要想说给我们学校的acm队员： 客观的说，我们学校很多名校落榜生（我相比而言是水进的）。确实都蛮聪明的，但再聪明也比不上ACRush吧？人家可是SGU都切满了！ACM不是智力测试，不是你什么都不做就可以天上掉馅饼的。当然我不是说题目一定要做多少多少道，但如果你觉得你可以一心二用，从概率上来讲，你百分之九十地错了，我是个工科生，我相信概率而非奇迹。 我觉得035这方面也是值得我们学习的，我比较喜欢扯淡，有时候聊题目的时候也经常不小心就去扯其他话题去了，在学习的时候，035是坚决不多聊乱七八糟的东西的，除了讨论上QQ，平时据我观察都是残酷地训练。现在回想起来，我有点后悔，QQ上和网上花掉的时间用来学习新的东西，也许结果会更好。 ACM-ICPC绝不是大学生活的全部，也不是搞算法的全部，你大可以花时间去做其他研究，做项目，或者参加学生工作(我更欣赏那些对人生和职业有良好规划的ACMer)；但是，如果你搞ICPC的那段时间你不是全部投入，那的在ACM-ICPC生涯中，将只有后悔。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:26:20 "},"markdown/feelings/你难道没收到我的邮件.html":{"url":"markdown/feelings/你难道没收到我的邮件.html","title":"你难道没收到我的邮件？","keywords":"","body":"你难道没收到我的邮件？你难道没收到我的邮件？ —— By EXP 2014-04-23 细数公司十大经典金句之首，当孰【你难道没收到我的邮件？】无疑（了吧~ 我发誓我木有统计过）——尤其是邮件作为我们公司主要的沟通手段之一，我对这句话可谓印象深刻了。 回想刚到公司的时候，我还不会打座机电话（我承认我真的去学了打电话...），当时跟工程同事唯一的沟通手段就是邮件，有时甚至把邮件当QQ用了。但毕竟邮件不是QQ，时效性略差。有时候一些问题得不到确认，于是事后问对方最多的就是你有没有收到我的邮件了。 通常情况下，我们大部分人都有一个认知误区：只要把邮件发给对方了，对方就一定会知晓并执行，于是自己的沟通任务就完成了。但事实是，对方很可能没有（及时）收到邮件，即使收到了邮件，也不代表能够理解、接受、甚至执行。 沟通并不仅仅是发送邮件那么简单——发送邮件不过是沟通手段的一种，切莫把沟通手段和沟通过程混淆了。 真正意义上的沟通，是指思想碰撞并传递的过程。只有我和你能够以相同的角度去看待某个问题、理解其细节，才能说我和你完成了沟通。否则即使你清楚明白地看到了（听到了）我的每字每句，但是你不理解我的意思，那我和你也没有做任何有实际意义的沟通。 邮件上的沟通，按我们通常的说法，充其量只是“存证式的沟通”。确实它可以作为沟通证据，但过于依赖邮件则可能造成沟通障碍——尤其是当邮件包含的信息量越大，其中的细节就越容易被忽略。 况且信息淹没只是沟通障碍的一种。文化背景、个人偏见等主观因素也会成为沟通障碍的帮凶。为了减少类似不必要的障碍，我现在工作的时候，更倾向于面对面的、或电话式的交流，同时我也会定期写一些文章，借此向身边的人表述我近期的观点或见闻——我觉得消除障碍最好的方法就是让别人可以更直接地了解自己。 我越来越觉得，当一个问题被过于依赖用邮件去处理时候，处理周期越长，它就像抛绣球似得被抛来抛去。多用面对面或电话式的沟通，则可以促使我们在当下通过讨论去解决、反思问题。而写文章则可以避免直面的尴尬，在特定的时期向其他人表述自己的观点。 实际上，我一直以来都有写文章的习惯，而且我有自己的Blog。但自从去年开始公司办了内刊，我就把本应发表去Blog的一部分文章改投放到公司内刊了。原因有二：一是可以令身边的人更了解我的想法，增强他人对自己的熟悉感会利于平时沟通；二是我更喜欢公司有个人可以帮我对文章把关，使我的文笔有所提升——我并不介意文章被挑剔，因为我始终相信：“谁越是对你的文笔斤斤计较，谁就越可能是决定你前途的人”。 但沟通不仅仅相互理解、消除障碍就足够了。沟通也是需要策略的，首要一条就是让对方可以听懂并接受的方式去表述，否则只会徒增对方的失落感、甚至乎反感。其次就是用可以吸引对方注意力的方式去表述——我相信相比起一本新书，遍布重点的参考书更有吸引力，尤其在考试前。 最后我需要声明的是，写下这篇文章，并不是说邮件沟通有什么不好。恰恰相反，邮件作为“存证式”的沟通手段，是其他沟通方式不能替代的。而之所以用邮件说明问题，不过是作为这篇劣文一个引子，我真正所倡导的，是灵活、有效的沟通过程——这才是我们需要的——我们大可以在完成沟通后，再用邮件来存证一下不是么？ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 13:30:48 "},"markdown/feelings/找BUG记.html":{"url":"markdown/feelings/找BUG记.html","title":"找BUG记","keywords":"","body":"找BUG记令人头痛的陈年老BUG（序章）因注释而蔓延最危险的组合令人头痛的陈年老BUG（终章）找BUG记 —— By EXP 2014-03-22 令人头痛的陈年老BUG（序章） 前几天，码农朋友甲（下文简称“甲”）拿着我5年前发表在某博文的代码问我：“这段代码是有bug吧？”下面就是他给我指出来的一段C++代码，大家可以先尝试能不能找到甲看到的bug： void solve::Initial(void) { TimeStamp = 0; // 时间戳 DFN = new int[N+1]; // 搜索次序 Low = new int[N+1]; // 能够回溯的最早次序号 setIntArrayVal(DFN, 0, N+1); setIntArrayVal(Low, 0, N+1); SCC_id = 0; SCC = new int[N+1]; // 辅助栈 Status = new int[N+1]; // 辅助栈状态 setIntArrayVal(Status, 0, N+1); sp = new Shrink_point[N+1]; // 缩点（极大强连通分量） return; } void solve::setIntArrayVal(int* array, int val, int len) { memset(array, val, sizeof(int)*len); return; } 诚然，突然要我查一段几年前写下的代码是否有bug，我内心是比较抗拒的——尤其是我自己写的代码（我对自己还是有相当自信的）——毕竟人的弱点就是不善于揭发自己的短处。不过这都只是次要的心理因素。 归根结底，所谓打铁趁热，bug也是越早发现越好，新代码的bug总是要比历史代码的bug更容易处理。而面对这个陈年老bug，我已经完全忘记了我在5年前写这段代码的思绪，所以要我马上就应付甲的质疑是不可能的。与其再花费一番周折琢磨我自己的代码，我干脆直接就举手投问：“所有测试用例运行可以通过，是哪里有bug呢？” 因注释而蔓延 甲告诉我，是memset函数使用错误：在C++中，函数memset的作用是对一段连续的内存块赋值，即赋值的单位是字节，换而言之memset只能用于字节数组，但int数组不是字节数组。 void solve::setIntArrayVal(int* array, int val, int len) { memset(array, val, sizeof(int)*len); return; } 老实说，我很高兴甲会如此仔细的看我5年前的代码。而且毫无疑问，他的观点是正确的。但是也不见得我就是错的。因为早在那时我就已经知道memset函数的局限所在，但我坚持要用这个函数做数组的初始化，是因为我看中了它的效率—— 相对于逐个赋值的方法初始化数组元素、memset的效率要高得多，因为从寻址次数来看，前者的时间复杂度是O(n)、后者是O(1)，更何况当时所解决问题的n是上千万级别的。虽然我把memset用在非字节数组，只要我保证初始化的值只为0就不会有任何问题。事实上也是如此。 于是我自信满满地告诉甲，单纯断章取义地看我这个方法，确实是一个bug。但如果整体地去看我的代码就恰恰相反，我只是利用了bug，并得到了更高效的处理。 但是甲之后的一席话确实值得我深思： “或许对目前的这份代码而言，这个bug是被你巧妙地利用了，但是我觉得真正的bug或许不是你的代码，而是你没有文字注释去说明你的想法。不要忘记你已经共享了你的代码，当更多人看到这段程序时，如果他们不了解menset的原理就照样搬用，那么你就无异于在别人的代码中散播了bug，因为你不能把他们代码中的val限制为0。” 最危险的组合 不得不承认，甲是对的。即使我有足够的自信在5年后仍然记得利用这个bug的前因后果，但在这5年间早已误了不少别人的子弟...... 不过话说回来，先不论这个bug的蔓延性，甲能够如此深入琢磨我的历史遗留物、并发现这个bug实属难得——在软件中有一种bug是最难被发现的：组合式的bug。组合式的bug有两种类型：相辅相成型、相互弥补型——甲在我代码中发现的bug就属于后者。 相辅相成型：举例而言，一个bug是楼梯很滑，另一个bug扶手坏了，但除非这两个bug同时存在，否则只有其中一个bug是不足以让人摔下楼梯的。 相互弥补型：它与相辅相成型刚好相反，只有两个bug同时存在（或不存在）程序才会正常运行。若只修正了其中一个bug，另一个bug就会曝露出来，而且会让人有误以为自己改错了的假象，因为修改之前程序是可以正常运行的。 之所以说它难以发现，因为组合bug几乎无迹可寻，尤其是相互弥补型。除非是编译原理的狂热爱好者、抑或出现了非常极端的运行环境。存在组合bug的程序，其通常状态无异于正常程序，而且可能正常运行了很长时间都没有曝露出来。 回到我的代码，它已经正常运行5年了。如果甲没有向我质问他心中的疑惑，而是擅自修改了他所发现的bug，那么我的程序就无法正常运行了——而甲就很可能会因此陷入怀疑自己的正确性的境地。 令人头痛的陈年老BUG（终章） 事实上，不是所有bug都需要解决掉的。很多时候我们明明知道正在为代码引入一个bug，但是我们却依然保留它。因为回避它的代价太大了，我们宁愿限制它的前提条件不让它轻易发生、或者将其“圈养”起来（如try-catch）不让它暴走——如何容忍bug也是一门学问。 不过也总有一些技术葩喜欢另辟蹊径，誓言要代表月亮消灭所有bug维护代码界安全——先不说甲就是这种人，反正我是不会去消灭一个几年前就已经知道的bug的。如果要消灭它，我当时就做了，何必等到现在。 这前面提到的“新bug更易于旧bug被解决”是一个原因，但我真正担忧的是我或许会引入更多不可控的bug——代码的历史太久远了，我已经近乎忘记了它的逻辑，我一旦盲目修改，完全有可能采用了更危险的方法去解决那个稳定了5年的bug。 很多时候，我们写完一段代码，只要程序能够编译运行、完成需求功能就算完成了，鲜有考究bug的可能性，大部分的bug都是通过日后使用时再去发现和解决的。其实解决bug的黄金时间在于代码刚被编写的时候，这时候我们往往只需看到异常提示，就可以马上定位异常原因，因为潜意识中我们已经隐约觉得哪个位置会报什么异常了。 所以当我们在面对一些陈年老bug的时候，其实早就已经错过了解决它的最好时机。这时候不妨将其圈养起来，可能相比于消灭它，会令代码更安全。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:42:34 "},"markdown/feelings/请还我安静的4小时.html":{"url":"markdown/feelings/请还我安静的4小时.html","title":"请还我安静的4小时","keywords":"","body":"请还我安静的4小时请还我安静的4小时 —— By EXP 2014-02-28 我大概总结了我每天分配的工作时间，一般情况下，我是这样汇报我的工作情况的： 实际上，我的工作情况却可能是这样的： 表面看来，这两个时间表所完成的工作内容是一模一样的，而且第一个时间表似乎可以更清晰地表述我一天的工作情况。但是它却无法反映出我的困扰：正如第二个凌乱的时间表所示——我的工作实际上是由无数的时间碎片构成的，而我们大部分人可能早已习惯了这个不正常的时间表。 通常，管理者为了更有效率地利用时间，他们很擅长在同一个时间处理多个问题，因为这可以体现出他们处事的应变能力。但我们程序员则更倾向于能够专注地做一件事：同样一件事，相比于断断续续地做4小时，专心地连续做4小时的效率要高得多。工作本就贵在专注，而一旦那种专注的状态被破坏，要恢复这种状态非但不易、而且还会白白浪费很多时间。 大家曾经都可能玩过一个堆纸牌金字塔的游戏，越想要砌得高、所需要的专注时间越长： 程序员开发软件，就好比堆纸牌的过程，想要迅速稳固，那么从开始到完成必须一气呵成，中途不能受到一丝打扰，否则整座金字塔都会散架，只能重头开始。 开发好的软件需要投入大量的精神时间，没有一段时间的酝酿是无法开展工作的。有时我们好不容易才有了一个构思的雏形，突如其来的打扰就会造成整个构思破产。这就是为什么每个程序员都非常讨厌在工作时被打扰的原因——可能十分钟的打扰，会多浪费我们一个小时的时间——这绝不是夸大其辞。 可惜往往事与愿违，公司绝大多数的环境都不允许我们安静地坐下来，完完全全地做自己的工作。在公司每天都有着持续不断的商讨、邮件、电话需要处理，其实这些事情很多都不是主要工作，但是因为时效性要求很高，把我们真正的工作时间变得支离破碎。 此前，我看过一篇关于 “时间是如何被浪费掉”的讨论。里面有个观点大概是说，浪费时间最危险的方式不是放纵消遣，而是花时间去“做假事”。因为当我们消遣的时候，至少知道我们在放纵自己，负罪感会让我们很快地结束这种状态。而所谓的“做假事”，是指我们在工作时间做一些非实质性的工作，例如收发邮件——花一整天的时间去处理邮件不是什么难以置信的事情，而且整个过程我们都会心安理得，因为这确实是工作。但如果过后问自己今天做了什么，我想很多人的答案基本上都是什么也没干。 我每天的工作都充斥着大量的假事。这些假事本已占用了工作时间，还因为不确定的出现时机，把主要工作的时间也掺和了。我的不少朋友都说，正是由于假事太多，导致白天在公司里根本无法静下心来做任何事情。他们宁愿选择在晚上完成主要工作，而在白天做一些次要的工作——或许这恰好也就是众多程序员都是夜猫子的成因，因为晚上没人打扰。 其实就我个人而论也是如此。我有时周末需要加班，但如非必要（如协同工作），我宁愿把工作带回去家里做。一来节省了来回公司的时间，二来效率确实比在公司高得多，往往要在公司做一天的事情，我在家里可能仅仅只需要短短的几个小时。 不过公司始终是公司，沟通交流是不可避免的一环，我们无法改变这个大环境，唯有从自身作要求，首先从不频繁地打扰别人做起，希望由此可以慢慢形成一种氛围——借由提供别人安静的工作环境，换取自己安静的工作环境——我要求不高，还我安静的3 - 4小时足矣。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 13:30:48 "},"markdown/feelings/别让你的能力成为绊脚石.html":{"url":"markdown/feelings/别让你的能力成为绊脚石.html","title":"别让你的能力成为绊脚石","keywords":"","body":"别让你的能力成为绊脚石别让你的能力成为绊脚石 —— By EXP 2013-11-15 在溺水时拼命抓住的，真的是救命稻草吗？ 能力越强的人，往往对自己的能力越是依赖。但相对地，处理危机的灵活性可能就越弱——尤其在环境发生巨大变化时，这种能力或许就是妨碍自身拓展最大的绊脚石。 人都是善于习惯的动物：长期沉溺在单一的环境中，虽培养了能力、但同时也习惯了一成不变的感觉。尤其是在自身日益卓越的时候，更易于陶醉于自己的能力，稍有不慎便会让自负的优越感侵蚀全身，甚至于逐渐对其他技能产生淡漠感、对环境变化产生迟钝感。 俗话说“居安思危”。自身能力越是接近临界点的时候，也就是最容易让人安于现状的时候——擅长的能力难以提升、其他能力又无心拓展，一旦连最基本的危机感都失去，离被淘汰也就不远了。在此节骨眼上，往往是我们选择的分岔口：是追求精益求精、抑或探求一专多长？我不能帮任何人做出选择，但我个人认为，仅满足于一种能力对自身未必有益：在职业生涯中需要的能力是多元化的，因为这有利于我们可以在环境变化时快速反应、调整自身。我们更需要的是能及时抓住机遇，永远不要被一叶障目、成为井底之蛙。 或许终将有一日，海上刮起大浪，我们都翻船了、溺水了。这不是危言耸听。于是乎，我们为了自救，出于本能地拼命去抓住身边能够抓住的一切——而我们的能力就是我们的一切——但若是我们只有一种能力，那么能抓住的就只有这根稻草。这毫无办法，即使我们深知这根稻草恐怕无法让我们活命。 当然，并不是能力越多，活命的机会就越大，这两者并无绝对的相关性。我只是说，能力越多，我们能够选择自救的机会就越多——或者会出现浮板、甚至是木船——至少不会是那根弱不禁风的稻草。 我很清楚，我也只是个溺水的人。 但我们都将会是溺水的人。不过，我们都不应该只有一根稻草。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:43:54 "},"markdown/feelings/我们需要的是测试而非重构.html":{"url":"markdown/feelings/我们需要的是测试而非重构.html","title":"我们需要的，是测试而非重构","keywords":"","body":"我们需要的，是测试而非重构我们需要的，是测试而非重构 —— By EXP 2013-11-13 上台一鞠躬。是的，久别两个月我又回来了。 最近忙着杂七杂八的一堆事，不过基本都是维护老项目代码了。一说起这个亘古不变的老话题，估计许多人都要开始抱怨了吧：没有格式没有篇章的混乱、没有甚至是错误的注释、没有说明文档……“我可写不出这种天才代码”、“实在太难看了，我要重构”之类的话我已经听不少了。 读代码难，但写代码也不见得很容易。老代码们都有着他们自己的项目背景，经手的人也多，日积月累自然而言就变成了现在的样子了。重构——说是很容易的——先不论我们的能力跟当时开发者相比孰优孰劣，他们会写出这样的代码总有他们的理由，只是经过时间的磨蚀，当时的缘由我们就不得而知了。 重构不是对付老代码最好的手段。重构首先会遇到最大的问题，就是刚才提到的项目背景，大多数的老代码除了满足基本需求功能，后期还会不断临时加入满足某些用户需求的特殊功能，若对这些不了解就轻易地重构，势必造成代码功能缺失。 之所以那么多人要重构老代码，因为我们都对它恐惧。而恐惧，则是源于我们对它的不了解。维护老代码时，我们怕破坏它的功能、怕造成程序的不稳定……我们维护自己的代码时，何曾会怕这怕那的？希望对老代码进行重构，不过是因为我们想把它变成自己的东西、方便自己操作而已。可一旦交接给下一个人，没准他又开始喊着要重构我们的代码了吧。 老代码告诉我们的是它的基本的样貌，不到万不得已，不必通过重构对它进行整容。我们只需要使用测试用例，去矫正它在岁月中留下的伤疤。 事实上，我们也应该强迫自己持续地给老代码做测试。刚开始这样做，可能会使得进度缓慢，但长期下去，我们就会有足够的测试用例，这除了使得老代码的功能可以更健壮，也使得我们对老代码更有信心，无需再过度担心维护代码时带来的副作用。 打个比方，举重运动员为了变得更健壮，日积月累地训练，终于使得腿部筋腱开始出现断裂。不过他认为持续的锻炼会使自己最终适应这种痛苦。但正如他每次下蹲都要忍受疼痛一样，没有测试用例的老代码在各种新功能附加的重压之下也开始出现扭曲、变形。后来医生告诉他应该重点做康复锻炼，因为只有在复健后，他的肌肉会变得更结实、能够承担更多重量。同样地，针对老代码的既有功能补充测试用例，可以使得老代码更健壮，当以后交接到别人手上的时候，重构的呼声自然也就会减少了。 不过有的时候，我们拿到手的老代码是已经有一定的测试用例的了，它们也能运行成功，但是这些测试却对理解老代码毫无帮助——有些测试是为了图方便而建立的，它们之所以能运行成功，是因为这些测试都是在假设代码能够顺利运行的理想情况下建立的——我们不需要这种花瓶式的测试用例。 其实最理想的情况，就是测试用例可以完全覆盖老代码，但实际上不可能——我们也不需要那样做——字典上单词都是用到时才去查的，测试用例也一样，不然你有看到过谁把字典背下来了吗？ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:41:37 "},"markdown/feelings/月缺梦圆.html":{"url":"markdown/feelings/月缺梦圆.html","title":"月缺，梦圆。","keywords":"","body":"月缺，梦圆。月缺，梦圆。 —— By EXP 2013-09-09 又是一年中秋时。 你多久没回家看过父母了？ …… 一个星期？一个月？抑或，一年？ …… 每个孩子从小都有一个愿望：独立。殊不知是狭隘的独立。年少的我们总是向往无拘无束的自由，而这种又总是单纯地诱使我们离开家里。于是选择远一点的地方念书，便成为了最简单的方法。而我，也不例外。 在我还在读书那会，我不怎么喜欢回家，纯粹只是因为怕麻烦。 那时候每个节日对我的意义，无非就是一个休息的日子——不管是春节也好，中秋也罢。虽然都会回家一趟看看父母，但总有一种“循例”的感觉在左右。“每逢佳节倍思亲”，那时的我，其实体会不深。 然后，就毕业了。 世事往往发生在意料之外、却又意料之中的无能为力。我因为工作来到了广州，可是昔日的同窗好友，却是一个都不在这里。或许只有到了真正举目无亲的时候，那种在语文课本念了几百遍的思乡情怀才真的会油然而生吧。 我又怎么想到有一天，回家，也会变成一种奢侈。 父母总是喜欢把我的前途放在首位，每次我打电话回家，跟父母说大概什么时候回去的时候，电话那头总是说：工作要紧，没时间就不用回了。我回家的时候，经常只能待1天、甚至更短，但只要我回去了，他们都会很开心。其实时间长短又何妨，我不过希望可以带回去一份心意，而已。 或许是成长总会带来一些自负，毕业的时候，我就跟自己说不会再问家里拿1分钱。因为我没有再依赖父母的理由，也没有资格去依赖他们。但是每次在家的时候，父亲总是问我钱够不够花，母亲则总是做一桌子我喜欢的菜。——他们都怕我一个人过得不好。 其实一个人又有什么所谓好不好的。我隐约觉得，我依赖了父母20年，父母又何尝不是依赖了我20年。只是我突然有一天真的离开了父母，不用他们照顾了，他们少了一份念想，觉得不习惯吧。我现在唯一可以告诉他们的，就是我过得很好，仅此而已。 我不怕被父母依赖。倒不如说，我希望有能力被父母依赖。早几年前开始，家里的大小事，父亲都会跟我商量。我那时候总跟父亲说：爸，你喜欢就好了，怎么决定我都没意见。有一次我母亲跟我谈到这个，她跟我说：你爸现在谁都不信，最信就是你……。我那天真的觉得，父母真的都已经老了。 算上大四那年，我出来工作已经一年多了，每次回到窝里，总是空荡荡的，总有种失落感。说真的，我比较怀念上中学的日子，起码每次回家都能看见父母，只悔那时不懂珍惜。 经常有人问我：你现在工作的地方跟家里那么近，回家不也是很方便吗？是很方便。但是物理上的距离再短，也是距离。影响沟通的距离。这种距离在心里累积起来，会变成难以驱散的孤独感，我不希望父母承受那种孤独感。 现在虽然父母嘴上不说，但是我知道他们总盼我什么时候能回家，可以见上一面，但又总是怕会烦叨我，没敢叫我回家。这种滋味不好受。所以我现在的愿望，就是可以把父母接到身边，安享晚年。至少，可以让他们少了一份牵挂。“父母在，不远游”，把父母留在家里，是我心头的一根刺。 之前在网上看过一篇文章：假设父母都能活到100岁，可等到我们工作的时候，他们的人生已经过半了。剩下50年，如果我们每年只回家1次，那也只能再见父母50次而已。我不知道这种日子还能有多长。但我希望在还没有失去的时候，可以好好地珍惜它。 中秋不过是个传统，我们不应该为了过中秋而过中秋。平时哪怕再忙，也应该常回家看看，好好想想自己的父母、家人。有些恩情，是我们穷尽一辈子都还不了的。 …… 月有阴晴圆缺。 但愿人长久，千里共婵娟。 …… 最后的最后，愿大家中秋阖家团圆，愿天下父母幸福安康。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 13:30:48 "},"markdown/feelings/请发展你的惰性.html":{"url":"markdown/feelings/请发展你的惰性.html","title":"请发展你的惰性","keywords":"","body":"请发展你的惰性请发展你的惰性 —— By EXP 2013-08-04 你工作的时候就只是工作吗？ 我不一定。我有些时候不会把今天的所有时间都用在为了完成今天的工作任务中。而且我也相信，把全部时间都花费在工作并不代表就能很好地完成工作。 作为一个程序员，我上班时出现过的状态不外乎是三种，如果以键盘作为计量单位，那就是：不停地敲键盘、偶尔敲键盘、和不敲键盘。状态一基本就是忙于开发任务的时候，状态二一般就是调试代码的时候，而状态三就是在做跟当前工作没有直接关联的事情的时候。 如果把状态一和状态二视为对忠于工作任务的韧性，那么状态三应该就是我对工作的惰性了。不过于我而言，一和二不外乎都是体力劳动的一种，只能使我做完工作，但三却能帮我做好工作。 众所周知，程序员是脑力工作者，我们的价值在于如何运用我们的脑细胞。同样都是为工作的需求写代码，一套考虑周全的代码总比为了应付工作而写的代码生命力更持久，其维护难度也更低。其实IT行业发展至今，先辈们积累了无数这方面的知识，并作为可利用的财富流传下来，而我至今所学的也不过是沧海一粟。因此我比较喜欢看一些前人总结的经验心得，作为我忙中偷闲的乐趣，而契机不过是恰好工作有需要、或是偶尔的突发奇想罢了。 并非我们在开发和调试的过程中学不到东西，只不过这些大部分都只能够作为我们自身的经验被积累下来。要把经验转化为知识，是需要时间去顿悟的。相较之下，直接去累积前人有价值的知识，化为己用更为便捷。于当下确实是花费了一点工时，而且也未必对目前的工作任务起到关键性的作用，但之后总有其发挥价值的时候，这我深有体会。 当然，我对工作的这种惰性，有一部分是源于我对职业的兴趣，这也是使得我能够保持不疲于工作的心态的原因之一。虽然对当下工作任务而言，这种惰性有点不公，但我觉得对以后的工作、乃至于职业而言却是有好处的。 惰性是一种慢热型的能力，未必适用于所有人。即使要发展惰性，各人方向或许也有所不同，不过都应该要知道把握尺度，不要影响到相关工作的完成质量，毕竟惰性的发展并不是能够对工作不负责的借口。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:29:36 "},"markdown/feelings/优雅的烂代码.html":{"url":"markdown/feelings/优雅的烂代码.html","title":"优雅的烂代码","keywords":"","body":"优雅的烂代码优雅的烂代码 —— By EXP 2013-07-28 /** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│& 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│\" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │ .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 敏捷开发是当下软件开发的主流模式之一，为了摒弃以往瀑布式开发带来的弊端，敏捷开发推崇在团队中以个人为单位进行简单的模块化开发，它更注重的是团队间的沟通和模块间的衔接。 为了使代码层面上的沟通更便捷，一套套的编码规范和设计模式应运而生，毫无疑问，使用这些规范模式会使得我们的代码看起来更优雅，经验也证明这更有利于团队沟通。 对于经验丰富的程序员而言，针对某种功能使用合理的设计模式编写出规范的代码、并提供满足功能调用的接口，可能是易如反掌的事。但每个团队中都不可避免的会存在生涩的程序员，例如我。对我而言这种方式就并不完全是这么回事了。 即使我作为一个项目经验如何不足的程序员，独立开发一个简单功能模块的能力还是具备的。经常在编写代码之前，我脑中已有完整的思路，我可以很清晰地向别人陈述我的编程思想，我也很有信心可以把这些思想变成代码。但事实上这可能比我想象的要难得多。很多时候我发现我花费了比预期更多的时间，却无法写出一段可执行的代码。因为我在编码的时候，想得更多的不是如何去实现这个功能，而是如何让别人更舒服地看懂我的代码。 虽然很多开发团队都强调代码的优雅性，但这是以“可运行性”为前提的。这种过分放大观赏性代码的地位，本就是本末倒置的行为。优雅只是交流的辅助手段，但不是唯一的手段。 事实上，如果仅是实现需求的功能，而不去考虑任何外因，我确信我可以很快地写出一段可运行的“烂代码”。烂代码与优雅代码相比，最表面的区别可能仅是可读性差而已。而且团队开发很多时候并不需要关心别人开发的功能是如何实现的，这些优雅性的问题自然也不会被马上指出来了。 当然，我并不是倡导每个人都去写烂代码。烂代码只是一个过度的产物，考虑到以后代码的维护性和可扩展性，必须在烂代码保证功能需求后，对其进行重构。而往往优雅地重构自己既成的代码，很可能要比优雅地写出构思中的代码要容易得多。 摒弃优雅性的约束，烂代码使得开发过程更轻松、耗用资源更少、编程的目的性更强。其实这与敏捷开发的部分理念恰好是一致的：有目的指向的简单构建、有辅助指向的重构勇气。这正是烂代码的优雅之道。 /** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　　　　　頂頂　　　　　 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂　　　　　　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　　　　　頂頂頂　 * 　　　頂頂　　　　　　頂頂　頂頂　頂頂 * 　頂頂頂頂　　　頂頂頂頂頂　頂頂頂頂頂 * 　頂頂頂頂　　　頂頂頂頂　　　頂頂頂頂 */ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:28:11 "},"markdown/feelings/程序员的病态.html":{"url":"markdown/feelings/程序员的病态.html","title":"程序员的\"病态\"","keywords":"","body":"程序员的\"病态\"密集空间恐惧症强迫症神经质妄想症程序员的\"病态\" —— By EXP 2013-07-16 每个程序员都是从菜鸟过来的，而菜鸟的成长之路总是崎岖的。不断地碰壁、不断地摸索、不断地成长，从中难免衍生出各种各样的“病态”，而这其实都是我们切实作为一个程序员的证明。 密集空间恐惧症 这应是程序员的通病了。不知道是谁的谎言：“程序员每天的工作就是看着一堆01代码”，这想着都会令人疯掉吧。每个程序员最怕看到的，就是那些一堆堆没换行没缩进的代码，更何况是一堆01代码。 如果一个程序员说他没有密集空间恐惧症，那他一定就是这堆代码的创始人之一了。我不理解为什么总有一些程序员要乐此不疲地代替编译器把代码中的空字符删去，编码规范出现的初衷，很可能就是为了对付这些程序员的——即使我忘记了我曾经或许也是他们中的一员。 强迫症 一些程序员在开发一个新项目的时候，会考虑太多情况，例如这种代码在以后的运行是否稳定、维护是否方便等。尤其是有一点项目经验但又不足、而且是完美主义者的程序员，在写代码的过程中会不断地考虑设计文档没有的东西，然后就很忘我地在项目代码上画蛇添足。 往往强迫自己写一个完美的程序的人，其现实就是：由于客观因素影响（如项目工时不足），导致最后提交的代码中出现太多没有被实现的抽象方法，结果反而是自己给自己挖了一堆无法填补的坑。 神经质 基本上每个正常的程序员都有点神经质的。一个显著的特点就是：我们对自己的代码充满信心、但看到别人的代码都会疑神疑鬼，习惯性地认为那有BUG，然后千方百计地将其找出来。如果有能力把BUG修复，还会因此感到非常有成就感，尽管那个BUG是无关痛痒的。 程序界有一个“潜规则”：每个程序中80%的BUG（漏洞）都是别人发现的。这跟程序员的神经质应是脱不了干系了。 妄想症 大部分程序员最初接触到一些已经投入使用、但看上去写得很差的项目代码时，就会开始妄想自己的能力，认为自己可以用最好的技术去重写它。由于是一时冲动，欠缺考虑因素太多（如背景、支撑环境等），往往都是失败告终。 其唯一的好处可能就是在重写的过程中，可能确实学到了一些未能投入使用的新技术，仅此而已。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 13:00:41 "},"markdown/feelings/工作需要经营.html":{"url":"markdown/feelings/工作需要经营.html","title":"工作需要经营","keywords":"","body":"工作需要经营智于心，慧于行：审视自己的工作模式慎言笃行：真诚做人，踏实做事云在青天水在瓶：心态决定位置工作需要经营 —— By EXP 2013-06-18 转眼间我已实习了3个月有余，在这期间，相比于精通什么技能或业务，我更学会了应该如何去经营自己的工作。 我深深体会到工作并不是做好自己的份内事就足够的。单纯的努力工作，那只是为了谋生所付出的劳动；用心去经营的工作，才有可能会变成自己的事业。 智于心，慧于行：审视自己的工作模式 在公司里面，我被告知得更多的是如何去改善自己的工作模式，其中最倡导的是尽可能避免无意义的重复劳动。确实，平时与我们工作打交道的是各种各样的数据，要逐一去处理这些本质一样而问题各异的数据，无疑是事倍功半的行为。 好的工作模式，不仅可以提升工作效率，使我们逃离无意义劳动的怪圈，还可以实现公司价值和自身价值的双赢。而工作模式的优化，关键在于不断积累的经验。 例如平时可以多留一个心眼，把新的想法或遇到的问题进行记录，这样日积月累下来，在遇到新的问题时就不至于手忙脚乱，甚至可以利用以往类似的处理经验，达到事半功倍的效果。 不过，有好的想法固然不错，但更重要的是将其付诸行动，找到一种属于自己的工作模式，而不仅仅是纸上谈兵。 慎言笃行：真诚做人，踏实做事 “真诚做人，踏实做事”，这其实也就是我入职时了解到的企业文化之一。 做事先做人，人脉关系是经营工作的必修课。在我看来，交际圈的尺寸，与能否诚心待人是正相关的。但无论与他人相处如何，都必须谨慎言行，视场合说话。语言是把双刃剑，所谓“祸从口出”，当不知道说什么的时候，既不是阿谀奉承，也不应论人是非——不逞口舌之快，有时踏踏实实多做事，远比一切语言更具说服力。 想起我刚入职的时候，就接到了一个特殊“任务”：必须在限期内认识组内所有同事，并让他们认识我。这确实不是一个好差事，因为当时我连组内有哪些人都不清楚，就是说我连自我介绍的对象都没有……不过也不知是我人缘好还是面皮厚，这个任务最后还是完成了。 而现在的我已经结识不少其他部门的同事了，在这段期间，受到了非常多同事的包容和照顾，其实我能够这么快融入公司，离不开同事之间的良好氛围。我都甚至觉得，我的人际关系，其实是大家帮我经营起来的。 云在青天水在瓶：心态决定位置 这其实是我比较信奉的一句座右铭。云和水都是同一种物质，但是它们的形态决定了它们所处的位置。但也不应该因为身处青天而自傲，因为身处瓶中而自卑。 在职期间，我并不是所有工作都一帆风顺，我也因为规范性事故受过批评、被扣过绩效。后来也因为工作表现好而受到了表扬和奖励。但其实我个人看待事情的心态是比较淡薄的，我不会随便自暴自弃，也不会骄傲自负。我觉得既然是自己的问题，就应该承认并纠正，逃避并不是解决问题的方法；而对于嘉许，平常心看待即可。 我觉得相比于工作模式和人脉培养，工作其实更依赖于内心的修养。一份良好的心态，在一定程度上可以反映出以后工作的发展空间、以及对挫折的承受能力，甚至为自己提供了一个精神支持。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 12:43:21 "},"markdown/about/about_us.html":{"url":"markdown/about/about_us.html","title":"关于我们","keywords":"","body":"EXP-BLOG站点介绍站长介绍联系方式EXP-BLOG 站点介绍 本站站点是：EXP 技术博客（https://lyy289065406.github.io/exp-blog） 本站的文章 95% 为站长在不同时期的原创作品，初衷是为了记录学习过程中的点点滴滴以验证自身，因此所分享的内容主要取决于站长当时正在做什么方面的研究，导致覆盖到的领域可能相对比较广泛。 撰写内容以IT软件方面为主，如算法、前后端开发技能、经验心得等，尤其针对特定领域、或热门领域，会尽可能设立技术专题与大家分享。 此博客是利用 GitBook 搭建的，同时兼容在 Github Pages 和 本地（线下） 运行。 站长介绍 站长 EXP 个人简历 （JS动画） 生涯 6年 学生时期因为热衷算法，在ACM社团写了不少POJ解题报告，参与了多种校内外比赛并获得一定成绩因工作本职需要面对多种接口的海量数据，涉猎数据分析和挖掘后自然天成进阶爬虫（B站、新浪、腾讯、百度都去参观了一下）一次游戏时的偶然机会接触到了逆向工程为了跟上时代脚步开始了研究人工智能和方块链的不归路最终决定专注于安防领域的渗透测试，圆了小时候一直以来的梦想 职称 高级 系统架构师 座右铭 工作 适用的，才是最好的   生活 因上努力，果上求缘 职业技能 流程 需求、分析、设计、开发、测试、运维   文档 Markdown、Word、Excel、PPT、Visio   工具 Maven（插件/骨架）、Nexus、Jenkins、Git/SVN、Eclipse、PyCharm、VS、VMWare、Wireshark、Fiddler、OD、SecureCRT、Shadowsocks、WordPress   管理 日志管理、版本管理、构件管理、项目管理、自动化部署、自动化升级 专业技能 语言 C/C++、Java、Python、汇编、Ruby   基础 数据结构、设计模式、字符集/编码、多线程、正则、Cron、开发规范   后端 UML、数据库（SQL/NoSQL）、单元测试、Debug、逆向工程、端口转发   前端 HTML、CSS、JavaScript、PHP、Swing   协议 TCP/UDP、Socket、WebSocket、SOAP（WebServices）、HTTP/HTTPS、Cookie、XML、JSON、FTP、Telnet、MAIL、MQ（JMS/Kafka）、Corba   系统 Windows、Linux、Mac、Kali 领域技能 专题 算法、爬虫、渗透测试、大数据分析（数据挖掘）、嵌入式开发、驱动开发、深度学习、区块链   架构 Kafka、Zookeeper、Dubbo、Ansible 其他技能   构件封装、网站建设、图像处理、3D建模（OpenGL/3DMAX）、视频剪辑 联系方式 QQ：289065406 Email：289065406@qq.com Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-02 12:18:53 "},"markdown/about/copyright.html":{"url":"markdown/about/copyright.html","title":"版权声明","keywords":"","body":"前言免责声明隐私原则消息推送前言 我们的站点是：EXP技术博客（https://lyy289065406.github.io/exp-blog） 您使用或继续使用我们（EXP技术博客）的服务，即意味着同意我们按照本《隐私策略和版权声明》收集、使用、储存和分享您的相关信息。 如对本《隐私策略和版权声明》或相关事宜有任何问题，请通过 Email : 289065406@qq.com 与我们联系。 免责声明 本站的内容均基于《署名-非商业性使用-相同方式共享 3.0 中国大陆 (CC BY-NC-SA 3.0 CN)》协议创作或转载，您可以转载分享，但同时应该保留原文链接。 本站提供的所有内容仅供学习、分享与交流，我们不保证内容的正确性。通过使用本站内容随之而来的风险与本站无关。当使用本站时，代表您已接受本站的免责声明和隐私原则等条款。 隐私原则 本站的留言区可能会透露您的隐私信息，当您留言时，您的电子邮箱、Cookie信息和IP地址都会被记录。这些信息仅为了改进我们的网站质量和可能的交流沟通。我们不会将这些信息进行展示、出租或出售给任何人。但以下情况除外： 只有透露您的个人资料，才能提供您所要求的产品和服务； 我们需要听从法庭传票、法律命令或遵循法律程序； 我们发现您违反了本站已发布的条款或声明。 消息推送 您在使用我们的服务时，我们可能使用您的信息向您的设备发送电子邮件、新闻或推送通知。如您不希望收到这些信息，可以按照我们的相关提示，在设备上选择取消订阅。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 13:00:45 "}}
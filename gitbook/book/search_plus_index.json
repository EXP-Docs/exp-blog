{"./":{"url":"./","title":"首页","keywords":"","body":"EXP-BLOGEXP 随笔小筑EXP-BLOG EXP 随笔小筑 [success] 　因上努力，果上求缘 EXP's Github 仓库 状态 说明 exp-blog 公开 EXP 技术博客 gitbook-server-docker 公开 使用 Docker 构建的 GitBook 服务器 CTF-Solving-Reports 公开 CTF 解题报告 expcodes 公开 经验代码库（索引目录） exp-libs 公开 经验构件库（Java版） mojo-release-plugin 公开 Maven 项目发布插件 mojo-archetype 公开 Maven 项目规范骨架 mojo-web-archetype 公开 Maven 项目规范骨架（Web版） site-package 公开 站长工具：站点功能组件 auto-planting 私有 Github 自动种草 account-mgr 公开 帐密管理工具 auto-upgrader 公开 自动化升级插件 certificate 公开 软件授权插件 cron-expression 公开 cron 表达式生成器 pyzone-crawler 私有 QQ空间爬虫（Python版） jzone-crawler 私有 QQ空间爬虫（Java版） sina-crawler 私有 新浪博客爬虫 top-baidu-tieba 私有 百度贴吧顶贴机 bilibili-plugin 私有 哔哩哔哩插件姬 ro-single-server 私有 仙境RO传说-单机版-服务端（支持联机） ro-single-client 私有 仙境RO传说-单机版-客户端（登陆补丁） api-online 公开 在线 API environment 公开 环境安装包 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 12:49:19 "},"markdown/technical/algorithm/":{"url":"markdown/technical/algorithm/","title":"算法","keywords":"","body":"算法算法 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/algorithm/acm/":{"url":"markdown/technical/algorithm/acm/","title":"ACM 资料","keywords":"","body":"ACM 资料ACM 资料 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/algorithm/poj/":{"url":"markdown/technical/algorithm/poj/","title":"POJ 解题报告","keywords":"","body":"POJ 解题报告POJ 解题报告 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/safe/":{"url":"markdown/technical/safe/","title":"安全","keywords":"","body":"安全安全 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-30 14:08:43 "},"markdown/technical/safe/pentest/":{"url":"markdown/technical/safe/pentest/","title":"渗透测试","keywords":"","body":"渗透测试渗透测试 白帽子渗透测试入门资源：参考书、课程、工具、认证 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 12:43:45 "},"markdown/technical/safe/pentest/白帽子渗透测试入门资源.html":{"url":"markdown/technical/safe/pentest/白帽子渗透测试入门资源.html","title":"白帽子渗透测试入门资源","keywords":"","body":"白帽子渗透测试入门资源：参考书、课程、工具、认证前言名词解析Pwk课程与OSCP证书CTF工具参考书相关文献推荐资源下载白帽子渗透测试入门资源：参考书、课程、工具、认证 前言 初入渗透测试领域，过程中遇到不少错综复杂的知识，也遇到不少坑，特此记录，慢慢整理慢慢填。 名词解析 名词 全称 解析 PwK Penetration Testing with Kali Linux Kali-Linux 渗透测试培训课程 OSCP Offensive Security Certified Professional 攻防安全专家认证 OWASP Open Web Application Security Project 开放式Web应用程序安全项目它提供有关计算机和互联网应用程序的公正、实际、有成本效益的信息，如《2017 Top 10 应用风险评估报告》其目的是协助个人、企业和机构来发现和使用可信赖软件 SCAP Security Content Automation Protocol 安全内容自动化协议已成立了SCAP中文社区，集成了协议框架中的CVE、CCE、CPE、CWE、CVSS、OVAL等6种网络安全相关标准数据库 CVE Common Vulnerabilities and Exposures 公共漏洞与暴露每个CVE都有唯一编号，是一个漏洞字典表 EXP Exploit 安全术语，指可利用点（如漏洞、代码等） vul Vulnerabilities 安全术语，泛指漏洞 PoC Proof of Concept 漏洞的概念证明，常见是一段可复盘漏洞的代码 payload - 安全术语，有效载荷，泛指漏洞利用成功后所要做的事情（如Cracker会做一些有害的或者恶性的动作） WAF Web Application Firewall Web应用防护系统（也称为：网站应用级入侵防御系统） Fuzz Fuzz testing 模糊测试，一种安全测试方法它介于完全的手工测试和完全的自动化测试之间而手工测试是指渗透测试，即模拟Cracker进入系统查找漏洞 社工 社会工程学攻击 安全术语，泛指通过心理战术，欺诈他人以收集信息、行骗和入侵计算机系统的行为 XSS Cross Site Scripting 跨站脚本攻击（缩写首字母为X是为了不与CSS混淆）根据攻击特点分为：反射型XSS、存储型XSS、DOM-XSS DoS Denial of Service 拒绝服务攻击 DDoS Distributed Denial of Service 分布式拒绝服务攻击 SQLi SQL Inject SQL注入式攻击 CSRF Cross-site request forgery 跨站请求伪造攻击 CORS Cross-Origin Resource Sharing 跨源资源共享 GDPR General Data Protection Regulation 通用数据保护条例，在2018-5-25由欧盟正式出台该条例的适用范围极为广泛，任何收集、传输、保留或处理涉及到欧盟所有成员国内的个人信息的机构组织均受该条例的约束，号称史上最严个人数据保护条例 Pwk课程与OSCP证书 OSCP认证：是一个专门针对 PwK课程 的国际安全专业认证。该认证机构声称，OSCP认证是一个区别于所有其它认证的考试，考试全程采取手动操作实战的方式，而不设笔试环节。这是在安全领域含金量非常高的国际认证。 认证条件：无 考试模式：OSCP的认证考试也是另类的存在，考生拥有24小时的时间（实际是23小时45分钟）去完成考试，具体如何分配时间由考生自己决定。题目是5台主机（随机抽取），目标是攻入并拿到最高权限（ROOT/SYSTEM）。基于难度级别，成功执行的攻击会获得相应的积分。24小时结束之后，你还有24小时去完成并提交考试报告（需要详细说明攻击步骤和里程碑截屏来证明确实攻破并获得相应权限）。 考试费用：最低 $ 800 （30天实验室访问学习 + 考试认证） 相关链接： OSCP概述 PwK培训材料 CTF Capture The Flag，夺旗赛。 通过在线靶场进行实战，磨炼网络安全技巧的一种竞技。这里推荐几个免费的 CTF 站点： Root Me CG-CTF Vulhub 不建议找答案，勇敢地刷题吧！ 可以很好地锻炼发掘EXP的能（nao）力（dong）~ 工具 工具 简介 下载 Kali-Linux 渗透测试的必备工具包Kali是一个基于 Debian 的 Linux 发行版，专门用于渗透测试的工具系统大多数做安全测试的渗透和审计开源工具都被尽可能多地囊括在内 官网 CVEList CVE字典表 Github SecLists OWASP维护的一个安全信息列表集合该集合包括了用于渗透的各种类型的列表，这些列表包含了237个字典文件以及常用的 Web Shell 攻击载荷，字典文件类型众多，如用户名、密码、域名、敏感数据特征码、模糊测试载荷等 Github Exploit Database 可利用漏洞数据库（在线）罗列了最新被发现的CVE和PoC等信息，可用于学习漏洞原理和复盘 官网 SearchSploit 与 Exploit Database 配套的命令行工具包（已集成到Kali）它把Exploit Database的数据保存在本地机器（攻击方），通过搜集目标机器（防御方）的信息，在本地发现这些信息的EXP，然后在本地机器提取对应的PoC上传到目标机器实现渗透 官网 Hydra 弱密码爆破工具（已集成到Kali） Github Burp Suite 用于攻击web 应用程序的集成平台（谁用谁知道） 官网破解版密：gsqygf Arachni 基于Ruby的Web漏洞扫描工具算不上强大但有其特色，用于评估web应用程序的安全性不仅能对基本的静态或CMS网站进行扫描，还能识别大部分平台的指纹信息（硬盘序列号和网卡物理地址） 官网Github XSStrike 基于python的XSS漏洞扫描和利用工具它对参数进行模糊测试之后构建合适的payload，然后对参数进行穷举匹配，大多数payload都是由作者精心构造。其内置爬虫功能，能够检测并尝试绕过WAF，且误报率极低 Github XssPy 基于python的Web应用XSS漏洞智能扫描器它不仅能检查主页或给定页面，还能够检查网站上的所有链接以及子域微软、斯坦福、摩托罗拉、Informatica等很多大型企业机构都在用 Github Wfuzz Web Fuzzer：Web应用程序评估审查工具它可以对任何字段的HTTP请求中的数据进行模糊处理 Github OpenSCAP 基于C/C++实现的SCAP协议开源框架目的是为SCAP各个标准协议的使用者提供一套简单易用的接口 官网中文社区Github Hackvertor 黑客工具包看看黑客们平时都在用什么工具 官网 SSL/TLS安全评估报告 检查HTTPS网站的SSL证书安全性 在线检查 SecurityHeaders 通过分析HTTP响应头，评估相关安全选项是否配置得当可根据评估建议修改配置 在线检查 URL Fuzzer 扫描Web服务器上的隐藏文件/目录是否存在敏感信息 在线检查 MD5Online MD5解密：通过已知的Hash字典逆向爆破（论MD5加salt的重要性） 在线使用 truffleHog 排查 Git 项目中是否包含可疑的敏感信息 Github BFG Repo-Cleaner 移除 Git 库中的大文件或污点提交 官网Github brakeman 通过静态代码扫描发现代码里的SQL注入问题 Github gixy Nginx 配置文件静态分析器防止安全配置错误，并自动进行缺陷检测 Github bleach HTML净化器对HTML片段进行标签或属性过滤，预防XSS攻击 GithubPython版PHP版 New PHP Snippet PHP在线运行环境 在线使用 RequestBin 临时 HTTP 服务器，用于收集 HTTP 请求，XSS 利器 在线使用 参考书 参考书（Kali系列） 简介/版本 下载 Penetration Testing with Kali Linux (pwk.1.0) Kali-Linux渗透测试学习指南PwK官方文档v1.0.1 - 2014版 腾讯微云密码：4vi4bw Instant Kali Linux 2013Kali快速入门指导 腾讯微云密码：ryxi47 Basic Security Testing with Kali Linux 2014基于Kali的安全测试 腾讯微云密码：qw9ym8 Hacking with Kali - Practical Penetration Testing Techniques 2014渗透测试实践技术 腾讯微云密码：xk8a3z Kali Linux Cookbook 2013Kali指导手册 腾讯微云密码：xhgjcd Kali Linux Social Engineering 2013基于Kali的社会工程 腾讯微云密码：gs4xay Kali Linux：Assuring Security By Penetration Testing 2014通过渗透测试确保安全 腾讯微云密码：6nrp2k Web Penetration Testing with Kali Linux 2013web应用渗透测试 腾讯微云密码：2cxp9c 参考书（Metasploit系列） 简介/版本 下载 Metasploit渗透测试魔鬼训练营 2013.国内中文原创详细讲解了Metasploit渗透测试的技术、方法和技巧，并提供实战的实验室环境 腾讯微云密码：i9ihtu Metasploit The Penetration Tester's Guide 2011渗透测试入门指导 腾讯微云密码：6gurxk Metasploit Penetration Testing Cookbook Jun.2012渗透测试指导手册 腾讯微云密码：r4q73x 参考书（BackTrack5系列） 简介/版本 下载 Offensive Security - Penetration Testing with BackTrack (Lab Guide) v3.2渗透测试实验室指导手册 腾讯微云密码：fj9sqt BackTrack 5 Wireless Penetration Testing Beginner's Guide 无线网络渗透测试入门指导 腾讯微云密码：pdeqfn 参考书（其他） 简介/版本 下载 影响力（中文版） 社会工程学人为什么犯贱？ 腾讯微云密码：ssyf25 欺骗的艺术（中文版） 社会工程学世界著名黑客传奇 腾讯微云密码：wtpih9 Learning Nessus for Penetration Testing Jan.2014基于Nessus的渗透测试 腾讯微云密码：dak9um PP.Penetration Testing with the Bash shell May.2014基于Bash的渗透测试 腾讯微云密码：7saehu The Basics of Hacking and Penetration Testing( Ethical Hacking and Penetration Testing Made Easy ) 2011渗透测试的基本理论 腾讯微云密码：z9enyr The Basics of Hacking and Penetration Testing( Ethical Hacking and Penetration Testing Made Easy ) The 2nd Edition, 2013渗透测试的基本理论 腾讯微云密码：5nwjt3 Advanced Penetration Testing For Highly-Secured Environments The Ultimate Security Guide 2012终极指南：高安全环境的渗透测试 腾讯微云密码：3u3c9t Gray Hat Hacking The 2nd Edition灰帽子黑客 腾讯微云密码：4tvjgb Hacking - Firewalls And Networks How To Hack Into Remote Computers 防火墙突破：远程网络渗透 腾讯微云密码：k93xfx Hacking The Art Of Exploitation The 2nd Edition, 2018漏洞利用的艺术 腾讯微云密码：5c5ee6 Hacking Wireless Networks For Dummies 2005无线网络窃听 腾讯微云密码：px7hgj Penetration Testing A Hands-On Introduction to Hacking 2014渗透测试实践指导 腾讯微云密码：996jfr Practical Hacking - Techniques and Countermeasures 黑客实践的技术与对策 腾讯微云密码：ne75b9 相关文献推荐 社会工程： 信息安全之社会工程学（需翻墙）：常识扫盲、信息收集、假冒身份、施加影响 《影响力》——人为什么犯贱 有哪些「社会工程学」攻击手段？ 防范社会工程学攻击的技巧与姿势 场景案例： Penetration Testing with Kali (PWK) 课程和 Offensive Security Certified Professional (OSCP) 考试回顾 XSS实战：我是如何拿下你的百度账号 如何构建自己的渗透测试环境 驱散前端安全梦魇——DOMXSS典型场景分析与修复指南 CSRF 攻击的应对之道 DDOS 攻击的防范教程 海量日志中，如何实时在线检测未知异常行为？看瀚思的序列异常算法 记一次在实战靶机中使用SearchSploit的总结 Paypal 2FA Bypass（通过删掉HTTP请求参数绕过验证） 部分利用社工技巧的群发邮件样本关联分析 主机入侵： 主机威胁入侵检测开源工具与规则 OSSEC主要功能及原理+详细配置+日志文件分析 集中式日志系统 ELK 协议栈详解 浅谈大型网络入侵检测建设 Linux提权： A GUIDE TO LINUX PRIVILEGE ESCALATION Linux提权基础介绍（是前一篇的译文） Basic Linux Privilege Escalation 史上最全Linux提权后获取敏感信息方法（是前一篇的译文） 初识linux提权 渗透测试中的Linux提权 Linux提权？这四个脚本可以帮助你 Linux提权：从入门到放弃 Windows提权： Windows Privilege Escalation Fundamentals Windows下的渗透测试之提权的基本套路[上][下]（是前一篇的译文） Windows提权笔记 Privilege Escalation Windows Windows 提权命令指南 Windows提权的几种姿势 内网渗透之如何玩转Meterpreter？ Windows内核漏洞利用提权教程 Metasploit、Powershell之AlwaysInstallElevated提权实战 metasploit 渗透测试笔记(meterpreter篇) WebShell： webshell原理 bash反弹shell原理解析 基于机器学习的web异常检测 机器学习入门之像使用Print一样使用算法检测WebShell OSSEC与webshell实时监控探索 HTTP相关： HTTP cookies HTTP 安全最佳实践 跟着 Github 学习 Restful HTTP API 设计 其他： 米斯特白帽培训讲义 知道创宇研发技能表v3.1 大学霸 Kali Linux 安全渗透教程 大数据安全分析漫谈 浅析ReDoS的原理与实践 最好用的开源Web漏扫工具梳理 How to completely remove a file from a Git repository 渗透测试常用工具集合 资源下载 [info] 资源打包下载（密码：mpgksn） Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 12:55:01 "},"markdown/technical/crawler/":{"url":"markdown/technical/crawler/","title":"爬虫","keywords":"","body":"爬虫爬虫 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/deeplearn/":{"url":"markdown/technical/deeplearn/","title":"深度学习","keywords":"","body":"深度学习深度学习 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/blockchain/":{"url":"markdown/technical/blockchain/","title":"区块链","keywords":"","body":"区块链区块链 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/bigdata/":{"url":"markdown/technical/bigdata/","title":"大数据","keywords":"","body":"大数据大数据 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/technical/re/":{"url":"markdown/technical/re/","title":"逆向工程","keywords":"","body":"逆向工程逆向工程 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/":{"url":"markdown/notes/language/","title":"开发语言","keywords":"","body":"开发语言开发语言 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/c/":{"url":"markdown/notes/language/c/","title":"C/C++","keywords":"","body":"C/C++C/C++ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/java/":{"url":"markdown/notes/language/java/","title":"Java","keywords":"","body":"JAVAJAVA Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/python/":{"url":"markdown/notes/language/python/","title":"Python","keywords":"","body":"PYTHONPYTHON Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/ruby/":{"url":"markdown/notes/language/ruby/","title":"Ruby","keywords":"","body":"RUBYRUBY Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/language/ass/":{"url":"markdown/notes/language/ass/","title":"汇编","keywords":"","body":"汇编汇编 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/datastruct/":{"url":"markdown/notes/datastruct/","title":"数据结构","keywords":"","body":"数据结构数据结构 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/design/":{"url":"markdown/notes/design/","title":"设计模式","keywords":"","body":"设计模式设计模式 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/database/":{"url":"markdown/notes/database/","title":"数据库","keywords":"","body":"数据库数据库 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/net/":{"url":"markdown/notes/net/","title":"网络","keywords":"","body":"网络网络 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/notes/scm/":{"url":"markdown/notes/scm/","title":"配置管理","keywords":"","body":"软件配置管理软件配置管理 Ansible-Tower 部署笔记 Git命令行安装与使用笔记 VisualSVN 使用手册 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 14:42:58 "},"markdown/notes/scm/AnsibleTower部署笔记.html":{"url":"markdown/notes/scm/AnsibleTower部署笔记.html","title":"Ansible-Tower 部署笔记","keywords":"","body":"Ansible-Tower 部署笔记前言1. 部署说明1.1. 安装环境1.2. 安装清单2. 安装步骤2.1. 安装 pywinrm（可选）2.2. 添加相关用户并授权2.3. 安装 Ansbile-2.7.52.4. 安装 PostgreSQL-9.62.5. 安装 Ansible-Tower-3.3.32.6. Ansible-Tower授权3. 附：被控主机为 Windows 时的额外配置3.1. 查看 PowerShell 与 .NET 版本并升级3.2. 安装并查看 WinRM 服务3.3. Ansible 测试 WinRM 连接Ansible-Tower 部署笔记 前言 作为时下最流行的自动化运维工具之一，Ansible 在业界应该是无人不知无人不晓的了。 作为一款轻量化的开源软件，它只需要简单地通过 SSH（对Linux平台）或 PowerShell（对Windows平台），无需被控主机安装客户端，就能实现远程操控、部署、升级等配置管理。 通过编写简单的 playbooks（yml） 脚本就能轻松对成千上万的主机进行区域管控、日常巡检等任务。 而 Ansible-Tower （旧称 AWX）作为其配套界面，使得 Ansible 更容易上手。 这里提供一些官方资料： Ansible 官网 : https://www.ansible.com/ Ansible-Tower 官网 : https://www.ansible.com/products/tower Ansible 官方文档（全） : https://docs.ansible.com/ Ansible 官方教程（英文版） : https://docs.ansible.com/ansible/latest/index.html Ansible 官方教程（中文版） : http://www.ansible.com.cn/docs/intro.html Ansible Github : https://github.com/ansible 1. 部署说明 本文主要记录了在 ubuntu 上部署 Ansible 和 Ansible-Tower 的过程。 虽然 Ansible-Tower 支持在多种操作系统版本上部署，但对于 ubuntu 只支持 14.0 和 16.0 两个版本（而 Ansible 则是支持到 ubuntu 18.0）。 为了可以同时安装 Ansible 和 Ansible-Tower ，本文选择了 ubuntu 16.0 系统进行安装。 1.1. 安装环境 操作系统：Ubuntu 16.04.5 LTS 预装软件：python 2.7、openssh 1.2. 安装清单 pywinrm （要求版本至少为 0.2.2，若不管理 windows 机器则无需安装） Ansible-2.7.5 （ 要求 python 版本 2.6 或 2.7 ） PostgreSQL-9.6 Ansible-Tower-3.3.3 （ 要求 Ansible 版本至少为 2.2，PostgreSQL版本至少为 9.6 ） 预装组件要求可查看官方手册指引：https://docs.ansible.com/ansible-tower/latest/html/quickinstall/prepare.html 2. 安装步骤 注意下述步骤直接依次复制执行即可完成整个部署流程，其中对于命令行前缀： 【#】表示 root 用户 【$】表示普通用户 2.1. 安装 pywinrm（可选） # apt install python-pip # 安装 pip # pip install --upgrade pip # 更新 pip # pip install \"pywinrm>=0.2.2\" # 使用 pip 安装 pywinrm，此模块用于远程管理 windows 机器 2.2. 添加相关用户并授权 # adduser ansible # 添加 ansible 专用用户 # chmod u+w /etc/sudoers # 修改 sudo 配置文件为可写 # vi /etc/sudoers # 修改 sudo 配置文件，对 ansible 和 postgres 用户授权，便于后面安装 root ALL=(ALL:ALL) ALL ansible ALL=(ALL:ALL) ALL awx ALL=(ALL:ALL) ALL # 安装 Ansible-Tower 时自动创建的用户 postgres ALL=(ALL:ALL) ALL # 安装 PostgreSQL 时自动创建的用户 # chmod u-w /etc/sudoers 2.3. 安装 Ansbile-2.7.5 相关过程整理自官方手册：https://ansible-tran.readthedocs.io/en/latest/docs/intro_installation.html#apt-ubuntu # su - ansible # 切换到 ansible 用户 $ sudo apt-get install software-properties-common # 在早期 Ubuntu 发行版中, “software-properties-common” 名为 “python-software-properties”，根据实际情况修改 $ sudo apt-add-repository ppa:ansible/ansible $ sudo apt-get update $ sudo apt-get install ansible # 安装 $ ansible --version # 若安装成功，核验版本 ansible 2.7.5 config file = /etc/ansible/ansible.cfg configured module search path = [u'/home/ansible/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules'] ansible python module location = /usr/lib/python2.7/dist-packages/ansible executable location = /usr/bin/ansible python version = 2.7.15rc1 (default, Nov 12 2018, 14:31:15) [GCC 7.3.0] 关于 Asible 的相关配置： 　　　○ 配置文件位置为 /etc/ansible/ansible.cfg 　　　○ 主机清单文件为 /etc/ansible/hosts （用于配置主机分组、连接方式等） 　　　○ playbooks 目录位置默认为 /etc/ansible/ ，若目录不存在，可手工创建 2.4. 安装 PostgreSQL-9.6 部分过程参考自CSDN：https://blog.csdn.net/zpf336/article/details/50843674 # 注意 Ubuntu 16.0 默认的 PostgreSQL 安装源是 9.5 版本的，不符合要求，需要更新安装源后再安装 $ sudo add-apt-repository \"deb http://apt.postgresql.org/pub/repos/apt/ xenial-pgdg main\" $ wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add - $ sudo apt-get update $ sudo apt-get install postgresql-9.6 # 安装完成后会自动新增数据库用户 postgres $ sudo su postgres $ psql postgres # 登录数据库 ALTER USER postgres with PASSWORD 'postgres'; # 修改 postgres 用户的数据库密码 \\q # 退出数据库 # 修改数据库配置（ 默认只允许本地连接，由于只有 Ansible-Tower 用，因此无需更改相关连接配置 ） $ vi /etc/postgresql//main/postgresql.conf # 此处的 根据实际安装的 PostgreSQL 版本修改 password_encryption = on # 去掉注释，启用密码验证登录方式 # 重启数据库使配置生效 $ sudo systemctl unmask postgresql $ sudo systemctl restart postgresql $ psql -U postgres -h 127.0.0.1 # 测试本地账密登录 CREATE USER ansible WITH PASSWORD 'ansible'; # 创建 Ansible-Tower 用的数据库用户 ansible CREATE DATABASE tower OWNER ansible; # 创建 Ansible-Tower 用的数据库 tower GRANT ALL PRIVILEGES ON DATABASE tower TO ansible; # 把 tower 库的所有权限授权给 ansible 用户 \\q # 退出数据库 # 测试使用 ansible 用户登录 tower 数据库： $ psql -U ansible -h 127.0.0.1 -d tower \\q # 可选（需图形界面支持） $ sudo apt-get install pgadmin3 # 可安装 PostgreSQL 库的图形客户端 $ pgadmin3 # 启动客户端 2.5. 安装 Ansible-Tower-3.3.3 相关过程整理自官方手册：https://docs.ansible.com/ansible-tower/latest/html/quickinstall/download_tower.html 部分过程参考自CSDN：https://blog.csdn.net/CodyGuo/article/details/78875717 在 ubuntu 系统下，Ansible-Tower 只能下载 Ansible 的 playbooks 脚本，由 Ansible 在线安装。 playbooks 脚本可从 此处 提取（目前最后的 latest 版是3.3.3）。 下载最后版本 ansible-tower-setup-latest.tar.gz 后，上传到任意目录即可。 # 上传到 ansible-tower-setup-latest.tar.gz 到 /tmp 目录 $ sudo su ansible # 切换 ansible 用户执行安装过程 $ tar xvzf ansible-tower-setup-latest.tar.gz # 解包 $ cd ansible-tower-setup- # tower_version 根据实际的 Ansible-Tower 版本号修改 $ vi inventory # 修改安装配置，根据前面流程设置的参数对号入座即可 [tower] localhost ansible_connection=local [database] [all:vars] admin_password='admin' pg_host='127.0.0.1' pg_port='5432' pg_database='tower' pg_username='ansible' pg_password='ansible' rabbitmq_username=tower rabbitmq_password='admin' rabbitmq_cookie=cookiemonster # 执行安装 $ sudo ./setup.sh 2.6. Ansible-Tower授权 安装成功后，可通过访问 https:/// 登录 Ansible-Tower （只能使用 HTTPS 协议） 登录账密在前面安装时已配置为：admin/admin （登录成功后，可以在【Users】里面修改） 登录成功后需要导入License授权，License 可以在官网申请，官方提供了 10 个管理节点的 免费 License 3. 附：被控主机为 Windows 时的额外配置 相关内容参考自： 　　　○ 官方指引手册（英文版）：https://docs.ansible.com/ansible/latest/user_guide/windows_setup.html 　　　○ 官方指引手册（中文版）：https://ansible-tran.readthedocs.io/en/latest/docs/intro_windows.html# 　　　○ 百度百家号：https://baijiahao.baidu.com/s?id=1580415145694814528&wfr=spider&for=pc 为了控制 Windows 主机，作为被控端的 Windows 必须具备以下几个条件： 操作系统版本限制为：桌面版 Windows 7、8.1、10 ；服务器版 Windows Server 2008、2012、2016 Windows上必须已经安装了 PowerShell 3.0 或更新版本 Windows上必须已经安装了 .NET Framework 4.0 或更新版本 WinRM 服务已经被创建并启动服务，相关服务端口没有被防火墙等拦截 3.1. 查看 PowerShell 与 .NET 版本并升级 运行 PowerShell （注意不是 CMD，一般 Win8 之后都默认安装） 输入命令 Get-Host 可查看当前 PowerShell 版本 输入命令 $PSVersionTable.CLRVersion 可查看当前 .NET Framework 版本 若 PowerShell 版本不满足要求，可参考 此处 的升级步骤进行升级 3.2. 安装并查看 WinRM 服务 详细安装步骤可参考 这里 为方便起见，Ansible 官方已提供了 WinRM 的自动安装与配置脚本：https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1 下载脚本后，在 PowerShell 执行命令即可完成安装： powershell.exe -ExecutionPolicy ByPass -File ConfigureRemotingForAnsible.ps1 安装完成后，输入命令 winrm enumerate winrm/config/Listener 或 winrm qc 可查看 WinRM 的服务状态 确认 WinRM 正在监听 HTTPS 5986 端口即配置成功，注意防火墙也要开放相关端口 3.3. Ansible 测试 WinRM 连接 注意，Ansible 主机必须已安装 pywinrm，相关步骤详见 这里 测试方法：修改 Ansible 主机的配置文件 /etc/ansible/hosts，在其末尾添加一行（其中 ${win_ip}、 ${win_username}、 ${win_password} 需根据实际情况修改）： ${win_ip} ansible_user=\"${win_username}\" ansible_password=\"${win_password}\" ansible_port=\"5986\" ansible_connection=\"winrm\" ansible_winrm_server_cert_validation=\"ignore\" ansible_winrm_transport=\"ssl\" 然后执行命令 ansible ${win_ip} -m win_ping 即可，若响应为 pong 则配置成功： Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 00:42:30 "},"markdown/notes/scm/Git命令行安装与使用笔记.html":{"url":"markdown/notes/scm/Git命令行安装与使用笔记.html","title":"Git 命令行安装与使用笔记","keywords":"","body":"Git命令行安装与使用笔记1. 安装环境2. Git下载3. Git安装4. 连接Github5. Git命令手册5.1. 专有名词5.2. 新建代码库5.3. 配置5.4. 增加/删除文件5.5. 代码提交5.6. 分支5.7. 标签5.8. 查看信息5.9. 远程同步5.10. 撤销5.11. 其他6. 示例：工作中使用Git的一般流程资源下载Git命令行安装与使用笔记 1. 安装环境 操作系统：Centos 7 （纯命令行环境） Git服务器：Github 安装的Git命令行版本：1.8.3.1 2. Git下载 首先需要安装git的依赖包： yum install curl curl-devel zlib-devel openssl-devel perl cpio expat-devel gettext-devel 切到安装目录： cd /usr/local Centos自带的Git版本比较旧，这里直接到官网下载最新版 ： wget http://www.codemonkey.org.uk/projects/git-snapshots/git/git-latest.tar.xz 注意下载回来的是.xz包（注意不是.gz包，我下载的时候，.gz包是0字节，可能是官方的问题），对其解压： xz -d git-latest.tar.xz tar -xvf git-latest.tar 解压出来的文件夹是 git-xxxx-xx-xx（xxxx-xx-xx是版本的日期，例如2018-07-23），切到该目录下： cd git-xxxx-xx-xx 3. Git安装 生成Git的配置脚本configure： autoconf 修改安装路径，可随意指定： ./configure --prefix=/usr/local/git 注意，若指定的安装路径不存在，则需要先预建目录： mkdir -p /usr/local/git 编译并安装： make | make install 把Git命令添加到系统环境变量，修改系统环境变量文件： vi /etc/profile 在文件最后添加以下内容： GIT_HOME=/usr/local/git PATH=$PATH:$GIT_HOME/bin export GIT_HOME PATH 重载系统环境变量使其生效： source /etc/profile 通过查看git版本号验证是否安装成功： git --version 至此Git命令行安装完成。 注： ○ 若安装时不通过 ./configure --prefix=xxx 命令指定安装路径，那么Git的可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share ○ 那么当需要卸载Git时，要么在原来的make目录下执行make uninstall（前提是make文件指定过uninstall），要么在上述目录中把相关的文件一个个手工删掉。 ○ 但若指定了安装路径，则只需直接删掉该路径文件夹即可。 4. 连接Github 配置Github的账号和邮箱： git config --global user.name \"你的Github账号\" git config --global user.email \"你的Github邮箱\" 生成该GitHub账号的SSH Keys（本质是RSA公私钥）： ssh-keygen -t rsa -C \"你的Github邮箱\" 运行该命令后，系统会确认一些问题，什么都不用输入，保持默认，连续三次回车即可。 期间系统会提示所生成的RSA公私钥保存位置（一般在~/.ssh目录）： 私钥文件位置：~/.ssh/id_rsa 公钥文件位置：~/.ssh/id_rsa.pub 私钥不要动，只需把公钥设置到Github上就可以实现连接了。 先查看公钥文件内容： cat ~/.ssh/id_rsa.pub 然后在浏览器登陆你的Github： Settings => SSH and GPG Keys => New SSH key 把公钥内容复制进去并保存即可： 注： 以后在这台Centos机器连接到Github时，就是使用这对RSA公私密钥，而不用通过Github密码，所以需要保管好这对密钥。 回到Centos，输入以下命令尝试连接到Github： ssh -T git@github.com 此时会提示以下内容，输入yes即可： The authenticity of host 'github.com (xxx.xxx.xxx.xxx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? yes 最终提示以下内容则表示连接成功： Warning: Permanently added 'github.com, xxx.xxx.xxx.xxx' (RSA) to the list of known hosts. Hi smartwen! You've successfully authenticated, but GitHub does not provide shell access. 此时随便指定一个目录并切换进去，如： cd /tmp/ 把该目录初始化为Git的代码仓库： git init 然后就可以同步Github上的项目代码（和它的整个代码历史）到本地了： git clone 项目仓库URL 5. Git命令手册 由于Centos下并不支持图形化界面（我用的是云服务器，纯命令行），因此需要熟悉Git的命令进行代码版本维护。 一般来说，日常使用只要记住下图6个命令就可以了： 但为了日后使用方便起见，此处整理一下Git的命令清单： 5.1. 专有名词 Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 5.2. 新建代码库 # 在当前目录新建一个Git代码库 git init   # 新建一个目录，将其初始化为Git代码库 git init [project-name]   # 下载一个项目和它的整个代码历史 git clone [url] 5.3. 配置 Git的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 git config --list   # 编辑Git配置文件 git config -e [--global]   # 设置提交代码时的用户信息 git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 5.4. 增加/删除文件 # 添加指定文件到暂存区 git add [file1] [file2] ...   # 添加指定目录到暂存区，包括子目录 git add [dir]   # 添加当前目录的所有文件到暂存区 git add .   # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 git add -p   # 删除工作区文件，并且将这次删除放入暂存区 git rm [file1] [file2] ...   # 停止追踪指定文件，但该文件会保留在工作区 git rm --cached [file]   # 改名文件，并且将这个改名放入暂存区 git mv [file-original] [file-renamed] 5.5. 代码提交 # 提交暂存区到仓库区 git commit -m [message]   # 提交暂存区的指定文件到仓库区 git commit [file1] [file2] ... -m [message]   # 提交工作区自上次commit之后的变化，直接到仓库区 git commit -a   # 提交时显示所有diff信息 git commit -v   # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 git commit --amend -m [message]   # 重做上一次commit，并包括指定文件的新变化 git commit --amend [file1] [file2] ... 5.6. 分支 # 列出所有本地分支 git branch   # 列出所有远程分支 git branch -r   # 列出所有本地分支和远程分支 git branch -a   # 新建一个分支，但依然停留在当前分支 git branch [branch-name]   # 新建一个分支，并切换到该分支 git checkout -b [branch]   # 新建一个分支，指向指定commit git branch [branch] [commit]   # 新建一个分支，与指定的远程分支建立追踪关系 git branch --track [branch] [remote-branch]   # 切换到指定分支，并更新工作区 git checkout [branch-name]   # 切换到上一个分支 git checkout -   # 建立追踪关系，在现有分支与指定的远程分支之间 git branch --set-upstream [branch] [remote-branch]   # 合并指定分支到当前分支 git merge [branch]   # 选择一个commit，合并进当前分支 git cherry-pick [commit]   # 删除分支 git branch -d [branch-name]   # 删除远程分支 git push origin --delete [branch-name] git branch -dr [remote/branch] 5.7. 标签 # 列出所有tag git tag   # 新建一个tag在当前commit git tag [tag]   # 新建一个tag在指定commit git tag [tag] [commit]   # 删除本地tag git tag -d [tag]   # 删除远程tag git push origin :refs/tags/[tagName]   # 查看tag信息 git show [tag]   # 提交指定tag git push [remote] [tag]   # 提交所有tag git push [remote] --tags   # 新建一个分支，指向某个tag git checkout -b [branch] [tag] 5.8. 查看信息 # 显示有变更的文件 git status   # 显示当前分支的版本历史 git log   # 显示commit历史，以及每次commit发生变更的文件 git log --stat   # 搜索提交历史，根据关键词 git log -S [keyword]   # 显示某个commit之后的所有变动，每个commit占据一行 git log [tag] HEAD --pretty=format:%s   # 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件 git log [tag] HEAD --grep feature   # 显示某个文件的版本历史，包括文件改名 git log --follow [file] git whatchanged [file]   # 显示指定文件相关的每一次diff git log -p [file]   # 显示过去5次提交 git log -5 --pretty --oneline   # 显示所有提交过的用户，按提交次数排序 git shortlog -sn   # 显示指定文件是什么人在什么时间修改过 git blame [file]   # 显示暂存区和工作区的代码差异 git diff   # 显示暂存区和上一个commit的差异 git diff --cached [file]   # 显示工作区与当前分支最新commit之间的差异 git diff HEAD   # 显示两次提交之间的差异 git diff [first-branch]...[second-branch]   # 显示今天你写了多少行代码 git diff --shortstat \"@{0 day ago}\"   # 显示某次提交的元数据和内容变化 git show [commit]   # 显示某次提交发生变化的文件 git show --name-only [commit]   # 显示某次提交时，某个文件的内容 git show [commit]:[filename]   # 显示当前分支的最近几次提交 git reflog   # 从本地master拉取代码更新当前分支：branch 一般为master git rebase [branch] 5.9. 远程同步 # 下载远程仓库的所有变动 git fetch [remote]   # 显示所有远程仓库 git remote -v   # 显示某个远程仓库的信息 git remote show [remote]   # 增加一个新的远程仓库，并命名 git remote add [shortname] [url]   # 取回远程仓库的变化，并与本地分支合并 git pull [remote] [branch]   # 上传本地指定分支到远程仓库 git push [remote] [branch]   # 强行推送当前分支到远程仓库，即使有冲突 git push [remote] --force   # 推送所有分支到远程仓库 git push [remote] --all 5.10. 撤销 # 恢复暂存区的指定文件到工作区 git checkout [file]   # 恢复某个commit的指定文件到暂存区和工作区 git checkout [commit] [file]   # 恢复暂存区的所有文件到工作区 git checkout .   # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 git reset [file]   # 重置暂存区与工作区，与上一次commit保持一致 git reset --hard   # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 git reset [commit]   # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --hard [commit]   # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 git reset --keep [commit]   # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 git revert [commit]   # 暂时将未提交的变化移除，稍后再移入 git stash git stash pop 5.11. 其他 # 生成一个可供发布的压缩包 git archive 6. 示例：工作中使用Git的一般流程 （1）下载远程代码仓库并创建分支： 　　　　git clone [远程代码仓库] 　　　　git branch [本地分支名称] （创建本地分支） 　　　　git branch （查看本地所有分支） 　　　　git checkout [本地分支名称] （切换到本地分支） （2） 写代码....... （3） 确认变更并提交： 　　　　git status （查看文件改变记录） 　　　　git diff （查看代码级改变） 　　　　git add （确认改变） 　　　　git commit -m 提交注释 （提交到当前分支的本地工作区） 　　　　git push [远程分支：origin] [本地分支的名称] （上传本地分支到远程仓库） （4） 去Git管理网站（如Github）创建Merge Request （5） 等待管理员（有选择地）合并所有人的Merge Request （6） 管理员合并后，从远程代码仓库更新本地分支： 　　　　git checkout master （切换至master） 　　　　git pull （从远程master更新至本地master） 　　　　git checkout [本地分支名称] （切换至本地分支） 　　　　git rebase master [本地分支名称] （从本地master拉取代码更新当前分支） （7） 拉取更新过程中，若有冲突的解决方法： 　　　　① 修改代码文件并解决冲突 　　　　② git add . （加入待提交） 　　　　③ git rebase --continue （继续执行前面第6步的rebase） 　　　　④ 如果仍然有冲突，重复前面①②③步骤 　　　　⑤ git rebase --skip （无法解决冲突时的处理手法1：直接用master覆盖本地分支） 　　　　⑥ git push -f origin [本地分支名称] （无法解决冲突时的处理手法2：强制用本地的代码去覆盖掉远程仓库的代码。其中origin为远程仓库名） （8） 去Git管理网站（如Github）重新创建Merge Request （9） 等待管理员合并Merge Request....... （10）重复上述对应步骤....... 资源下载 [info] 本文全文下载 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 13:24:27 "},"markdown/notes/scm/VisualSVN使用手册.html":{"url":"markdown/notes/scm/VisualSVN使用手册.html","title":"VisualSVN 使用手册","keywords":"","body":"VisualSVN 使用手册1. VisualSVN Server简介2. TortoiseSVN简介3. VisualSVN Server的安装4. VisualSVN Server的配置5. TortoiseSVN的安装6. VisualSVN Server与TortoiseSVN的基本组合使用7. 资源的同步与共享7.1. 浏览器连接SVN服务器查看和下载资源7.2. TortoiseSVN的Checkout功能导出SVN服务器资源8. Eclipse的SVN插件安装9. Eclipse与SVN服务器的连接10. 利用SVN插件进行代码的同步与共享10.1. 从SVN服务器上把代码同步到本地10.2. 把本地的代码共享到SVN服务器10.3. 本地代码与服务器代码的更新和冲突处理11. *版本控制资源下载VisualSVN 使用手册 —— By EXP 2012.02.14 第 2 次修订 1. VisualSVN Server简介 介绍VisualSVN Server之前，首先说说Subversion。 Subversion是一个自由，开源的版本控制系统。在Subversion管理下，文件和目录可以超越时空。Subversion将文件存放在中心版本库里。这个版本库很像一个普通的文件服务器，不同的是，它可以记录每一次文件和目录的修改情况。这样就可以籍此将数据恢复到以前的版本，并可以查看数据的更改细节：做了哪些修改，谁做的修改，等等。正因为如此，许多人将版本控制系统当作一种神奇的“时间机器”。 Subversion的版本库可以通过网络访问，从而使用户可以在不同的电脑上进行操作。从某种程度上来说，允许用户在各自的空间里修改和管理同一组数据可以促进团队协作。因为修改不再是单线进行（单线进行也就是必须一个一个进行），开发进度会进展迅速。此外，由于所有的工作都已版本化，也就不必担心由于错误的更改而影响软件质量—如果出现不正确的更改，只要撤销那一次更改操作即可。 某些版本控制系统本身也是软件配置管理系统（如SCM），这种系统经过精巧的设计，专门用来管理源代码树，并且具备许多与软件开发有关的特性—比如，对编程语言的支持，或者提供程序构建工具。不过Subversion并不是这样的系统。它是一个通用系统，可以管理任何类型的文件集。 VisualSVN和Subversion一样，都是版本控制器SVN的服务端，一个重要区别是VisualSVN比Subversion配置起来容易的多了。 如果直接使用Subversion，那么在Windows 系统上，要想让它随系统启动，就要封装SVN Server为Windws service，还要通过修改配置文件来控制用户权限，另外如果要想以Web方式（http协议）访问，一般还要安装配置Apache，如果是新手，岂不是很头痛？ 而VisualSVN Serve集成了Subversion和Apache，省去了以上所有的麻烦。安装的时候SVN Server已经封装为Windws service，Apache服务器的配置也只是在图像界面上，指定认证方式、访问端口等简单操作；另外，用户权限的管理也是通过图像界面来配置。 需要知道的是，VisualSVN和VisualSVN Server又有一定区别，两者虽然同是SVN的服务端，但前者是收费的，后者是免费的。 还有一点， 用VisualSVN Server所搭建的服务器仅能在局域网下工作，这是团队开发中必须要注意的，所有成员都必须在同一局域网才能进行资源的同步与共享。一旦客户机与服务机跨越了路由，便无法相连。 2. TortoiseSVN简介 TortoiseSVN 是 Subversion 版本控制系统的一个免费开源客户端，可以超越时间的管理文件和目录。 实际上安装TortoiseSVN后，它是以一种类似“右键插件”的方式存在，使用TortoiseSVN能够更方便地管理SVN服务器上的资源，在团队开发中能够更有效实时地共享所有资源。 这里使用TortoiseSVN的一个主要原因是为了使用它的一个基本功能：把代码或资源迁入SVN服务器以达到同步共享的目的。 3. VisualSVN Server的安装 先到网上下载VisualSVN Server的最新版（当前为2.1.10）。 运行 VisualSVN-Server-2.1.10.msi 安装程序后，点击Next按钮继续。 勾选“I accept the terms in the License Agreement”选择框，点击Next按钮继续下一步操作。 选择完全安装方式，点击Next按钮继续。 到这里开始要注意： “Location”为VisualSVN Server的安装目录，可任意选择。 “Repositories”为SVN代码仓库的位置，即在使用时共享资料的位置，因此基于方便使用的考虑，不建议该位置设置太深（一般在磁盘根目录下再建一层即可），否则以后使用时同步资源库不方便。 “Server Port”为服务端口选择，后面有一个选择框“Use secure connection”。不勾选该选择框为使用快速链接【http协议】，此时供选择的端口有80/81/8080三个；勾选该选择框为使用安全链接【https协议】，这时的端口只有433/8433二个可用。 一般建议选择安全链接【https协议】，即勾选选择框，端口使用默认的即可。设置完毕点击Next按钮继续下一步，然后一直到安装完成即可。 4. VisualSVN Server的配置 安装完VisualSVN Server后，运行VisualSVN Server Manger，启动界面，其中： “Status”为SVN服务器状态，包括运行状态和服务器URL地址。 “Logging”为服务器日志。 “Subversion Authentication”为账户（User和Groups）信息。 “Repositories”为SVN代码库信息。 首先添加一个代码库。右击“Repository”，出现下图所示的右键菜单，任意选择一种方式均可创建一个新的代码库。 然后在文本框中输入代码库名称。 需要注意的是，若选择框“Creat default structure”被选中，则在代码库StartKit下面会创建trunk、branches、tags三个子目录；不选中，则只创建空的代码库StartKit。点击OK按钮，代码库StartKit则创建成功。 创建完代码库后，没有任何内容在里面。添加内容的方法会在后面说明，这里暂且略过。 下面，开始创建用户Users。在左侧的Users上点击右键，出现下图所示的右键菜单，任意选择一种方式均可创建一个新的用户。 然后设置新用户的用户名和密码。输入信息后，点击OK按钮，就创建一个用户了。按照这种方式，创建4个用户：starter、Developer1、tester1、manager1。 然后把这些用户授权给刚才创建的代码库StartKit。只有被授权的用户才能使用StartKit代码库内的资源，与其他用户进行资源共享。具体方法如下： 首先右击刚才创建的代码库StartKit, 选择“Properties”，弹出如下界面： 点击\"Add...\"按钮，然后选择刚才创建的4个新用户，点击OK按钮则完成了授权工作。 注：大家可能注意到了图中的Groups。是的，我们也可以先创建组，把用户添加到各个组中，然后对组进行授权，操作比较简单，在此略过。 把用户授权给代码库后，还要继续对每个用户（或组）进行详细的权限设置： “No Access”为禁止该用户访问代码库。 “Read Only”为虽然用户可以访问代码库，但只有读资源的权限。 “Read / Write”为用户不但可以访问代码库，还能对其中的资源进行读或写。 需要注意的是，在用户列表中存在一个“Everyone”用户，为缺省用户，暂时无视之即可。 设置完权限后，点击“确定”按钮，这4个用户就具有了访问StartKit代码库的不同权限。 本例中各个用户的权限说明： 用户starter：在团队中是新来者，不希望他向代码库中提交新代码，所以他只能读取代码库中的代码，不能提交代码。 用户tester1：是测试人员，不负责代码编写，所以也是只读权限。 用户Developer1：是开发人员，自然具有读写的权限。 用户manager1：是项目经理，自然具有读写的权限。 在实际的项目开发过程中，Developer和tester往往不可能只有一个人，这时候使用组来授权会更加方便。 5. TortoiseSVN的安装 先到网上下载TortoiseSVN的最新版（当前为1.7.2）。 运行 TortoiseSVN-1.7.4.22459-x64-svn-1.7.2.msi安装程序后，点击Next按钮继续。 此时点选“I accept the terms in the License Agreement”选择框，点击Next按钮继续下一步操作。 然后选择安装目录，任意即可。设置完毕点击Next按钮继续下一步，然后一直到安装完成。 点击Finish按钮后TortoiseSVN即安装完毕，但此时可能会提示重启系统，其实不重启也没有关系。 6. VisualSVN Server与TortoiseSVN的基本组合使用 注意在使用SVN服务之前，要先确保关闭Windows防火墙，否则可能出现无法连接到SVN服务器的情况。 关闭Windows防火墙的方法是： 右击计算机 -> 属性 -> 系统和安全 -> Windows防火墙 -> 打开或关闭Windows防火墙 为方便下文说明，这里重新配置了一下VisualSVN Server： SVN资源库为CodeLib（代码库）和FileLib（文件库），其所在的位置可在VisualSVN Server启动界面查得： 用户及其权限分别为：（Everyone是缺省用户，暂无视之） CaiZhenBiao Read Only DengWeiWen Read Only LiaoQuanBin Read/Write LiJianCong Read Only 这里设置4个用户的密码均为123456。 然后说一下用TortoiseSVN把源代码迁入SVN服务器的例子。 首先在Eclipse新建项目TestSVN： 然后打开Eclipse的工作空间，可以找到项目TestSVN的文件夹，如下图： 右击要迁入SVN服务器的项目文件夹TestSVN，可以看到TortoiseSVN出现在右键选项中。若选择Setting则可进行相关的设置，这里不做详细说明。我们选择Import把项目TestSVN迁入SVN服务器。 此时弹出如下图所示的界面， URL ： https://Exp-PC/svn/CodeLib 就是当前要迁入的SVN服务器地址。其中 https://Exp-PC/ 是服务器名，svn是代码库的根目录，CodeLib就是刚才添加的代码库。 注意上图中左下角的“Include ignored files”，在第一次迁入源代码时没有用，可以不勾选。但是，在以后提交代码的时候是非常有用的。 点击OK按钮后则自动把TestSVN项目迁入了SVN服务器。迁入过程如下图所示。迁入完成后再点击OK关闭窗口。 此时在VisualSVN Server中点击CodeLib，可在右方看到刚才迁入SVN服务器的源代码（如下图），若没有显示，右键刷新即可。 注意：也可从这里的灰色条栏中看到当前代码库CodeLib的URL地址。 不难发现项目TestSVN的项目文件夹没有了，在CodeLib中只保留了其项目内容。这是因为“根文件夹默认不上传”，因此要把整个TestSVN项目（包括项目文件夹在内）都上传到SVN服务器，可以把整个项目复制到任意一个空文件夹A中，使得文件夹A作为根文件夹，再右击文件夹A进行上传。效果如下图所示。 注意：资源上传到SVN服务器的是资源的副本，因此一旦资源被上传，即使在本地删除也不会对服务器中的资源有任何影响。 7. 资源的同步与共享 第6节介绍了如何利用TortoiseSVN把源代码上传到SVN服务器，其实上传非代码的其他资源也是同样的方法，把所需上传的资源（如Word、Excel、*.rar等）放在文件夹内，右键Import即可。同样要注意的是“根文件夹默认不上传”。 本节主要介绍怎样读取已上传到SVN服务器的指定资源的方法，主要有三种： （1）浏览器连接SVN服务器查看和下载资源； （2）TortoiseSVN的Checkout功能导出SVN服务器资源； （3）Eclipse连接SVN服务器查看和导出资源。 方法（3）要在Eclipse安装SVN插件后（见第8节）才能使用，这将在第9节和第10节介绍。所以在本节中主要介绍方法（1）和方法（2）。 7.1. 浏览器连接SVN服务器查看和下载资源 要通过浏览器连接SVN服务器，首先需要获取SVN服务器的URL地址，URL地址的获取方法如下图所示： 打开VisualSVN Server界面，右击想要连接的代码库CodeLib，点选“Copy URL to Clipboard”即把代码库的URL复制到剪贴板。 然后把URL黏贴到浏览器地址栏回车即可。 注意：部分浏览器可能会拦截，如火狐浏览器可能会出现下图的警告。此时点击“我已充分了解可能的风险”，然后点击“添加例外”，“确认安全例外”即可。 同时请确认windows防火墙已关闭。 　　其他浏览器也是类似的信任安全操作。 通过浏览器拦截后，会弹出身份认证窗口。此时只需要把刚才在VisualSVN Server中设置的4个用户之中的一个账号密码输入即可。然后浏览器就会反馈出当前SVN服务器所保有的资源。 下载界面如下： 7.2. TortoiseSVN的Checkout功能导出SVN服务器资源 在任意空白位置点击鼠标右键，在弹出的功能菜单中选择“SVN Checkout”。 如上图所示（下述的“检出”实质就是把SVN服务器上的资源复制一份副本到本地）： “URL of repository”为要检出资源的SVN资源库地址。 “Checkout directory”为要检出到的位置，可自由选择。 “Checkout Depth”为检出资源的深度，默认为把整个数据库的资源都检出。若要指定检出的项目，可点击“Choose item”按钮进行选择，只勾选需要检出的资源，然后点选OK按钮。 “Revision”为版本控制选项，功能很重要，将在第11节叙述相关作用。 “Show log”为显示被选中的服务器的操作日志。 如上图为检出过程。 如下图为检出后的资源文件。其中左下角的Icon若为“绿色√”说明本地资源与服务器资源一致。当本地资源被修改后，“绿色√”变成“红色！”，说明本地资源与服务器资源不一致。 而关联本地与服务器资源一致性的功能由“.svn”文件夹实现，该文件夹默认为隐藏。当删除“.svn”文件夹后本地与服务器断开连接，Icon消失。 8. Eclipse的SVN插件安装 首先安装Eclipse关于SVN的插件。这里使用Eclipse在线安装插件的方法。 Google搜索“SVN Eclipse插件”即可很容易找到SVN插件的安装地址，当前的安装地址为：http://subclipse.tigris.org/update_1.6.x。 然后打开Eclipse -> Help -> Install New Software。 把地址http://subclipse.tigris.org/update_1.6.x复制到“Work with”下按回车，等待加载如下图的3个插件，点击 “Select all”按钮选中全部，然后点击Next按钮执行下一步，按提示操作即可完成安装。可能安装的时间较漫长，请耐心等待。 9. Eclipse与SVN服务器的连接 安装SVN插件后，找到Eclipse左下角的“+”（快速视图菜单），再点击打开快速视图菜单，选择Other。在弹出的界面中输入“SVN”，点选搜索到的“SVN资源库”，点击OK按钮确认。 此时会出现SVN资源库窗口（如下图）。在空白处右击，选择“新建”，在点选“资源库位置”。然后在弹出的窗口输入SVN服务器的地址，这里使用前面创建的代码库的URL地址：https://Exp-PC/svn/CodeLib 。地址无误则点击Finish按钮确定。 此时会弹出如下图所示的对话框，选择“永久接受”，然后输入用户名和密码。这里必须使用授权给当前正在同步的SVN资源库的用户。 前面第6节中，配置给CodeLib代码库的用户有4个，这里选择其中的一个即可，为避免以后再输入账户密码，可选择“保存密码”。 此时已经可以看到SVN服务器上的代码库，展开则可看到保存在SVN服务器的资源。 10. 利用SVN插件进行代码的同步与共享 10.1. 从SVN服务器上把代码同步到本地 打开Eclipse的“SVN资源库”，找到要下载的源代码项目，右击该项目的根文件夹，选择“检出为”则可把服务器上的项目同步到本地。 如上图所示，检出时会提示命名项目名称，任意命名均可（只要与本地已有项目不重名）。命名完毕后直接按Finish按钮。 此时返回本地Project目录，即可看到刚才从SVN服务器同步下来的TestSVN项目。 如下图所示，从服务器上同步到本地的项目，可以在左边项目列表看到该源代码的来源，以及最后被更新的时间和用户信息。 10.2. 把本地的代码共享到SVN服务器 新建项目TestSVNUpdata，右击项目文件夹，选择Teamshare project在弹出的界面中选择“SVN”，点击Next按钮继续。 如下图所示，选择“使用已有资源库位置”，然后在资源库地址列表中点选要上传的SVN服务器，点击Next按钮继续下一步。若资源库地址列表为空，则选择“创建新的资源库的位置”，输入要上传的SVN服务器的URL地址即可。 到这步选择“使用项目名做为文件夹名”，点Finish后自动切换到Synchronize标签，其中Synchronize显示的是为等待同步到服务器的项目，这里只有项目TestSVNUpdata可供选择。右击TestSVNUpdata项目文件夹，选择“提交”。 然后弹出下图的界面，勾选全部，点击OK按钮。 切换回到“SVN资源库”标签，右击刚才所上传到的SVN资源库，选择“刷新”，则可看到刚才上传的项目，上传成功。 10.3. 本地代码与服务器代码的更新和冲突处理 在说明更新和冲突处理之前，先解释一下各种SVN图标含义。 当本地的项目是从SVN服务器上更新下来的时候，若本地或SVN服务器的代码有被修改过，则当进行如此操作时：在“Project Explorer”标签的本地项目上点击右键 Team 与资源库同步（“与资源库同步”仅是在本地和服务器进行比对，暂时并不会使得本地或服务器代码有任何改变）。 这时会在“Synchronize”标签中列出本地与SVN服务器上不一致的文件列表。文件列表中各个文件的右方会根据不同的情况出现不同的Icon（即SVN图标），它们的含义分别为： 灰色向右箭头：本地修改过； 蓝色向左箭头：SVN上修改过； 灰色向右且中间有个加号的箭头：本地比SVN上多出的文件； 蓝色向左且中间有个加号的箭头：SVN上比本地多出的文件； 灰色向右且中间有个减号的箭头：本地删除了而SVN上未删除的文件； 蓝色向左且中间有个减号的箭头：SVN上删除了而本地未删除的文件； 红色双向箭头：SVN上修改过,本地也修改过的文件。 10.3.1. 更新处理 更新主要有两种操作形式： （1）从本地提交到服务器； （2）从服务器覆盖/更新到本地。 前者主要用于开发进度的更新，后者主要用于从服务器的备份恢复本地错误。两种操作都比较简单，在核对完本地和服务器代码后，只需在“Synchronize”标签中选中需要更新的文件（或文件夹），然后点击右击，找到“Team”，此时选择“提交”则是进行操作（1），选择“覆盖/更新”则是进行操作（2）。具体要进行哪种操作应该视情况而定，这里不再详细说明。 10.3.2. 冲突处理 产生冲突的原因很多，最普遍的一个原因就是：假设服务器上有源代码x，开发者A从服务器上复制了x的副本x1到本地Ax进行开发，开发者B从服务器上复制了x的副本x2到本地Bx进行开发。 当开发者A首先完成了他的开发任务时，此时其本地Ax的源代码就是x1*，当他x1*提交到服务器上后，服务器的源代码就被更新为x1*。 此后开发者B也完成了它的开发任务，此时其本地Bx的源代码就是x2*，当他试图把x2*提交到服务器上时，就出现了冲突。因为此时服务器的代码不再是x，而是被A修改过的x1*。x1*中不但有A增加的代码，原本x中还可能有被A删改过的地方。 此时B要提交代码x2*，就必须根据服务器的代码x1*先把x2*进行恰当的修改，使得修改后的x2**不但包含B的开发部分，还比包含A开发的x1*部分。 如下图所示为产生冲突的一种情况，Eclipse的SVN插件自动指出了本地与服务器不同或冲突的部分，B就能根据这些提示在本地进行修改再提交。结合下图在本地进行如下修改： （a）本地第6行由于是在本地被无故修改的，因此根据服务器进行恢复 （b）本地第8行需要保留，因此不修改 （c）服务器第8行需要被保留，因此复制到本地 （d）服务器第10行不需要保留，因此不复制到本地 （e）服务器第12行需要保留，复制到本地 （f）本地第10行不需要保留，删除 修改后如下图所示，此时冲突已解决，本地保存后，右击代码文件 -> Team -> 提交，即可更新到服务器。 11. *版本控制 版本控制已在第7.2节介绍TortoiseSVN的Checkout功能时粗略提及过，本节将详细介绍如何利用Eclipse的SVN插件进行版本控制。TortoiseSVN的版本控制原理雷同，因此不再详细介绍，读者可自行摸索。 　　以下为示例。 如下图所示，首先在Eclipse建立一个新的本地项目“版本控制测试”。 然后把该项目上传到SVN服务器：右击项目文件夹 -> Team -> Share project。 然后按下图依次进行操作。 到这步为止，为当前提交到服务器的项目在“编辑提交注释”一栏中填写版本信息。这步很重要，是作为以后版本控制的依据。 填写完版本信息后，点击Finish按钮，自动跳转到“Synchronize”标签（同步标签），在同步列表中出现等待同步到服务器的项目。右击“版本控制测试”项目的文件夹，选择“提交”，然后按提示操作即可把“版本控制测试”项目连同其版本信息写入SVN服务器。 注意：若提交对话框的注释栏为空，请重新填写版本信息，也可利用下拉选择。 此时SVN服务器上只有“版本控制测试”项目的1.0版本。 现在回到本地，现在对本地的“版本控制测试”项目进行修改： 然后右击项目文件夹，选择“Team”，选择“与资源库同步”。自动跳转到“Synchronize”标签（同步标签）。右击“版本控制测试”项目的文件夹，选择“提交”。在出现的提交界面中填写新的版本号。 确认上传后，现在SVN服务器已经有了“版本测试控制”项目的1.0版本和2.0版本。虽然在SVN资源库中依然只有一个“版本测试控制”项目，这是因为SVN资源库默认是显示项目的最新版本。 注意此时服务器上有两个版本1.0和2.0，而本地上只有最新的版本2.0。 下面我们试图把本地的版本恢复到1.0： 在资源库中右击“版本控制测试”，选择“检出为”。 可以看到“Check out HEAD revision”默认是被勾选的，表示从服务器检出最新版本（当前为2.0）的项目到本地。 “Depth”为检出深度，默认为选中的整个资源文件，按需设置，这里为默认值。 “Check out HEAD revision”下方有“Revision”，这里是填写希望检出的版本号，这里先不急着填，先点击“显示日志”。 如上面几张图所示，可以看到点击“显示日志”后，出现了关于项目“版本控制测试”的修改日志列表，日志列表下方对应的是当前被选中的版本号的详细修改信息。但是出现了两个“最初版本1.0”和一个“版本2.0”。现在希望把本地项目恢复到1.0版本，应该选择哪个呢？ 不难发现，最底下的“最初版本1.0”的修改信息只有1个空文件夹，那是之前我们把项目第一次同步到服务器时产生的：我们实际上分开了两步上传，先在服务器创建了项目文件夹，然后再上传项目文件，而这两次操作我们都编写了同一个版本号信息，因此会出现这种情况。 而中间的“最初版本1.0”的修改信息则是整个项目的内容，那么显然现在我们要恢复到的是中间的“最初版本1.0”，即修订号为85的版本。 至于“版本2.0”的修改信息只有“VersionTest.java”一个文件，这也是因为我们只对这个文件做了修改的缘故。 现在我们选择“最初版本1.0”（修订号为85）的版本，点击OK按钮。自动返回到检出界面，而“Check out HEAD revision”已不再被勾选，“Revision”一栏自动被填写了对应修订号85。点击Finish按钮，提示覆盖本地项目，点击OK按钮即可。 返回本地项目查看，已被恢复至1.0版本（如下图）。 类似地，现在也可以从服务器中把最新的版本2.0重新检出到本地，方法一样，具体步骤不再阐明。 资源下载 [info] 本文全文下载 配套PPT讲义下载 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 15:10:53 "},"markdown/notes/arch/":{"url":"markdown/notes/arch/","title":"系统架构","keywords":"","body":"系统架构系统架构 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/resource/":{"url":"markdown/resource/","title":"资源分享","keywords":"","body":"资源资源 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 12:35:37 "},"markdown/feelings/":{"url":"markdown/feelings/","title":"心路历程","keywords":"","body":"心路历程心路历程 半杯水 一位ACMer过来人的心得 你难道没收到我的邮件？ 找BUG记 请还我安静的4小时 别让你的能力成为绊脚石 我们需要的，是测试而非重构 月缺，梦圆。 请发展你的惰性 优雅的烂代码 程序员的\"病态\" 工作需要经营 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:27:19 "},"markdown/feelings/半杯水.html":{"url":"markdown/feelings/半杯水.html","title":"半杯水","keywords":"","body":"半杯水这应该算是引子分节目录苦逼程序猿，劳模运维狮你需要K.I.S.S掌控你的资源能力与方法囚徒困境人的核心竞争力书写是为了更好地思考半杯水 [info] 读 《暗时间》 有感 这应该算是引子 半杯水 —— 思如杯，技如水，技盈则满，思盈则空。虚而不满，似无物，可容万物。 有一个辩题为「能力和思维哪个更重要」。我不选边站，「学而不思则惘，思而不学则怠」，物极必反是亘古之理。只是现在社会的竞争过大，很多人为了眼下的生活，都过份追求自身能力的发展，而忽略了不时反思自身的那份态度。 我之前问过一个海纳百川的朋友：「你什么新技能都去试，也不想想学得多而不精有什么用？」 于是他告诉我，这样才能在短时间内让上司知道自己有什么变化，而且新东西可以显得自己与众不同。 我想说，其实如果你可以坚持每天不穿衣服去上班，也是可以起到同样效果的…… 同理，我也不认为一味思考人生就会变得很好，当然如果你想成为下一个「深井冰」，那就另当别论了。 其实辩题不应该是哪个更重要，因为都重要。关键是如何在两者之间寻求平衡，保持半杯水的「状态」 —— 但我更倾向于认为这是种互补的「心态」：不过分依赖能力、也不过分依赖思考，不过分依赖自己、也不过分依赖他人，为身边的一切寻求互补，不卑不亢，聪明地做事。 分节目录 - - ● 苦逼程序猿，劳模运维狮 —— 工作怪圈 ● 你需要K.I.S.S —— 跳出怪圈（程序猿篇） ● 掌控你的资源 —— 跳出怪圈（运维狮篇） ● 能力与方法 —— 正确地使用你的能力 ● 囚徒困境 —— 别宅了，抱团吧 ● 人的核心竞争力 —— 技能不是万能 ● 书写是为了更好地思考 —— 你的思维需要降速 苦逼程序猿，劳模运维狮 对程序猿而言，「重构」永远是最大的课题。 程序猿最困扰的，莫过于总要面对一堆乱七八糟的历史代码 —— 历史代码其本身可能并不混乱，只是经手的人多了，面目全非罢了。从心理上看，一份代码越混乱，对于维护结果抱着「无所谓」的心态越明显。但不负责任的恶性维护，尽头只能是重构，而即使重构了，却也只是新循环的开始。 而对于运维狮，「自动」应是他们最终所追求的幻想。 运维狮的工作核心基本无一例外的就是要面对大量的机器、大量的程序副本、不知何时会崩坏的线程，还要时常排查天文数字一样的监控数据，到头来却不知道自己究竟在维护什么。 即使渴望可以自动化完成这一切，但「羊群效应」却使得大多数运维狮无意识地从众，因为有安全感的，尤其所面对的东西是未知的时候 —— 既然已经有那么多非自动化部署的程序 …… 于是又手动拷贝了一份程序副本。 我们总是在嘲笑历史上的别人留下一堆麻烦，历史却总是惊人的相似 —— 因为我们在抱怨别人的烂摊子的同时，一边给别人制造烂摊子却不自知。若始终不肯抛弃「自我感觉良好」的心态，所有人都只能苦逼地活在别人制造的圈子里，然后成为别人嘲笑的劳模。这个循环是时候结束了。 你需要K.I.S.S 首先要声明的是，不要理会别人的维护质量有多烂，从自身做起，保持良好的心态，负责任地维护每一份代码才是一个程序猿应有的职业素质。 但是总有一些代码经过历史不断的修补而变得过于复杂，复杂到我们宁愿放弃80%的功能（这并不是确切的划分，只是我深受二八定律影响罢了）去重构一份简洁的代码 —— 当然如果还有保有我们所需要的那些功能就更好了。 良好的开端比什么都重要。程序猿觉得代码维护困难，根本原因在于程序设计阶段没有做好。所以无论如何，只要你一下定决心要重构，请务必由始至终把K.I.S.S原则铭记在心。K.I.S.S，即「Keep it simple,stupid!」，直译过来就是「保持简单，傻瓜」。确实，把程序复杂化无助于性能和资源的管控，也使得后续的使用和维护更加困难。 有一条程序猿悖论如是说：「程序猿的工作效率并不会随着资历的增加而有显著提高」。究其原因，年轻的程序猿会耗费大量的工作时间去敲写几万行代码以体现能力；而老程序猿更倾向于在深入思考后再写出几百行代码以体现质量，即使偶尔花了大量时间在写代码上，一般也只是为了这几百行代码找到最优的组合而已。 这是因为所有老程序猿都明白，华而不实的工作能力，只会使我们的工作变得更加困难。只有简单才是美，为了简单我们不惜付出任何代价。 掌控你的资源 相对于程序猿，运维狮没有推翻一切重来的「重构」手段，因此需要的更多是务实的精神，但务实不等同于蛮干，技巧也很重要。一个合格的运维狮应该思考的不是「能做多少」，而是「如何做得最少」。 如果你觉得维护工作开始变得困难，或者已经很困难，就需要审视自己是否有正确利用身边的资源以提高自身的工作效率和质量。不要奢望「自家的」程序猿什么时候能提供自动化的程序使你的工作变得轻松，关注第三方的运维工具并利用起来才是王道，毕竟现在的社会，什么东西都是「别人家的」更好啊。 有一条成功的箴言如是说：「要看一个人是否成功，看他晚上8点之后在干什么」。其实也是很浅显的道理，白天谋生、晚上谋事。作为运维狮，虽然少有晚上时间，但闲下来的时候必须学会充实自己。如果你还在迷茫应该学习什么，或者我能够为你指两个方向： 掌握shell/sed/awk三剑客编程：学会编写定制化的脚本 掌握自动化部署工具ansible：用程序生成程序、而不是手工复制 特别一提的是，不少运维狮容易受工作内容所限，生疏于编程语言、甚至不懂编程语言。其实不妨走出自己的圈子，学习一些编程语言，打通前后端，更有利于自身的工作。在维护出现问题的程序的时候，「知道用什么方法解决」和「知道为什么可以这样解决」是两种截然不同的境界。 这里说一个题外话，我在协助现场维护工作的时候，发现运维狮和用户之间总有争取硬件资源的矛盾。所谓「宁花机器一分，不费程序员一秒」，程序量提高了，用户却迟迟不肯放宽硬件资源，很多时候可能是没有看到有力的「证据」。如果能够做到常态化监控，并把性能数据持续集成健康的报表，对用户透明化，或许争取资源会更容易，这也是一种做事手段。 能力与方法 [info] 「如果你手里有一把锤子，所有东西看上去都像钉子」。 —— 这不是我说的。 往往我们可能花费了大量时间去学习一项技能，而学无所用是所有人最不愿意发生的事情。于是我们就会尝试在各个方面炫耀这项新技能，而不管它是否适用。 在我学习设计模式之初，就陷入了这种状态，几乎不能自拔。确实，设计模式为我打开了一扇大门，我首次知道原来代码也可以写得如此优美，使得我迫不及待地寻找可以应用它们的项目，哪怕只有一点可以用得上。但牵强附会总是没有好结果的。 再如我现在所参与的技术框架开发，虽然一些工具组件已经被成功推广起来了，但一些工具组件却依然不为人所知。不是说这些组件没有技术性，究其原因也是适用性问题。所谓的工具是为了提高开发效率才被制造出来的，而很多同事就投诉说，为了使用一个工具必须注意这注意那，还要配置一堆有的没的东西，甚至还可能与业务逻辑不兼容，如此复杂还不如自己实现。于是他们真的选择了抛弃这些工具。 所以其实正确的做事态度应该是：「如果你想钉一个钉子，所有东西看上去都像是锤子」。 即我们在处理问题时，优先考虑的是要做什么What，而不是怎么做How。只有先明确目的，才去选择合适的工具，而不是拿着一把工具对所有事情都勉而为之。正确而有效率地做事，谨记以下几点，受用无穷： 方向比努力更重要：莫要南辕北辙 流程比修补更重要：无规矩不成方圆 方法比拼命更重要：事半功倍 囚徒困境 在信息时代，「大鱼吃小鱼」已成为过去，如今是「快鱼吃慢鱼」。但如何能够「快」？在软件开发中，如果单凭一个人在闭关修炼技术，无论学习能力多么像海绵，也不可能短时间内海纳百川，又如何能快得起来？其实这也恰好说明你开始需要一个团队了 —— 为了综合实力，取长补短。 软件开发的本质就是一项团队运动，人与人的因素对结果的影响完全不亚于技术因素。一个项目成功的关键不仅仅是写出漂亮的代码，团队中的所有人朝着同一个目标一起合作也是同样重要的。但团队工作经常遇到的问题，就是沟通问题，我遇到的主要有两种情况：不愿意沟通，或无法正确表达自己想法。 举一个博弈中的著名栗子，「囚徒困境」。大概是描述这样的一个问题：两个疑犯被隔离审讯，由于证据不足，若两个都抵赖则均判1年，两个都坦白则均判8年，一个坦白一个抵赖则坦白的释放、抵赖判10年。 从整体利益上考量，最优的方案是两者均抵赖。但由于两个疑犯不知对方所想，在对方可能会抵赖的怀疑下，局限于自身利益进行判断，都会选择坦白，以保证自身利益最大化。 囚徒困境也是在团队工作中，缺乏沟通或沟通不当的必然结果。所谓的团队任务，就是要每个人承担一块工作，分别完成后再整合。如果都只从自身角度做考量而不顾他人，即使自己工作得非常出色，但最终却无法与他人的工作完成整合，那么也只是在做无用功。 只有通过不断的沟通、磨合，才可能保证整体的利益最大化，一盘散沙，终难成事。所谓「要学做事，先学做人」，时刻谨记我们都只是半杯水：内修本领、追求极致，固然重要；外联朋志、寻求互补，方是王道 —— 抱团取暖 = 力量大。 人的核心竞争力 前面讲述的都是一些现实性的东西，那些确实都是我们用来竞争的实质性资本。但毕竟随着工作的更替，很多东西也就过时了。而不过时的只有思考的方式，或者说只有思考才真正是我们作为人的不可替代的核心竞争力。 下面这些是我平时或蒐集、或所悟的「箴言」，既然是分享，我就不要脸地「借鉴」过来了。有时这些看似与技能毫无关系的东西，可能恰好就在某个转折点决定了人生，所以都参考着看一下吧： 万事先修德，养性必制怒。 广交朋友并为他们做事情。 多参与社区活动，积极分享，锻炼口才。 锻炼身体，笑到最后得有一副好身体。 反思是让人得以改进自己的最重要的思维品质。 「教」是最好的「学」。 我们都是半杯水，正是这样人生才有意义，不卑不亢，寻找互补。 人生就是一场修行，人必自助而天助之。 读书，尤其是读那些非实用性的书（如心理学等）。 潜心一到两项业余爱好，参与一些艺术活动。 不断寻找偷懒的方法，聪明地工作。 越努力，越幸运。 与智者交谈，思考，并常做笔记。 犯错趁早，防微杜渐。 因上努力，果上求缘。 书写是为了更好地思考 最后，这是一个我自身的一个小故事。 —— 一个我成为「作家（虚伪的）」之前的故事。 以前我们读书的时候，每天的工作就是写。而现在工作了，扪心自问，又还有谁拿起过笔？恐怕都差不多执笔忘字了吧。 那为什么我们需要书写？ 众所周知，物理上速度的极限是光速。但撇开物理不谈，比光速更快的，则是人的思维 —— 因为光从地球到火星都需要400秒，而人想一下就到了。 这不是脑筋急转弯，大部分人应该有过这样的经历：在思考一个问题很久却不得果时，都会试着问一下别人的想法。但当我们把问题描述一次给对方的时候，对方还没做出回答，我们就突然「想通」了。 这是因为，我们在思考问题的时候，往往已经想明白了各个细节要如何解决，但由于思维速度过快、跳跃性太大，在想细节A的时候、忘记了细节B，想B的时候又忘记了A，从而引起「想不透」或「总觉得哪里不对」的假象。 而通过文字将问题重新描述一次，实际上就是一个将思考「降速」并「梳理」的过程。因此如果一直想不透一个问题，不妨用笔将其写下来，往往问题就迎刃而解了。有时可能还会因此有意外的收获。 以上。 所以.... 所以我好像丝毫没有提到那个故事，这是因为我知道你们不会想看的。 但其实你已经猜到那个故事了 —— 所以大家都积极地写一点东西去记录自己的点点滴滴吧！ 或许一开始你可能会纠结怎样可以写出令人眼前一亮的东西，但当你意识到这可以让你更好地思考的时候，你就会摒弃这种纠结。当你慢慢习惯怎样用文字去描述你的想法时，所谓「思如泉涌」也不过如是罢了。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:41:20 "},"markdown/feelings/一位ACMer过来人的心得.html":{"url":"markdown/feelings/一位ACMer过来人的心得.html","title":"一位ACMer过来人的心得","keywords":"","body":"【转】一位ACMer过来人的心得算法学习是ACM比赛所要推广或者要提倡的一个方面用模板是不好的需要深入学习独立思考做有意义的题估算好某种训练所需要的时间有关训练的度【转】一位ACMer过来人的心得 刻苦的训练我打算最后稍微提一下。主要说后者：什么是有效地训练？ 我想说下我的理解。 很多ACMer入门的时候，都被告知：要多做题，做个500多道就变牛了。其实，这既不是充分条件、也不会是必要条件。 我觉得一般情况下，对于我们普通学校的大学生，各方面能力的差距不会太大，在这种情况下，训练和学习的方法尤为重要。 其实，500题仅仅是一个标志，而且仅仅表示你做 ACM-ICPC 有一定的时间。 我们训练的目的是什么？我觉得有四点： 提高编程能力 学习算法（读书，读论文，包括做一些题目验证） 准备好面临将到来的挑战（熟悉题型，调整心态） 启发思维 这里四个目的，从训练的角度上，重要性逐次递减；为什么呢？ 因为前面的因素是后面的基础。而是后面的目的，想达成越为不易。我觉得前3者能保证你ac掉你能做的题，即使难题始终不会做，也可以ac掉中等偏难的题目。 而需要一定思维难度的题，要以前三者为基础而且属于训练的后期，中期只能作为偶尔调节。当然，我思维也烂得要死，对这点没什么发言权，大家可以鄙视我。 我这里想主要说下第2点。 对于算法，我发现，很多我们这样的弱校ACMer选手没有侧重好算法的学习。 下面要讲的几点，可能都很老套，但我想以035对比我自己的例子给大家做说明。 算法学习是ACM比赛所要推广或者要提倡的一个方面 记得曾经路过某人的blog，上面说他作比赛的时候遇到了一个dijkstra，他没做出来，然后评论到（大意）：我才不会花时间去搞明白“这种”算法。 “这种”也许有可能是指：没什么实用性，对吧，这样我就不想评论了（又是有关科学和工程的讨论）。但起码有一点需要明确的：ACM-ICPC比赛时关于计算机科学的比赛，计算机科学是算法的科学，计算机算法中dijkstra有着重要的实际和启发意义，所以比赛一定要考。 你参加这个比赛，要拿奖，就必须学习这种算法。你也许觉得你智商很高，但ACM-ICPC比赛本身不是智力比赛，比赛就是要让你去学习这些东西，所以，如果你不想学的话，我觉得也没有必要参加。说道这，可能偏题有点远，但是希望以上的分析能得出这样一个基础结论：不想学好算法，那没有必要来比赛。 用模板是不好的 现在很多我们弱校的ACM-ICPC选手比较依赖模板，说实话，我也很依赖，但是我起码知道一点，这样是不对的，某种意义上说，这是你没有把算法学明白的一种表现。而且也严重影响编码速度。在我见过的huicpc035参加过的比赛中，他从来没有看过模板，全部现场敲，有一次比赛有个图强连通分量+缩点+染色+什么的题去了，我在他们机房做，我则抄模板，结果总共敲了1个半小时，而035明确算法之后，啪啦啪啦，估计30多分钟就敲完了。这里顺便八卦一下他：我和kevin以前去湖大集训队玩的时候，给他取了个外号——打字猛男（他应该还不知道）。因为他敲键盘的声音特别大特别快，呵呵。 我觉得他敲代码的时间没有浪费，某牛曾说：因为每次敲都有可能有不同的错误，所以不用模板是好习惯。我最开始学dancing link的的时候，自己敲出了代码，然后接下来的几道题部分参考了以前的代码，后来基本上是直接copy。现在，当别人问我dancing link算法或有关的题目的时候，我已经是一脸茫然。 所以，用模板是不好的，有时候由于某些原因可能你用了模板，但你起码要知道这要做是不对的，并且有机会要改正。 需要深入学习 像 ACRush、zzy、ahyangyi...等等国家队的天才们，本身难以说我们与他们之间有什么可比性。但是他们的学习方法应该还是值得借鉴的，他们的学习方法当然我们得不到言传身教，但是从他们在国家队集训的论文中和他们搞完ACM-ICPC以后的轨迹中，可以有所体现。那就是：深入学习。 其实这点我来讲可能还是不够有力，因为我这方面也很欠缺，我尽量说下我的想法。 首先，觉得ACMer学算法不应停留在看看代码实现这个层面，在算法思想上要有清醒的认识，在正确性分析上要也应该要有较好的逻辑。因为网上的代码的实现上的一些细枝末节很可能掩盖了算法本身有的简洁性、美感和思想。因而丧失了对算法整体上的一些认识。还拿dijkstra算法打比方，有些算法不是基于 dijskstra的直接建模，而是需要你修改这个算法，这时你对算法没有真正理解的话，也就一筹莫展了。 我为什么老说Dijkstra算法，因为确实很多人都只知道用模板，而且模板还不好，在我看到的Dijkstra实现中，只有czyuan_acm的代码写得好。不是说其他的不对，但确实是有问题，投机取巧了的。 所以，要阅读论文和书籍，尤其与英文书籍，窥到它的本质。另一方面，只有这样，你学的的东西才能在ACM-ICPC以外，给你一定的启发——否则你会迅速忘掉它的。 据我所知，035起码阅读了几十篇集训队论文，orzorzorz，而且切掉了例题。 独立思考 这点我也很惭愧，因为我也是缺乏独立思考的。很多题我不会了就去搜解题报告，所以反而我的搜资料能力变得特别强。035和许多大牛在这点上做的比我好多了，他们遇到题不会的时候，也不会很急于把题目做出来，可能每隔一段时间又拿出来想一次，总有一天想通了，之后这一类型的题目基本上也就没有什么问题了。 而我恰恰比较“虚荣”，做到的题目不会不太愿意想太久，就想尽量快些AC，于是急于看解题报告，这样导致的一个问题就是有些重要的东西解题报告中没有提到，而我也没去想就把他们忽略了，这样，我还是不会做。我和035讨论问题的时候，我不会一般就直接找他要代码，但是他不懂的时候，顶多问我大体的思路，而绝对不会要代码的。 在去年ACM赛区尾声的时候，我发现035做中难题的能力已经明显超过我一个档次。看他现在做的题目，已然是相当变态，几乎是都100以下人ac，这些题目我看了基本上没什么想法，更要命的时，解题报告也搜不到。035目前的状态让我想起一个人，不知道大家知道不：wangfangbob，他切bt题的能力也是令人汗颜的。 做有意义的题 不要做水题，这里的水题定义为：一眼就能看出做法，而且中途的实现可以预计没有太多问题的题目。 做能够强化你最近学到的东西的题目 你不会但你应该会的题目 这同时也是在说，某些没太多代表性的题目可以少做，因为对比赛帮助不大。（当然我这个参加比赛的目的很功利，非功利主义者另当别论）刚才，我把我在poj上的号和他的号对比了下，他ac而我没ac的基本上是难题，我ac他没ac的一般是水题，看得我想哭，5555。 补充一点：ac的人多的并不一定代表着水题，有些几千人ac的题目，在现场赛中ac的人很少，这样的题目往往是有一定思维难度且编码不难的好题，这种题目要认真做，某个学长说：经典的题目啊，只有那么多，做一道，就少一道。 估算好某种训练所需要的时间 我觉得我学网络流就是一个例子，我在大概赛区赛之前2个月开始学习网络流，1个月前开始学习费用流，但是对于我来讲，这两个月培养出来的网络流思维还是不够（虽然也做了不少题），特别是，这种题目往往作为中难的题目出现，不会让你随便水的，于是，北京赛区的那道网络流当时就没有想出来——功利地说，学习网络流没有得到好的效果。 所以，现在来看，当时其实我可以不搞网络流。如果要学一种比较有难度的东西，并且还必须把他搞好，应该较早地，全面地学习，必须长期的训练以培养这种思维。打个比方，如果你微积分平时不学，仅仅考试前一周狂做题目，我觉得上90分是很困难的。 当然，这要根据个人情况而定，我的理解能力应该说是中等水平，如果牛的话应该可以更快地学好。 有关训练的度 我有时候通宵刷体，这里我不知道huicpc035有没有这个习惯，不过我通宵的时候没见到他通宵。 我觉得其实通宵刷体，或者太长时间地做题，还是不好的。我们为什么会这样有热情的做题呢，因为我们有兴趣；但是一个人的成功不仅仅依赖于兴趣，还要依赖于自控。这和打游戏是一个道理，游戏太有趣以至于我们常常通宵——ICPC题目也太有趣，所以有时候通宵。而且很多时候是，由于一道题AC不掉，所以赌气一定要搞定才睡觉，这样一不小心，就通宵了。 其实我明白，通宵不一定效果好，这仅仅说明了你兴趣很高涨而已。通宵往往会打乱你的时间安排，打乱你的生物钟，进而影响你短期或是中期的训练计划。而且，疲惫的状态下做题，你往往只有ac题目的欲望，而完全丧失了ac题目的灵气。所以，我建议，ACMer一定要合理安排作息，能够自控，这样不仅仅对你做 ACM-ICPC有好处。 总之，有效训练是很重要，只有通过有效的训练你才能获得你参加这个比赛应得的东西。 还有就是，除了035以外，另一个值得大家学习的就是richardxx——我也很佩服，我并不觉得他是天才，我觉得他以全方位的努力让他自己变得优秀，大家看他的blog可以看到他的学习历程。 最后要说下刻苦训练这一点，这个我主要想说给我们学校的acm队员： 客观的说，我们学校很多名校落榜生（我相比而言是水进的）。确实都蛮聪明的，但再聪明也比不上ACRush吧？人家可是SGU都切满了！ACM不是智力测试，不是你什么都不做就可以天上掉馅饼的。当然我不是说题目一定要做多少多少道，但如果你觉得你可以一心二用，从概率上来讲，你百分之九十地错了，我是个工科生，我相信概率而非奇迹。 我觉得035这方面也是值得我们学习的，我比较喜欢扯淡，有时候聊题目的时候也经常不小心就去扯其他话题去了，在学习的时候，035是坚决不多聊乱七八糟的东西的，除了讨论上QQ，平时据我观察都是残酷地训练。现在回想起来，我有点后悔，QQ上和网上花掉的时间用来学习新的东西，也许结果会更好。 ACM-ICPC绝不是大学生活的全部，也不是搞算法的全部，你大可以花时间去做其他研究，做项目，或者参加学生工作(我更欣赏那些对人生和职业有良好规划的ACMer)；但是，如果你搞ICPC的那段时间你不是全部投入，那的在ACM-ICPC生涯中，将只有后悔。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:26:20 "},"markdown/feelings/你难道没收到我的邮件.html":{"url":"markdown/feelings/你难道没收到我的邮件.html","title":"你难道没收到我的邮件？","keywords":"","body":"你难道没收到我的邮件？你难道没收到我的邮件？ —— By EXP 2014-04-23 细数公司十大经典金句之首，当孰【你难道没收到我的邮件？】无疑（了吧~ 我发誓我木有统计过）——尤其是邮件作为我们公司主要的沟通手段之一，我对这句话可谓印象深刻了。 回想刚到公司的时候，我还不会打座机电话（我承认我真的去学了打电话...），当时跟工程同事唯一的沟通手段就是邮件，有时甚至把邮件当QQ用了。但毕竟邮件不是QQ，时效性略差。有时候一些问题得不到确认，于是事后问对方最多的就是你有没有收到我的邮件了。 通常情况下，我们大部分人都有一个认知误区：只要把邮件发给对方了，对方就一定会知晓并执行，于是自己的沟通任务就完成了。但事实是，对方很可能没有（及时）收到邮件，即使收到了邮件，也不代表能够理解、接受、甚至执行。 沟通并不仅仅是发送邮件那么简单——发送邮件不过是沟通手段的一种，切莫把沟通手段和沟通过程混淆了。 真正意义上的沟通，是指思想碰撞并传递的过程。只有我和你能够以相同的角度去看待某个问题、理解其细节，才能说我和你完成了沟通。否则即使你清楚明白地看到了（听到了）我的每字每句，但是你不理解我的意思，那我和你也没有做任何有实际意义的沟通。 邮件上的沟通，按我们通常的说法，充其量只是“存证式的沟通”。确实它可以作为沟通证据，但过于依赖邮件则可能造成沟通障碍——尤其是当邮件包含的信息量越大，其中的细节就越容易被忽略。 况且信息淹没只是沟通障碍的一种。文化背景、个人偏见等主观因素也会成为沟通障碍的帮凶。为了减少类似不必要的障碍，我现在工作的时候，更倾向于面对面的、或电话式的交流，同时我也会定期写一些文章，借此向身边的人表述我近期的观点或见闻——我觉得消除障碍最好的方法就是让别人可以更直接地了解自己。 我越来越觉得，当一个问题被过于依赖用邮件去处理时候，处理周期越长，它就像抛绣球似得被抛来抛去。多用面对面或电话式的沟通，则可以促使我们在当下通过讨论去解决、反思问题。而写文章则可以避免直面的尴尬，在特定的时期向其他人表述自己的观点。 实际上，我一直以来都有写文章的习惯，而且我有自己的Blog。但自从去年开始公司办了内刊，我就把本应发表去Blog的一部分文章改投放到公司内刊了。原因有二：一是可以令身边的人更了解我的想法，增强他人对自己的熟悉感会利于平时沟通；二是我更喜欢公司有个人可以帮我对文章把关，使我的文笔有所提升——我并不介意文章被挑剔，因为我始终相信：“谁越是对你的文笔斤斤计较，谁就越可能是决定你前途的人”。 但沟通不仅仅相互理解、消除障碍就足够了。沟通也是需要策略的，首要一条就是让对方可以听懂并接受的方式去表述，否则只会徒增对方的失落感、甚至乎反感。其次就是用可以吸引对方注意力的方式去表述——我相信相比起一本新书，遍布重点的参考书更有吸引力，尤其在考试前。 最后我需要声明的是，写下这篇文章，并不是说邮件沟通有什么不好。恰恰相反，邮件作为“存证式”的沟通手段，是其他沟通方式不能替代的。而之所以用邮件说明问题，不过是作为这篇劣文一个引子，我真正所倡导的，是灵活、有效的沟通过程——这才是我们需要的——我们大可以在完成沟通后，再用邮件来存证一下不是么？ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:20:48 "},"markdown/feelings/找BUG记.html":{"url":"markdown/feelings/找BUG记.html","title":"找BUG记","keywords":"","body":"找BUG记令人头痛的陈年老BUG（序章）因注释而蔓延最危险的组合令人头痛的陈年老BUG（终章）找BUG记 —— By EXP 2014-03-22 令人头痛的陈年老BUG（序章） 前几天，码农朋友甲（下文简称“甲”）拿着我5年前发表在某博文的代码问我：“这段代码是有bug吧？”下面就是他给我指出来的一段C++代码，大家可以先尝试能不能找到甲看到的bug： void solve::Initial(void) { TimeStamp = 0; // 时间戳 DFN = new int[N+1]; // 搜索次序 Low = new int[N+1]; // 能够回溯的最早次序号 setIntArrayVal(DFN, 0, N+1); setIntArrayVal(Low, 0, N+1); SCC_id = 0; SCC = new int[N+1]; // 辅助栈 Status = new int[N+1]; // 辅助栈状态 setIntArrayVal(Status, 0, N+1); sp = new Shrink_point[N+1]; // 缩点（极大强连通分量） return; } void solve::setIntArrayVal(int* array, int val, int len) { memset(array, val, sizeof(int)*len); return; } 诚然，突然要我查一段几年前写下的代码是否有bug，我内心是比较抗拒的——尤其是我自己写的代码（我对自己还是有相当自信的）——毕竟人的弱点就是不善于揭发自己的短处。不过这都只是次要的心理因素。 归根结底，所谓打铁趁热，bug也是越早发现越好，新代码的bug总是要比历史代码的bug更容易处理。而面对这个陈年老bug，我已经完全忘记了我在5年前写这段代码的思绪，所以要我马上就应付甲的质疑是不可能的。与其再花费一番周折琢磨我自己的代码，我干脆直接就举手投问：“所有测试用例运行可以通过，是哪里有bug呢？” 因注释而蔓延 甲告诉我，是memset函数使用错误：在C++中，函数memset的作用是对一段连续的内存块赋值，即赋值的单位是字节，换而言之memset只能用于字节数组，但int数组不是字节数组。 void solve::setIntArrayVal(int* array, int val, int len) { memset(array, val, sizeof(int)*len); return; } 老实说，我很高兴甲会如此仔细的看我5年前的代码。而且毫无疑问，他的观点是正确的。但是也不见得我就是错的。因为早在那时我就已经知道memset函数的局限所在，但我坚持要用这个函数做数组的初始化，是因为我看中了它的效率—— 相对于逐个赋值的方法初始化数组元素、memset的效率要高得多，因为从寻址次数来看，前者的时间复杂度是O(n)、后者是O(1)，更何况当时所解决问题的n是上千万级别的。虽然我把memset用在非字节数组，只要我保证初始化的值只为0就不会有任何问题。事实上也是如此。 于是我自信满满地告诉甲，单纯断章取义地看我这个方法，确实是一个bug。但如果整体地去看我的代码就恰恰相反，我只是利用了bug，并得到了更高效的处理。 但是甲之后的一席话确实值得我深思： “或许对目前的这份代码而言，这个bug是被你巧妙地利用了，但是我觉得真正的bug或许不是你的代码，而是你没有文字注释去说明你的想法。不要忘记你已经共享了你的代码，当更多人看到这段程序时，如果他们不了解menset的原理就照样搬用，那么你就无异于在别人的代码中散播了bug，因为你不能把他们代码中的val限制为0。” 最危险的组合 不得不承认，甲是对的。即使我有足够的自信在5年后仍然记得利用这个bug的前因后果，但在这5年间早已误了不少别人的子弟...... 不过话说回来，先不论这个bug的蔓延性，甲能够如此深入琢磨我的历史遗留物、并发现这个bug实属难得——在软件中有一种bug是最难被发现的：组合式的bug。组合式的bug有两种类型：相辅相成型、相互弥补型——甲在我代码中发现的bug就属于后者。 相辅相成型：举例而言，一个bug是楼梯很滑，另一个bug扶手坏了，但除非这两个bug同时存在，否则只有其中一个bug是不足以让人摔下楼梯的。 相互弥补型：它与相辅相成型刚好相反，只有两个bug同时存在（或不存在）程序才会正常运行。若只修正了其中一个bug，另一个bug就会曝露出来，而且会让人有误以为自己改错了的假象，因为修改之前程序是可以正常运行的。 之所以说它难以发现，因为组合bug几乎无迹可寻，尤其是相互弥补型。除非是编译原理的狂热爱好者、抑或出现了非常极端的运行环境。存在组合bug的程序，其通常状态无异于正常程序，而且可能正常运行了很长时间都没有曝露出来。 回到我的代码，它已经正常运行5年了。如果甲没有向我质问他心中的疑惑，而是擅自修改了他所发现的bug，那么我的程序就无法正常运行了——而甲就很可能会因此陷入怀疑自己的正确性的境地。 令人头痛的陈年老BUG（终章） 事实上，不是所有bug都需要解决掉的。很多时候我们明明知道正在为代码引入一个bug，但是我们却依然保留它。因为回避它的代价太大了，我们宁愿限制它的前提条件不让它轻易发生、或者将其“圈养”起来（如try-catch）不让它暴走——如何容忍bug也是一门学问。 不过也总有一些技术葩喜欢另辟蹊径，誓言要代表月亮消灭所有bug维护代码界安全——先不说甲就是这种人，反正我是不会去消灭一个几年前就已经知道的bug的。如果要消灭它，我当时就做了，何必等到现在。 这前面提到的“新bug更易于旧bug被解决”是一个原因，但我真正担忧的是我或许会引入更多不可控的bug——代码的历史太久远了，我已经近乎忘记了它的逻辑，我一旦盲目修改，完全有可能采用了更危险的方法去解决那个稳定了5年的bug。 很多时候，我们写完一段代码，只要程序能够编译运行、完成需求功能就算完成了，鲜有考究bug的可能性，大部分的bug都是通过日后使用时再去发现和解决的。其实解决bug的黄金时间在于代码刚被编写的时候，这时候我们往往只需看到异常提示，就可以马上定位异常原因，因为潜意识中我们已经隐约觉得哪个位置会报什么异常了。 所以当我们在面对一些陈年老bug的时候，其实早就已经错过了解决它的最好时机。这时候不妨将其圈养起来，可能相比于消灭它，会令代码更安全。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 16:42:34 "},"markdown/feelings/请还我安静的4小时.html":{"url":"markdown/feelings/请还我安静的4小时.html","title":"请还我安静的4小时","keywords":"","body":"请还我安静的4小时请还我安静的4小时 —— By EXP 2014-02-28 我大概总结了我每天分配的工作时间，一般情况下，我是这样汇报我的工作情况的： 实际上，我的工作情况却可能是这样的： 表面看来，这两个时间表所完成的工作内容是一模一样的，而且第一个时间表似乎可以更清晰地表述我一天的工作情况。但是它却无法反映出我的困扰：正如第二个凌乱的时间表所示——我的工作实际上是由无数的时间碎片构成的，而我们大部分人可能早已习惯了这个不正常的时间表。 通常，管理者为了更有效率地利用时间，他们很擅长在同一个时间处理多个问题，因为这可以体现出他们处事的应变能力。但我们程序员则更倾向于能够专注地做一件事：同样一件事，相比于断断续续地做4小时，专心地连续做4小时的效率要高得多。工作本就贵在专注，而一旦那种专注的状态被破坏，要恢复这种状态非但不易、而且还会白白浪费很多时间。 大家曾经都可能玩过一个堆纸牌金字塔的游戏，越想要砌得高、所需要的专注时间越长： 程序员开发软件，就好比堆纸牌的过程，想要迅速稳固，那么从开始到完成必须一气呵成，中途不能受到一丝打扰，否则整座金字塔都会散架，只能重头开始。 开发好的软件需要投入大量的精神时间，没有一段时间的酝酿是无法开展工作的。有时我们好不容易才有了一个构思的雏形，突如其来的打扰就会造成整个构思破产。这就是为什么每个程序员都非常讨厌在工作时被打扰的原因——可能十分钟的打扰，会多浪费我们一个小时的时间——这绝不是夸大其辞。 可惜往往事与愿违，公司绝大多数的环境都不允许我们安静地坐下来，完完全全地做自己的工作。在公司每天都有着持续不断的商讨、邮件、电话需要处理，其实这些事情很多都不是主要工作，但是因为时效性要求很高，把我们真正的工作时间变得支离破碎。 此前，我看过一篇关于 “时间是如何被浪费掉”的讨论。里面有个观点大概是说，浪费时间最危险的方式不是放纵消遣，而是花时间去“做假事”。因为当我们消遣的时候，至少知道我们在放纵自己，负罪感会让我们很快地结束这种状态。而所谓的“做假事”，是指我们在工作时间做一些非实质性的工作，例如收发邮件——花一整天的时间去处理邮件不是什么难以置信的事情，而且整个过程我们都会心安理得，因为这确实是工作。但如果过后问自己今天做了什么，我想很多人的答案基本上都是什么也没干。 我每天的工作都充斥着大量的假事。这些假事本已占用了工作时间，还因为不确定的出现时机，把主要工作的时间也掺和了。我的不少朋友都说，正是由于假事太多，导致白天在公司里根本无法静下心来做任何事情。他们宁愿选择在晚上完成主要工作，而在白天做一些次要的工作——或许这恰好也就是众多程序员都是夜猫子的成因，因为晚上没人打扰。 其实就我个人而论也是如此。我有时周末需要加班，但如非必要（如协同工作），我宁愿把工作带回去家里做。一来节省了来回公司的时间，二来效率确实比在公司高得多，往往要在公司做一天的事情，我在家里可能仅仅只需要短短的几个小时。 不过公司始终是公司，沟通交流是不可避免的一环，我们无法改变这个大环境，唯有从自身作要求，首先从不频繁地打扰别人做起，希望由此可以慢慢形成一种氛围——借由提供别人安静的工作环境，换取自己安静的工作环境——我要求不高，还我安静的3 - 4小时足矣。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:47:27 "},"markdown/feelings/别让你的能力成为绊脚石.html":{"url":"markdown/feelings/别让你的能力成为绊脚石.html","title":"别让你的能力成为绊脚石","keywords":"","body":"别让你的能力成为绊脚石别让你的能力成为绊脚石 —— By EXP 2013-11-15 在溺水时拼命抓住的，真的是救命稻草吗？ 能力越强的人，往往对自己的能力越是依赖。但相对地，处理危机的灵活性可能就越弱——尤其在环境发生巨大变化时，这种能力或许就是妨碍自身拓展最大的绊脚石。 人都是善于习惯的动物：长期沉溺在单一的环境中，虽培养了能力、但同时也习惯了一成不变的感觉。尤其是在自身日益卓越的时候，更易于陶醉于自己的能力，稍有不慎便会让自负的优越感侵蚀全身，甚至于逐渐对其他技能产生淡漠感、对环境变化产生迟钝感。 俗话说“居安思危”。自身能力越是接近临界点的时候，也就是最容易让人安于现状的时候——擅长的能力难以提升、其他能力又无心拓展，一旦连最基本的危机感都失去，离被淘汰也就不远了。在此节骨眼上，往往是我们选择的分岔口：是追求精益求精、抑或探求一专多长？我不能帮任何人做出选择，但我个人认为，仅满足于一种能力对自身未必有益：在职业生涯中需要的能力是多元化的，因为这有利于我们可以在环境变化时快速反应、调整自身。我们更需要的是能及时抓住机遇，永远不要被一叶障目、成为井底之蛙。 或许终将有一日，海上刮起大浪，我们都翻船了、溺水了。这不是危言耸听。于是乎，我们为了自救，出于本能地拼命去抓住身边能够抓住的一切——而我们的能力就是我们的一切——但若是我们只有一种能力，那么能抓住的就只有这根稻草。这毫无办法，即使我们深知这根稻草恐怕无法让我们活命。 当然，并不是能力越多，活命的机会就越大，这两者并无绝对的相关性。我只是说，能力越多，我们能够选择自救的机会就越多——或者会出现浮板、甚至是木船——至少不会是那根弱不禁风的稻草。 我很清楚，我也只是个溺水的人。 但我们都将会是溺水的人。不过，我们都不应该只有一根稻草。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:43:54 "},"markdown/feelings/我们需要的是测试而非重构.html":{"url":"markdown/feelings/我们需要的是测试而非重构.html","title":"我们需要的，是测试而非重构","keywords":"","body":"我们需要的，是测试而非重构我们需要的，是测试而非重构 —— By EXP 2013-11-13 上台一鞠躬。是的，久别两个月我又回来了。 最近忙着杂七杂八的一堆事，不过基本都是维护老项目代码了。一说起这个亘古不变的老话题，估计许多人都要开始抱怨了吧：没有格式没有篇章的混乱、没有甚至是错误的注释、没有说明文档……“我可写不出这种天才代码”、“实在太难看了，我要重构”之类的话我已经听不少了。 读代码难，但写代码也不见得很容易。老代码们都有着他们自己的项目背景，经手的人也多，日积月累自然而言就变成了现在的样子了。重构——说是很容易的——先不论我们的能力跟当时开发者相比孰优孰劣，他们会写出这样的代码总有他们的理由，只是经过时间的磨蚀，当时的缘由我们就不得而知了。 重构不是对付老代码最好的手段。重构首先会遇到最大的问题，就是刚才提到的项目背景，大多数的老代码除了满足基本需求功能，后期还会不断临时加入满足某些用户需求的特殊功能，若对这些不了解就轻易地重构，势必造成代码功能缺失。 之所以那么多人要重构老代码，因为我们都对它恐惧。而恐惧，则是源于我们对它的不了解。维护老代码时，我们怕破坏它的功能、怕造成程序的不稳定……我们维护自己的代码时，何曾会怕这怕那的？希望对老代码进行重构，不过是因为我们想把它变成自己的东西、方便自己操作而已。可一旦交接给下一个人，没准他又开始喊着要重构我们的代码了吧。 老代码告诉我们的是它的基本的样貌，不到万不得已，不必通过重构对它进行整容。我们只需要使用测试用例，去矫正它在岁月中留下的伤疤。 事实上，我们也应该强迫自己持续地给老代码做测试。刚开始这样做，可能会使得进度缓慢，但长期下去，我们就会有足够的测试用例，这除了使得老代码的功能可以更健壮，也使得我们对老代码更有信心，无需再过度担心维护代码时带来的副作用。 打个比方，举重运动员为了变得更健壮，日积月累地训练，终于使得腿部筋腱开始出现断裂。不过他认为持续的锻炼会使自己最终适应这种痛苦。但正如他每次下蹲都要忍受疼痛一样，没有测试用例的老代码在各种新功能附加的重压之下也开始出现扭曲、变形。后来医生告诉他应该重点做康复锻炼，因为只有在复健后，他的肌肉会变得更结实、能够承担更多重量。同样地，针对老代码的既有功能补充测试用例，可以使得老代码更健壮，当以后交接到别人手上的时候，重构的呼声自然也就会减少了。 不过有的时候，我们拿到手的老代码是已经有一定的测试用例的了，它们也能运行成功，但是这些测试却对理解老代码毫无帮助——有些测试是为了图方便而建立的，它们之所以能运行成功，是因为这些测试都是在假设代码能够顺利运行的理想情况下建立的——我们不需要这种花瓶式的测试用例。 其实最理想的情况，就是测试用例可以完全覆盖老代码，但实际上不可能——我们也不需要那样做——字典上单词都是用到时才去查的，测试用例也一样，不然你有看到过谁把字典背下来了吗？ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:41:37 "},"markdown/feelings/月缺梦圆.html":{"url":"markdown/feelings/月缺梦圆.html","title":"月缺，梦圆。","keywords":"","body":"月缺，梦圆。月缺，梦圆。 —— By EXP 2013-09-09 又是一年中秋时。 你多久没回家看过父母了？ …… 一个星期？一个月？抑或，一年？ …… 每个孩子从小都有一个愿望：独立。殊不知是狭隘的独立。年少的我们总是向往无拘无束的自由，而这种又总是单纯地诱使我们离开家里。于是选择远一点的地方念书，便成为了最简单的方法。而我，也不例外。 在我还在读书那会，我不怎么喜欢回家，纯粹只是因为怕麻烦。 那时候每个节日对我的意义，无非就是一个休息的日子——不管是春节也好，中秋也罢。虽然都会回家一趟看看父母，但总有一种“循例”的感觉在左右。“每逢佳节倍思亲”，那时的我，其实体会不深。 然后，就毕业了。 世事往往发生在意料之外、却又意料之中的无能为力。我因为工作来到了广州，可是昔日的同窗好友，却是一个都不在这里。或许只有到了真正举目无亲的时候，那种在语文课本念了几百遍的思乡情怀才真的会油然而生吧。 我又怎么想到有一天，回家，也会变成一种奢侈。 父母总是喜欢把我的前途放在首位，每次我打电话回家，跟父母说大概什么时候回去的时候，电话那头总是说：工作要紧，没时间就不用回了。我回家的时候，经常只能待1天、甚至更短，但只要我回去了，他们都会很开心。其实时间长短又何妨，我不过希望可以带回去一份心意，而已。 或许是成长总会带来一些自负，毕业的时候，我就跟自己说不会再问家里拿1分钱。因为我没有再依赖父母的理由，也没有资格去依赖他们。但是每次在家的时候，父亲总是问我钱够不够花，母亲则总是做一桌子我喜欢的菜。——他们都怕我一个人过得不好。 其实一个人又有什么所谓好不好的。我隐约觉得，我依赖了父母20年，父母又何尝不是依赖了我20年。只是我突然有一天真的离开了父母，不用他们照顾了，他们少了一份念想，觉得不习惯吧。我现在唯一可以告诉他们的，就是我过得很好，仅此而已。 我不怕被父母依赖。倒不如说，我希望有能力被父母依赖。早几年前开始，家里的大小事，父亲都会跟我商量。我那时候总跟父亲说：爸，你喜欢就好了，怎么决定我都没意见。有一次我母亲跟我谈到这个，她跟我说：你爸现在谁都不信，最信就是你……。我那天真的觉得，父母真的都已经老了。 算上大四那年，我出来工作已经一年多了，每次回到窝里，总是空荡荡的，总有种失落感。说真的，我比较怀念上中学的日子，起码每次回家都能看见父母，只悔那时不懂珍惜。 经常有人问我：你现在工作的地方跟家里那么近，回家不也是很方便吗？是很方便。但是物理上的距离再短，也是距离。影响沟通的距离。这种距离在心里累积起来，会变成难以驱散的孤独感，我不希望父母承受那种孤独感。 现在虽然父母嘴上不说，但是我知道他们总盼我什么时候能回家，可以见上一面，但又总是怕会烦叨我，没敢叫我回家。这种滋味不好受。所以我现在的愿望，就是可以把父母接到身边，安享晚年。至少，可以让他们少了一份牵挂。“父母在，不远游”，把父母留在家里，是我心头的一根刺。 之前在网上看过一篇文章：假设父母都能活到100岁，可等到我们工作的时候，他们的人生已经过半了。剩下50年，如果我们每年只回家1次，那也只能再见父母50次而已。我不知道这种日子还能有多长。但我希望在还没有失去的时候，可以好好地珍惜它。 中秋不过是个传统，我们不应该为了过中秋而过中秋。平时哪怕再忙，也应该常回家看看，好好想想自己的父母、家人。有些恩情，是我们穷尽一辈子都还不了的。 …… 月有阴晴圆缺。 但愿人长久，千里共婵娟。 …… 最后的最后，愿大家中秋阖家团圆，愿天下父母幸福安康。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:38:06 "},"markdown/feelings/请发展你的惰性.html":{"url":"markdown/feelings/请发展你的惰性.html","title":"请发展你的惰性","keywords":"","body":"请发展你的惰性请发展你的惰性 —— By EXP 2013-08-04 你工作的时候就只是工作吗？ 我不一定。我有些时候不会把今天的所有时间都用在为了完成今天的工作任务中。而且我也相信，把全部时间都花费在工作并不代表就能很好地完成工作。 作为一个程序员，我上班时出现过的状态不外乎是三种，如果以键盘作为计量单位，那就是：不停地敲键盘、偶尔敲键盘、和不敲键盘。状态一基本就是忙于开发任务的时候，状态二一般就是调试代码的时候，而状态三就是在做跟当前工作没有直接关联的事情的时候。 如果把状态一和状态二视为对忠于工作任务的韧性，那么状态三应该就是我对工作的惰性了。不过于我而言，一和二不外乎都是体力劳动的一种，只能使我做完工作，但三却能帮我做好工作。 众所周知，程序员是脑力工作者，我们的价值在于如何运用我们的脑细胞。同样都是为工作的需求写代码，一套考虑周全的代码总比为了应付工作而写的代码生命力更持久，其维护难度也更低。其实IT行业发展至今，先辈们积累了无数这方面的知识，并作为可利用的财富流传下来，而我至今所学的也不过是沧海一粟。因此我比较喜欢看一些前人总结的经验心得，作为我忙中偷闲的乐趣，而契机不过是恰好工作有需要、或是偶尔的突发奇想罢了。 并非我们在开发和调试的过程中学不到东西，只不过这些大部分都只能够作为我们自身的经验被积累下来。要把经验转化为知识，是需要时间去顿悟的。相较之下，直接去累积前人有价值的知识，化为己用更为便捷。于当下确实是花费了一点工时，而且也未必对目前的工作任务起到关键性的作用，但之后总有其发挥价值的时候，这我深有体会。 当然，我对工作的这种惰性，有一部分是源于我对职业的兴趣，这也是使得我能够保持不疲于工作的心态的原因之一。虽然对当下工作任务而言，这种惰性有点不公，但我觉得对以后的工作、乃至于职业而言却是有好处的。 惰性是一种慢热型的能力，未必适用于所有人。即使要发展惰性，各人方向或许也有所不同，不过都应该要知道把握尺度，不要影响到相关工作的完成质量，毕竟惰性的发展并不是能够对工作不负责的借口。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:29:36 "},"markdown/feelings/优雅的烂代码.html":{"url":"markdown/feelings/优雅的烂代码.html","title":"优雅的烂代码","keywords":"","body":"优雅的烂代码优雅的烂代码 —— By EXP 2013-07-28 /** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│& 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│\" '│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │ .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ 敏捷开发是当下软件开发的主流模式之一，为了摒弃以往瀑布式开发带来的弊端，敏捷开发推崇在团队中以个人为单位进行简单的模块化开发，它更注重的是团队间的沟通和模块间的衔接。 为了使代码层面上的沟通更便捷，一套套的编码规范和设计模式应运而生，毫无疑问，使用这些规范模式会使得我们的代码看起来更优雅，经验也证明这更有利于团队沟通。 对于经验丰富的程序员而言，针对某种功能使用合理的设计模式编写出规范的代码、并提供满足功能调用的接口，可能是易如反掌的事。但每个团队中都不可避免的会存在生涩的程序员，例如我。对我而言这种方式就并不完全是这么回事了。 即使我作为一个项目经验如何不足的程序员，独立开发一个简单功能模块的能力还是具备的。经常在编写代码之前，我脑中已有完整的思路，我可以很清晰地向别人陈述我的编程思想，我也很有信心可以把这些思想变成代码。但事实上这可能比我想象的要难得多。很多时候我发现我花费了比预期更多的时间，却无法写出一段可执行的代码。因为我在编码的时候，想得更多的不是如何去实现这个功能，而是如何让别人更舒服地看懂我的代码。 虽然很多开发团队都强调代码的优雅性，但这是以“可运行性”为前提的。这种过分放大观赏性代码的地位，本就是本末倒置的行为。优雅只是交流的辅助手段，但不是唯一的手段。 事实上，如果仅是实现需求的功能，而不去考虑任何外因，我确信我可以很快地写出一段可运行的“烂代码”。烂代码与优雅代码相比，最表面的区别可能仅是可读性差而已。而且团队开发很多时候并不需要关心别人开发的功能是如何实现的，这些优雅性的问题自然也不会被马上指出来了。 当然，我并不是倡导每个人都去写烂代码。烂代码只是一个过度的产物，考虑到以后代码的维护性和可扩展性，必须在烂代码保证功能需求后，对其进行重构。而往往优雅地重构自己既成的代码，很可能要比优雅地写出构思中的代码要容易得多。 摒弃优雅性的约束，烂代码使得开发过程更轻松、耗用资源更少、编程的目的性更强。其实这与敏捷开发的部分理念恰好是一致的：有目的指向的简单构建、有辅助指向的重构勇气。这正是烂代码的优雅之道。 /** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　　　　　頂頂　　　　　 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂頂頂頂頂頂頂頂頂頂 * 　　　頂頂　　　頂頂　　　　　　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　頂頂　　頂頂頂　　頂頂 * 　　　頂頂　　　　　　　頂頂頂　 * 　　　頂頂　　　　　　頂頂　頂頂　頂頂 * 　頂頂頂頂　　　頂頂頂頂頂　頂頂頂頂頂 * 　頂頂頂頂　　　頂頂頂頂　　　頂頂頂頂 */ Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 15:28:11 "},"markdown/feelings/程序员的病态.html":{"url":"markdown/feelings/程序员的病态.html","title":"程序员的\"病态\"","keywords":"","body":"程序员的\"病态\"密集空间恐惧症强迫症神经质妄想症程序员的\"病态\" —— By EXP 2013-07-16 每个程序员都是从菜鸟过来的，而菜鸟的成长之路总是崎岖的。不断地碰壁、不断地摸索、不断地成长，从中难免衍生出各种各样的“病态”，而这其实都是我们切实作为一个程序员的证明。 密集空间恐惧症 这应是程序员的通病了。不知道是谁的谎言：“程序员每天的工作就是看着一堆01代码”，这想着都会令人疯掉吧。每个程序员最怕看到的，就是那些一堆堆没换行没缩进的代码，更何况是一堆01代码。 如果一个程序员说他没有密集空间恐惧症，那他一定就是这堆代码的创始人之一了。我不理解为什么总有一些程序员要乐此不疲地代替编译器把代码中的空字符删去，编码规范出现的初衷，很可能就是为了对付这些程序员的——即使我忘记了我曾经或许也是他们中的一员。 强迫症 一些程序员在开发一个新项目的时候，会考虑太多情况，例如这种代码在以后的运行是否稳定、维护是否方便等。尤其是有一点项目经验但又不足、而且是完美主义者的程序员，在写代码的过程中会不断地考虑设计文档没有的东西，然后就很忘我地在项目代码上画蛇添足。 往往强迫自己写一个完美的程序的人，其现实就是：由于客观因素影响（如项目工时不足），导致最后提交的代码中出现太多没有被实现的抽象方法，结果反而是自己给自己挖了一堆无法填补的坑。 神经质 基本上每个正常的程序员都有点神经质的。一个显著的特点就是：我们对自己的代码充满信心、但看到别人的代码都会疑神疑鬼，习惯性地认为那有BUG，然后千方百计地将其找出来。如果有能力把BUG修复，还会因此感到非常有成就感，尽管那个BUG是无关痛痒的。 程序界有一个“潜规则”：每个程序中80%的BUG（漏洞）都是别人发现的。这跟程序员的神经质应是脱不了干系了。 妄想症 大部分程序员最初接触到一些已经投入使用、但看上去写得很差的项目代码时，就会开始妄想自己的能力，认为自己可以用最好的技术去重写它。由于是一时冲动，欠缺考虑因素太多（如背景、支撑环境等），往往都是失败告终。 其唯一的好处可能就是在重写的过程中，可能确实学到了一些未能投入使用的新技术，仅此而已。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 13:00:41 "},"markdown/feelings/工作需要经营.html":{"url":"markdown/feelings/工作需要经营.html","title":"工作需要经营","keywords":"","body":"工作需要经营智于心，慧于行：审视自己的工作模式慎言笃行：真诚做人，踏实做事云在青天水在瓶：心态决定位置工作需要经营 —— By EXP 2013-06-18 转眼间我已实习了3个月有余，在这期间，相比于精通什么技能或业务，我更学会了应该如何去经营自己的工作。 我深深体会到工作并不是做好自己的份内事就足够的。单纯的努力工作，那只是为了谋生所付出的劳动；用心去经营的工作，才有可能会变成自己的事业。 智于心，慧于行：审视自己的工作模式 在公司里面，我被告知得更多的是如何去改善自己的工作模式，其中最倡导的是尽可能避免无意义的重复劳动。确实，平时与我们工作打交道的是各种各样的数据，要逐一去处理这些本质一样而问题各异的数据，无疑是事倍功半的行为。 好的工作模式，不仅可以提升工作效率，使我们逃离无意义劳动的怪圈，还可以实现公司价值和自身价值的双赢。而工作模式的优化，关键在于不断积累的经验。 例如平时可以多留一个心眼，把新的想法或遇到的问题进行记录，这样日积月累下来，在遇到新的问题时就不至于手忙脚乱，甚至可以利用以往类似的处理经验，达到事半功倍的效果。 不过，有好的想法固然不错，但更重要的是将其付诸行动，找到一种属于自己的工作模式，而不仅仅是纸上谈兵。 慎言笃行：真诚做人，踏实做事 “真诚做人，踏实做事”，这其实也就是我入职时了解到的企业文化之一。 做事先做人，人脉关系是经营工作的必修课。在我看来，交际圈的尺寸，与能否诚心待人是正相关的。但无论与他人相处如何，都必须谨慎言行，视场合说话。语言是把双刃剑，所谓“祸从口出”，当不知道说什么的时候，既不是阿谀奉承，也不应论人是非——不逞口舌之快，有时踏踏实实多做事，远比一切语言更具说服力。 想起我刚入职的时候，就接到了一个特殊“任务”：必须在限期内认识组内所有同事，并让他们认识我。这确实不是一个好差事，因为当时我连组内有哪些人都不清楚，就是说我连自我介绍的对象都没有……不过也不知是我人缘好还是面皮厚，这个任务最后还是完成了。 而现在的我已经结识不少其他部门的同事了，在这段期间，受到了非常多同事的包容和照顾，其实我能够这么快融入公司，离不开同事之间的良好氛围。我都甚至觉得，我的人际关系，其实是大家帮我经营起来的。 云在青天水在瓶：心态决定位置 这其实是我比较信奉的一句座右铭。云和水都是同一种物质，但是它们的形态决定了它们所处的位置。但也不应该因为身处青天而自傲，因为身处瓶中而自卑。 在职期间，我并不是所有工作都一帆风顺，我也因为规范性事故受过批评、被扣过绩效。后来也因为工作表现好而受到了表扬和奖励。但其实我个人看待事情的心态是比较淡薄的，我不会随便自暴自弃，也不会骄傲自负。我觉得既然是自己的问题，就应该承认并纠正，逃避并不是解决问题的方法；而对于嘉许，平常心看待即可。 我觉得相比于工作模式和人脉培养，工作其实更依赖于内心的修养。一份良好的心态，在一定程度上可以反映出以后工作的发展空间、以及对挫折的承受能力，甚至为自己提供了一个精神支持。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-16 12:43:21 "},"markdown/about/about_us.html":{"url":"markdown/about/about_us.html","title":"关于我们","keywords":"","body":"EXP-BLOG站点介绍站长介绍联系方式EXP-BLOG 站点介绍 本站站点是：EXP 随笔小筑（https://lyy289065406.github.io/exp-blog） 本站的文章 95% 为站长在不同时期的原创作品，初衷是为了记录学习过程中的点点滴滴以验证自身，因此所分享的内容主要取决于站长当时正在做什么方面的研究，导致覆盖到的领域可能相对比较广泛。 撰写内容以IT软件方面为主，如算法、前后端开发技能、经验心得等，尤其针对特定领域、或热门领域，会尽可能设立技术专题与大家分享。 此博客是利用 GitBook 搭建的，同时兼容在 Github Pages 和 本地（线下） 运行。 站长介绍 站长 EXP 个人简历 （JS动画） 生涯 6年 学生时期因为热衷算法，在ACM社团写了不少POJ解题报告，参与了多种校内外比赛并获得一定成绩因工作本职需要面对多种接口的海量数据，涉猎数据分析和挖掘后自然天成进阶爬虫（B站、新浪、腾讯、百度都去参观了一下）一次游戏时的偶然机会接触到了逆向工程为了跟上时代脚步开始了研究人工智能和方块链的不归路最终决定专注于安防领域的渗透测试，圆了小时候一直以来的梦想 职称 高级 系统架构师 座右铭 工作 适用的，才是最好的   生活 因上努力，果上求缘 职业技能 流程 需求、分析、设计、开发、测试、运维   文档 Markdown、Word、Excel、PPT、Visio   工具 Maven（插件/骨架）、Nexus、Jenkins、Git/SVN、Eclipse、PyCharm、VS、VMWare、Wireshark、Fiddler、OD、SecureCRT、Shadowsocks、WordPress   管理 日志管理、版本管理、构件管理、项目管理、自动化部署、自动化升级 专业技能 语言 C/C++、Java、Python、汇编、Ruby   基础 数据结构、设计模式、字符集/编码、多线程、正则、Cron、开发规范   后端 UML、数据库（SQL/NoSQL）、单元测试、Debug、逆向工程、端口转发   前端 HTML、CSS、JavaScript、PHP、Swing   协议 TCP/UDP、Socket、WebSocket、SOAP（WebServices）、HTTP/HTTPS、Cookie、XML、JSON、FTP、Telnet、MAIL、MQ（JMS/Kafka）、Corba   系统 Windows、Linux、Mac、Kali 领域技能 专题 算法、爬虫、渗透测试、大数据分析（数据挖掘）、嵌入式开发、驱动开发、深度学习、区块链   架构 Kafka、Zookeeper、Dubbo、Ansible 其他技能   构件封装、网站建设、图像处理、3D建模（OpenGL/3DMAX）、视频剪辑 联系方式 QQ：289065406 Email：289065406@qq.com Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-12-01 01:01:49 "},"markdown/about/copyright.html":{"url":"markdown/about/copyright.html","title":"版权声明","keywords":"","body":"前言免责声明隐私原则消息推送前言 我们的站点是：EXP技术博客（https://lyy289065406.github.io/exp-blog） 您使用或继续使用我们（EXP技术博客）的服务，即意味着同意我们按照本《隐私策略和版权声明》收集、使用、储存和分享您的相关信息。 如对本《隐私策略和版权声明》或相关事宜有任何问题，请通过 Email : 289065406@qq.com 与我们联系。 免责声明 本站的内容均基于《署名-非商业性使用-相同方式共享 3.0 中国大陆 (CC BY-NC-SA 3.0 CN)》协议创作或转载，您可以转载分享，但同时应该保留原文链接。 本站提供的所有内容仅供学习、分享与交流，我们不保证内容的正确性。通过使用本站内容随之而来的风险与本站无关。当使用本站时，代表您已接受本站的免责声明和隐私原则等条款。 隐私原则 本站的留言区可能会透露您的隐私信息，当您留言时，您的电子邮箱、Cookie信息和IP地址都会被记录。这些信息仅为了改进我们的网站质量和可能的交流沟通。我们不会将这些信息进行展示、出租或出售给任何人。但以下情况除外： 只有透露您的个人资料，才能提供您所要求的产品和服务； 我们需要听从法庭传票、法律命令或遵循法律程序； 我们发现您违反了本站已发布的条款或声明。 消息推送 您在使用我们的服务时，我们可能使用您的信息向您的设备发送电子邮件、新闻或推送通知。如您不希望收到这些信息，可以按照我们的相关提示，在设备上选择取消订阅。 Copyright © EXP 2019 all right reserved，powered by Gitbook最后修改时间 ： 2019-11-07 13:00:45 "}}